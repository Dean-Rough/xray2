/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(() => {
var exports = {};
exports.id = "app/api/resume-analysis/route";
exports.ids = ["app/api/resume-analysis/route"];
exports.modules = {

/***/ "@prisma/client":
/*!*********************************!*\
  !*** external "@prisma/client" ***!
  \*********************************/
/***/ ((module) => {

"use strict";
module.exports = require("@prisma/client");

/***/ }),

/***/ "next/dist/compiled/next-server/app-page.runtime.dev.js":
/*!*************************************************************************!*\
  !*** external "next/dist/compiled/next-server/app-page.runtime.dev.js" ***!
  \*************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/compiled/next-server/app-page.runtime.dev.js");

/***/ }),

/***/ "next/dist/compiled/next-server/app-route.runtime.dev.js":
/*!**************************************************************************!*\
  !*** external "next/dist/compiled/next-server/app-route.runtime.dev.js" ***!
  \**************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/compiled/next-server/app-route.runtime.dev.js");

/***/ }),

/***/ "../app-render/after-task-async-storage.external":
/*!***********************************************************************************!*\
  !*** external "next/dist/server/app-render/after-task-async-storage.external.js" ***!
  \***********************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/server/app-render/after-task-async-storage.external.js");

/***/ }),

/***/ "../app-render/work-async-storage.external":
/*!*****************************************************************************!*\
  !*** external "next/dist/server/app-render/work-async-storage.external.js" ***!
  \*****************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/server/app-render/work-async-storage.external.js");

/***/ }),

/***/ "./work-unit-async-storage.external":
/*!**********************************************************************************!*\
  !*** external "next/dist/server/app-render/work-unit-async-storage.external.js" ***!
  \**********************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/server/app-render/work-unit-async-storage.external.js");

/***/ }),

/***/ "assert":
/*!*************************!*\
  !*** external "assert" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("assert");

/***/ }),

/***/ "buffer":
/*!*************************!*\
  !*** external "buffer" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("buffer");

/***/ }),

/***/ "child_process":
/*!********************************!*\
  !*** external "child_process" ***!
  \********************************/
/***/ ((module) => {

"use strict";
module.exports = require("child_process");

/***/ }),

/***/ "crypto":
/*!*************************!*\
  !*** external "crypto" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("crypto");

/***/ }),

/***/ "events":
/*!*************************!*\
  !*** external "events" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("events");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/***/ ((module) => {

"use strict";
module.exports = require("fs");

/***/ }),

/***/ "http":
/*!***********************!*\
  !*** external "http" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("http");

/***/ }),

/***/ "https":
/*!************************!*\
  !*** external "https" ***!
  \************************/
/***/ ((module) => {

"use strict";
module.exports = require("https");

/***/ }),

/***/ "net":
/*!**********************!*\
  !*** external "net" ***!
  \**********************/
/***/ ((module) => {

"use strict";
module.exports = require("net");

/***/ }),

/***/ "os":
/*!*********************!*\
  !*** external "os" ***!
  \*********************/
/***/ ((module) => {

"use strict";
module.exports = require("os");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("path");

/***/ }),

/***/ "stream":
/*!*************************!*\
  !*** external "stream" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("stream");

/***/ }),

/***/ "tls":
/*!**********************!*\
  !*** external "tls" ***!
  \**********************/
/***/ ((module) => {

"use strict";
module.exports = require("tls");

/***/ }),

/***/ "tty":
/*!**********************!*\
  !*** external "tty" ***!
  \**********************/
/***/ ((module) => {

"use strict";
module.exports = require("tty");

/***/ }),

/***/ "url":
/*!**********************!*\
  !*** external "url" ***!
  \**********************/
/***/ ((module) => {

"use strict";
module.exports = require("url");

/***/ }),

/***/ "util":
/*!***********************!*\
  !*** external "util" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("util");

/***/ }),

/***/ "zlib":
/*!***********************!*\
  !*** external "zlib" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("zlib");

/***/ }),

/***/ "@modelcontextprotocol/sdk/client/index.js":
/*!************************************************************!*\
  !*** external "@modelcontextprotocol/sdk/client/index.js" ***!
  \************************************************************/
/***/ ((module) => {

"use strict";
module.exports = import("@modelcontextprotocol/sdk/client/index.js");;

/***/ }),

/***/ "@modelcontextprotocol/sdk/client/stdio.js":
/*!************************************************************!*\
  !*** external "@modelcontextprotocol/sdk/client/stdio.js" ***!
  \************************************************************/
/***/ ((module) => {

"use strict";
module.exports = import("@modelcontextprotocol/sdk/client/stdio.js");;

/***/ }),

/***/ "puppeteer":
/*!****************************!*\
  !*** external "puppeteer" ***!
  \****************************/
/***/ ((module) => {

"use strict";
module.exports = import("puppeteer");;

/***/ }),

/***/ "?32c4":
/*!****************************!*\
  !*** bufferutil (ignored) ***!
  \****************************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?66e9":
/*!********************************!*\
  !*** utf-8-validate (ignored) ***!
  \********************************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader/index.js?name=app%2Fapi%2Fresume-analysis%2Froute&page=%2Fapi%2Fresume-analysis%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fresume-analysis%2Froute.ts&appDir=%2FUsers%2Fdeannewton%2FDocuments%2Fxray%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2FUsers%2Fdeannewton%2FDocuments%2Fxray&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D!":
/*!***************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-app-loader/index.js?name=app%2Fapi%2Fresume-analysis%2Froute&page=%2Fapi%2Fresume-analysis%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fresume-analysis%2Froute.ts&appDir=%2FUsers%2Fdeannewton%2FDocuments%2Fxray%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2FUsers%2Fdeannewton%2FDocuments%2Fxray&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D! ***!
  \***************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   patchFetch: () => (/* binding */ patchFetch),\n/* harmony export */   routeModule: () => (/* binding */ routeModule),\n/* harmony export */   serverHooks: () => (/* binding */ serverHooks),\n/* harmony export */   workAsyncStorage: () => (/* binding */ workAsyncStorage),\n/* harmony export */   workUnitAsyncStorage: () => (/* binding */ workUnitAsyncStorage)\n/* harmony export */ });\n/* harmony import */ var next_dist_server_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/server/route-modules/app-route/module.compiled */ \"(rsc)/./node_modules/next/dist/server/route-modules/app-route/module.compiled.js\");\n/* harmony import */ var next_dist_server_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_dist_server_route_kind__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/dist/server/route-kind */ \"(rsc)/./node_modules/next/dist/server/route-kind.js\");\n/* harmony import */ var next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/dist/server/lib/patch-fetch */ \"(rsc)/./node_modules/next/dist/server/lib/patch-fetch.js\");\n/* harmony import */ var next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _Users_deannewton_Documents_xray_app_api_resume_analysis_route_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./app/api/resume-analysis/route.ts */ \"(rsc)/./app/api/resume-analysis/route.ts\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_Users_deannewton_Documents_xray_app_api_resume_analysis_route_ts__WEBPACK_IMPORTED_MODULE_3__]);\n_Users_deannewton_Documents_xray_app_api_resume_analysis_route_ts__WEBPACK_IMPORTED_MODULE_3__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n\n\n\n// We inject the nextConfigOutput here so that we can use them in the route\n// module.\nconst nextConfigOutput = \"\"\nconst routeModule = new next_dist_server_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__.AppRouteRouteModule({\n    definition: {\n        kind: next_dist_server_route_kind__WEBPACK_IMPORTED_MODULE_1__.RouteKind.APP_ROUTE,\n        page: \"/api/resume-analysis/route\",\n        pathname: \"/api/resume-analysis\",\n        filename: \"route\",\n        bundlePath: \"app/api/resume-analysis/route\"\n    },\n    resolvedPagePath: \"/Users/deannewton/Documents/xray/app/api/resume-analysis/route.ts\",\n    nextConfigOutput,\n    userland: _Users_deannewton_Documents_xray_app_api_resume_analysis_route_ts__WEBPACK_IMPORTED_MODULE_3__\n});\n// Pull out the exports that we need to expose from the module. This should\n// be eliminated when we've moved the other routes to the new format. These\n// are used to hook into the route.\nconst { workAsyncStorage, workUnitAsyncStorage, serverHooks } = routeModule;\nfunction patchFetch() {\n    return (0,next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__.patchFetch)({\n        workAsyncStorage,\n        workUnitAsyncStorage\n    });\n}\n\n\n//# sourceMappingURL=app-route.js.map\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LWFwcC1sb2FkZXIvaW5kZXguanM/bmFtZT1hcHAlMkZhcGklMkZyZXN1bWUtYW5hbHlzaXMlMkZyb3V0ZSZwYWdlPSUyRmFwaSUyRnJlc3VtZS1hbmFseXNpcyUyRnJvdXRlJmFwcFBhdGhzPSZwYWdlUGF0aD1wcml2YXRlLW5leHQtYXBwLWRpciUyRmFwaSUyRnJlc3VtZS1hbmFseXNpcyUyRnJvdXRlLnRzJmFwcERpcj0lMkZVc2VycyUyRmRlYW5uZXd0b24lMkZEb2N1bWVudHMlMkZ4cmF5JTJGYXBwJnBhZ2VFeHRlbnNpb25zPXRzeCZwYWdlRXh0ZW5zaW9ucz10cyZwYWdlRXh0ZW5zaW9ucz1qc3gmcGFnZUV4dGVuc2lvbnM9anMmcm9vdERpcj0lMkZVc2VycyUyRmRlYW5uZXd0b24lMkZEb2N1bWVudHMlMkZ4cmF5JmlzRGV2PXRydWUmdHNjb25maWdQYXRoPXRzY29uZmlnLmpzb24mYmFzZVBhdGg9JmFzc2V0UHJlZml4PSZuZXh0Q29uZmlnT3V0cHV0PSZwcmVmZXJyZWRSZWdpb249Jm1pZGRsZXdhcmVDb25maWc9ZTMwJTNEISIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUErRjtBQUN2QztBQUNxQjtBQUNpQjtBQUM5RjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IseUdBQW1CO0FBQzNDO0FBQ0EsY0FBYyxrRUFBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsWUFBWTtBQUNaLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxRQUFRLHNEQUFzRDtBQUM5RDtBQUNBLFdBQVcsNEVBQVc7QUFDdEI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUMwRjs7QUFFMUYscUMiLCJzb3VyY2VzIjpbIiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBcHBSb3V0ZVJvdXRlTW9kdWxlIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvcm91dGUtbW9kdWxlcy9hcHAtcm91dGUvbW9kdWxlLmNvbXBpbGVkXCI7XG5pbXBvcnQgeyBSb3V0ZUtpbmQgfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci9yb3V0ZS1raW5kXCI7XG5pbXBvcnQgeyBwYXRjaEZldGNoIGFzIF9wYXRjaEZldGNoIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvbGliL3BhdGNoLWZldGNoXCI7XG5pbXBvcnQgKiBhcyB1c2VybGFuZCBmcm9tIFwiL1VzZXJzL2RlYW5uZXd0b24vRG9jdW1lbnRzL3hyYXkvYXBwL2FwaS9yZXN1bWUtYW5hbHlzaXMvcm91dGUudHNcIjtcbi8vIFdlIGluamVjdCB0aGUgbmV4dENvbmZpZ091dHB1dCBoZXJlIHNvIHRoYXQgd2UgY2FuIHVzZSB0aGVtIGluIHRoZSByb3V0ZVxuLy8gbW9kdWxlLlxuY29uc3QgbmV4dENvbmZpZ091dHB1dCA9IFwiXCJcbmNvbnN0IHJvdXRlTW9kdWxlID0gbmV3IEFwcFJvdXRlUm91dGVNb2R1bGUoe1xuICAgIGRlZmluaXRpb246IHtcbiAgICAgICAga2luZDogUm91dGVLaW5kLkFQUF9ST1VURSxcbiAgICAgICAgcGFnZTogXCIvYXBpL3Jlc3VtZS1hbmFseXNpcy9yb3V0ZVwiLFxuICAgICAgICBwYXRobmFtZTogXCIvYXBpL3Jlc3VtZS1hbmFseXNpc1wiLFxuICAgICAgICBmaWxlbmFtZTogXCJyb3V0ZVwiLFxuICAgICAgICBidW5kbGVQYXRoOiBcImFwcC9hcGkvcmVzdW1lLWFuYWx5c2lzL3JvdXRlXCJcbiAgICB9LFxuICAgIHJlc29sdmVkUGFnZVBhdGg6IFwiL1VzZXJzL2RlYW5uZXd0b24vRG9jdW1lbnRzL3hyYXkvYXBwL2FwaS9yZXN1bWUtYW5hbHlzaXMvcm91dGUudHNcIixcbiAgICBuZXh0Q29uZmlnT3V0cHV0LFxuICAgIHVzZXJsYW5kXG59KTtcbi8vIFB1bGwgb3V0IHRoZSBleHBvcnRzIHRoYXQgd2UgbmVlZCB0byBleHBvc2UgZnJvbSB0aGUgbW9kdWxlLiBUaGlzIHNob3VsZFxuLy8gYmUgZWxpbWluYXRlZCB3aGVuIHdlJ3ZlIG1vdmVkIHRoZSBvdGhlciByb3V0ZXMgdG8gdGhlIG5ldyBmb3JtYXQuIFRoZXNlXG4vLyBhcmUgdXNlZCB0byBob29rIGludG8gdGhlIHJvdXRlLlxuY29uc3QgeyB3b3JrQXN5bmNTdG9yYWdlLCB3b3JrVW5pdEFzeW5jU3RvcmFnZSwgc2VydmVySG9va3MgfSA9IHJvdXRlTW9kdWxlO1xuZnVuY3Rpb24gcGF0Y2hGZXRjaCgpIHtcbiAgICByZXR1cm4gX3BhdGNoRmV0Y2goe1xuICAgICAgICB3b3JrQXN5bmNTdG9yYWdlLFxuICAgICAgICB3b3JrVW5pdEFzeW5jU3RvcmFnZVxuICAgIH0pO1xufVxuZXhwb3J0IHsgcm91dGVNb2R1bGUsIHdvcmtBc3luY1N0b3JhZ2UsIHdvcmtVbml0QXN5bmNTdG9yYWdlLCBzZXJ2ZXJIb29rcywgcGF0Y2hGZXRjaCwgIH07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFwcC1yb3V0ZS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader/index.js?name=app%2Fapi%2Fresume-analysis%2Froute&page=%2Fapi%2Fresume-analysis%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fresume-analysis%2Froute.ts&appDir=%2FUsers%2Fdeannewton%2FDocuments%2Fxray%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2FUsers%2Fdeannewton%2FDocuments%2Fxray&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D!\n");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?server=true!":
/*!******************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?server=true! ***!
  \******************************************************************************************************/
/***/ (() => {



/***/ }),

/***/ "(ssr)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?server=true!":
/*!******************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?server=true! ***!
  \******************************************************************************************************/
/***/ (() => {



/***/ }),

/***/ "(rsc)/./app/api/resume-analysis/route.ts":
/*!******************************************!*\
  !*** ./app/api/resume-analysis/route.ts ***!
  \******************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GET: () => (/* binding */ GET),\n/* harmony export */   POST: () => (/* binding */ POST)\n/* harmony export */ });\n/* harmony import */ var next_server__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/server */ \"(rsc)/./node_modules/next/dist/api/server.js\");\n/* harmony import */ var _lib_data_processing__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../lib/data-processing */ \"(rsc)/./lib/data-processing.ts\");\n/* harmony import */ var _lib_prisma_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../lib/prisma-utils */ \"(rsc)/./lib/prisma-utils.ts\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_lib_data_processing__WEBPACK_IMPORTED_MODULE_1__]);\n_lib_data_processing__WEBPACK_IMPORTED_MODULE_1__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n\n\n/**\n * POST handler for resuming failed analyses\n * @param request - The incoming request containing the analysis ID to resume\n */ async function POST(request) {\n    try {\n        // Parse request body\n        const { analysisId } = await request.json();\n        if (!analysisId) {\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                error: 'Missing analysisId parameter'\n            }, {\n                status: 400\n            });\n        }\n        console.log(`Resuming analysis: ${analysisId}`);\n        // Start the resume process\n        const result = await (0,_lib_data_processing__WEBPACK_IMPORTED_MODULE_1__.resumeFailedAnalysis)(analysisId);\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            id: result.id,\n            status: 'processing_resumed',\n            analysisId,\n            message: 'Analysis has been resumed successfully. Use the returned ID to check status.'\n        });\n    } catch (error) {\n        console.error('Error resuming analysis:', error);\n        // Check if it's a structured error from our scraping process\n        if (typeof error === 'object' && error !== null && 'type' in error) {\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                error: error.message,\n                type: error.type,\n                canResume: error.canResume,\n                suggestions: error.suggestions,\n                analysisId: error.analysisId\n            }, {\n                status: 500\n            });\n        }\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            error: error instanceof Error ? error.message : 'Failed to resume analysis'\n        }, {\n            status: 500\n        });\n    }\n}\n/**\n * GET handler for listing resumable analyses\n * @param request - The incoming request with optional query parameters\n */ async function GET(request) {\n    try {\n        const url = new URL(request.url);\n        const type = url.searchParams.get('type') || 'all'; // 'failed', 'resumable', or 'all'\n        const targetUrl = url.searchParams.get('url'); // Optional URL filter\n        let analyses;\n        if (type === 'failed') {\n            analyses = await (0,_lib_prisma_utils__WEBPACK_IMPORTED_MODULE_2__.getFailedAnalysisRequests)(10);\n        } else if (type === 'resumable') {\n            analyses = await (0,_lib_prisma_utils__WEBPACK_IMPORTED_MODULE_2__.getResumableAnalysisRequests)(targetUrl || undefined);\n        } else {\n            // Get both failed and resumable\n            const failed = await (0,_lib_prisma_utils__WEBPACK_IMPORTED_MODULE_2__.getFailedAnalysisRequests)(5);\n            const resumable = await (0,_lib_prisma_utils__WEBPACK_IMPORTED_MODULE_2__.getResumableAnalysisRequests)(targetUrl || undefined);\n            analyses = [\n                ...failed,\n                ...resumable.filter((r)=>r.status !== 'FAILED')\n            ];\n        }\n        // Format the response with useful information\n        const formattedAnalyses = analyses.map((analysis)=>({\n                id: analysis.id,\n                url: analysis.url,\n                status: analysis.status,\n                error: analysis.error,\n                createdAt: analysis.createdAt,\n                updatedAt: analysis.updatedAt,\n                processingTime: analysis.processingTime,\n                canResume: [\n                    'FAILED',\n                    'MAPPING',\n                    'SCRAPING',\n                    'PROCESSING'\n                ].includes(analysis.status),\n                lastStep: getLastCompletedStep(analysis.status),\n                estimatedResumeTime: getEstimatedResumeTime(analysis.status)\n            }));\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            analyses: formattedAnalyses,\n            total: formattedAnalyses.length,\n            type,\n            targetUrl\n        });\n    } catch (error) {\n        console.error('Error fetching resumable analyses:', error?.toString() || 'Unknown error');\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            error: error instanceof Error ? error.message : 'Failed to fetch resumable analyses'\n        }, {\n            status: 500\n        });\n    }\n}\n/**\n * Helper function to determine the last completed step\n */ function getLastCompletedStep(status) {\n    switch(status){\n        case 'PENDING':\n            return 'None';\n        case 'MAPPING':\n            return 'Database record created';\n        case 'SCRAPING':\n            return 'Site mapping completed';\n        case 'PROCESSING':\n            return 'Content scraping completed';\n        case 'FAILED':\n            return 'Process failed at some point';\n        case 'COMPLETED':\n            return 'All steps completed';\n        default:\n            return 'Unknown';\n    }\n}\n/**\n * Helper function to estimate resume time based on status\n */ function getEstimatedResumeTime(status) {\n    switch(status){\n        case 'PENDING':\n        case 'FAILED':\n            return '5-10 minutes (full process)';\n        case 'MAPPING':\n            return '4-8 minutes (from mapping)';\n        case 'SCRAPING':\n            return '3-6 minutes (from scraping)';\n        case 'PROCESSING':\n            return '1-3 minutes (from processing)';\n        case 'COMPLETED':\n            return 'Already completed';\n        default:\n            return 'Unknown';\n    }\n}\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Z0JBQzlDK0IscUJBQXFCQyx1QkFBdUJSLFNBQVN4QixNQUFNO1lBQzdEO1FBRUEsT0FBT1QscURBQVlBLENBQUNPLElBQUksQ0FBQztZQUN2QmtCLFVBQVVNO1lBQ1ZXLE9BQU9YLGtCQUFrQlksTUFBTTtZQUMvQjVCO1lBQ0FTO1FBQ0Y7SUFDRixFQUFFLE9BQU9oQixPQUFPO1FBQ2RFLFFBQVFGLEtBQUssQ0FBQyxzQ0FBc0NBLE9BQU9vQyxjQUFjO1FBRXpFLE9BQU81QyxxREFBWUEsQ0FBQ08sSUFBSSxDQUN0QjtZQUFFQyxPQUFPQSxpQkFBaUJVLFFBQVFWLE1BQU1NLE9BQU8sR0FBRztRQUFxQyxHQUN2RjtZQUFFTCxRQUFRO1FBQUk7SUFFbEI7QUFDRjtBQUVBOztDQUVDLEdBQ0QsU0FBUzhCLHFCQUFxQjlCLE1BQWM7SUFDMUMsT0FBUUE7UUFDTixLQUFLO1lBQ0gsT0FBTztRQUNULEtBQUs7WUFDSCxPQUFPO1FBQ1QsS0FBSztZQUNILE9BQU87UUFDVCxLQUFLO1lBQ0gsT0FBTztRQUNULEtBQUs7WUFDSCxPQUFPO1FBQ1QsS0FBSztZQUNILE9BQU87UUFDVDtZQUNFLE9BQU87SUFDWDtBQUNGO0FBRUE7O0NBRUMsR0FDRCxTQUFTZ0MsdUJBQXVCaEMsTUFBYztJQUM1QyxPQUFRQTtRQUNOLEtBQUs7UUFDTCxLQUFLO1lBQ0gsT0FBTztRQUNULEtBQUs7WUFDSCxPQUFPO1FBQ1QsS0FBSztZQUNILE9BQU87UUFDVCxLQUFLO1lBQ0gsT0FBTztRQUNULEtBQUs7WUFDSCxPQUFPO1FBQ1Q7WUFDRSxPQUFPO0lBQ1g7QUFDRiIsInNvdXJjZXMiOlsiL1VzZXJzL2RlYW5uZXd0b24vRG9jdW1lbnRzL3hyYXkvYXBwL2FwaS9yZXN1bWUtYW5hbHlzaXMvcm91dGUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTmV4dFJlcXVlc3QsIE5leHRSZXNwb25zZSB9IGZyb20gJ25leHQvc2VydmVyJztcbmltcG9ydCB7IHJlc3VtZUZhaWxlZEFuYWx5c2lzIH0gZnJvbSAnLi4vLi4vLi4vbGliL2RhdGEtcHJvY2Vzc2luZyc7XG5pbXBvcnQgeyBnZXRSZXN1bWFibGVBbmFseXNpc1JlcXVlc3RzLCBnZXRGYWlsZWRBbmFseXNpc1JlcXVlc3RzIH0gZnJvbSAnLi4vLi4vLi4vbGliL3ByaXNtYS11dGlscyc7XG5cbi8qKlxuICogUE9TVCBoYW5kbGVyIGZvciByZXN1bWluZyBmYWlsZWQgYW5hbHlzZXNcbiAqIEBwYXJhbSByZXF1ZXN0IC0gVGhlIGluY29taW5nIHJlcXVlc3QgY29udGFpbmluZyB0aGUgYW5hbHlzaXMgSUQgdG8gcmVzdW1lXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBQT1NUKHJlcXVlc3Q6IE5leHRSZXF1ZXN0KSB7XG4gIHRyeSB7XG4gICAgLy8gUGFyc2UgcmVxdWVzdCBib2R5XG4gICAgY29uc3QgeyBhbmFseXNpc0lkIH0gPSBhd2FpdCByZXF1ZXN0Lmpzb24oKTtcblxuICAgIGlmICghYW5hbHlzaXNJZCkge1xuICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKFxuICAgICAgICB7IGVycm9yOiAnTWlzc2luZyBhbmFseXNpc0lkIHBhcmFtZXRlcicgfSxcbiAgICAgICAgeyBzdGF0dXM6IDQwMCB9XG4gICAgICApO1xuICAgIH1cblxuICAgIGNvbnNvbGUubG9nKGBSZXN1bWluZyBhbmFseXNpczogJHthbmFseXNpc0lkfWApO1xuXG4gICAgLy8gU3RhcnQgdGhlIHJlc3VtZSBwcm9jZXNzXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzdW1lRmFpbGVkQW5hbHlzaXMoYW5hbHlzaXNJZCk7XG5cbiAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oe1xuICAgICAgaWQ6IHJlc3VsdC5pZCxcbiAgICAgIHN0YXR1czogJ3Byb2Nlc3NpbmdfcmVzdW1lZCcsXG4gICAgICBhbmFseXNpc0lkLFxuICAgICAgbWVzc2FnZTogJ0FuYWx5c2lzIGhhcyBiZWVuIHJlc3VtZWQgc3VjY2Vzc2Z1bGx5LiBVc2UgdGhlIHJldHVybmVkIElEIHRvIGNoZWNrIHN0YXR1cy4nXG4gICAgfSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgcmVzdW1pbmcgYW5hbHlzaXM6JywgZXJyb3IpO1xuXG4gICAgLy8gQ2hlY2sgaWYgaXQncyBhIHN0cnVjdHVyZWQgZXJyb3IgZnJvbSBvdXIgc2NyYXBpbmcgcHJvY2Vzc1xuICAgIGlmICh0eXBlb2YgZXJyb3IgPT09ICdvYmplY3QnICYmIGVycm9yICE9PSBudWxsICYmICd0eXBlJyBpbiBlcnJvcikge1xuICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKFxuICAgICAgICB7XG4gICAgICAgICAgZXJyb3I6IChlcnJvciBhcyBhbnkpLm1lc3NhZ2UsXG4gICAgICAgICAgdHlwZTogKGVycm9yIGFzIGFueSkudHlwZSxcbiAgICAgICAgICBjYW5SZXN1bWU6IChlcnJvciBhcyBhbnkpLmNhblJlc3VtZSxcbiAgICAgICAgICBzdWdnZXN0aW9uczogKGVycm9yIGFzIGFueSkuc3VnZ2VzdGlvbnMsXG4gICAgICAgICAgYW5hbHlzaXNJZDogKGVycm9yIGFzIGFueSkuYW5hbHlzaXNJZFxuICAgICAgICB9LFxuICAgICAgICB7IHN0YXR1czogNTAwIH1cbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKFxuICAgICAgeyBlcnJvcjogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnRmFpbGVkIHRvIHJlc3VtZSBhbmFseXNpcycgfSxcbiAgICAgIHsgc3RhdHVzOiA1MDAgfVxuICAgICk7XG4gIH1cbn1cblxuLyoqXG4gKiBHRVQgaGFuZGxlciBmb3IgbGlzdGluZyByZXN1bWFibGUgYW5hbHlzZXNcbiAqIEBwYXJhbSByZXF1ZXN0IC0gVGhlIGluY29taW5nIHJlcXVlc3Qgd2l0aCBvcHRpb25hbCBxdWVyeSBwYXJhbWV0ZXJzXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBHRVQocmVxdWVzdDogTmV4dFJlcXVlc3QpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCB1cmwgPSBuZXcgVVJMKHJlcXVlc3QudXJsKTtcbiAgICBjb25zdCB0eXBlID0gdXJsLnNlYXJjaFBhcmFtcy5nZXQoJ3R5cGUnKSB8fCAnYWxsJzsgLy8gJ2ZhaWxlZCcsICdyZXN1bWFibGUnLCBvciAnYWxsJ1xuICAgIGNvbnN0IHRhcmdldFVybCA9IHVybC5zZWFyY2hQYXJhbXMuZ2V0KCd1cmwnKTsgLy8gT3B0aW9uYWwgVVJMIGZpbHRlclxuXG4gICAgbGV0IGFuYWx5c2VzO1xuXG4gICAgaWYgKHR5cGUgPT09ICdmYWlsZWQnKSB7XG4gICAgICBhbmFseXNlcyA9IGF3YWl0IGdldEZhaWxlZEFuYWx5c2lzUmVxdWVzdHMoMTApO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3Jlc3VtYWJsZScpIHtcbiAgICAgIGFuYWx5c2VzID0gYXdhaXQgZ2V0UmVzdW1hYmxlQW5hbHlzaXNSZXF1ZXN0cyh0YXJnZXRVcmwgfHwgdW5kZWZpbmVkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gR2V0IGJvdGggZmFpbGVkIGFuZCByZXN1bWFibGVcbiAgICAgIGNvbnN0IGZhaWxlZCA9IGF3YWl0IGdldEZhaWxlZEFuYWx5c2lzUmVxdWVzdHMoNSk7XG4gICAgICBjb25zdCByZXN1bWFibGUgPSBhd2FpdCBnZXRSZXN1bWFibGVBbmFseXNpc1JlcXVlc3RzKHRhcmdldFVybCB8fCB1bmRlZmluZWQpO1xuICAgICAgYW5hbHlzZXMgPSBbLi4uZmFpbGVkLCAuLi5yZXN1bWFibGUuZmlsdGVyKHIgPT4gci5zdGF0dXMgIT09ICdGQUlMRUQnKV07XG4gICAgfVxuXG4gICAgLy8gRm9ybWF0IHRoZSByZXNwb25zZSB3aXRoIHVzZWZ1bCBpbmZvcm1hdGlvblxuICAgIGNvbnN0IGZvcm1hdHRlZEFuYWx5c2VzID0gYW5hbHlzZXMubWFwKGFuYWx5c2lzID0+ICh7XG4gICAgICBpZDogYW5hbHlzaXMuaWQsXG4gICAgICB1cmw6IGFuYWx5c2lzLnVybCxcbiAgICAgIHN0YXR1czogYW5hbHlzaXMuc3RhdHVzLFxuICAgICAgZXJyb3I6IGFuYWx5c2lzLmVycm9yLFxuICAgICAgY3JlYXRlZEF0OiBhbmFseXNpcy5jcmVhdGVkQXQsXG4gICAgICB1cGRhdGVkQXQ6IGFuYWx5c2lzLnVwZGF0ZWRBdCxcbiAgICAgIHByb2Nlc3NpbmdUaW1lOiBhbmFseXNpcy5wcm9jZXNzaW5nVGltZSxcbiAgICAgIGNhblJlc3VtZTogWydGQUlMRUQnLCAnTUFQUElORycsICdTQ1JBUElORycsICdQUk9DRVNTSU5HJ10uaW5jbHVkZXMoYW5hbHlzaXMuc3RhdHVzKSxcbiAgICAgIGxhc3RTdGVwOiBnZXRMYXN0Q29tcGxldGVkU3RlcChhbmFseXNpcy5zdGF0dXMpLFxuICAgICAgZXN0aW1hdGVkUmVzdW1lVGltZTogZ2V0RXN0aW1hdGVkUmVzdW1lVGltZShhbmFseXNpcy5zdGF0dXMpXG4gICAgfSkpO1xuXG4gICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKHtcbiAgICAgIGFuYWx5c2VzOiBmb3JtYXR0ZWRBbmFseXNlcyxcbiAgICAgIHRvdGFsOiBmb3JtYXR0ZWRBbmFseXNlcy5sZW5ndGgsXG4gICAgICB0eXBlLFxuICAgICAgdGFyZ2V0VXJsXG4gICAgfSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgcmVzdW1hYmxlIGFuYWx5c2VzOicsIGVycm9yPy50b1N0cmluZygpIHx8ICdVbmtub3duIGVycm9yJyk7XG5cbiAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oXG4gICAgICB7IGVycm9yOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdGYWlsZWQgdG8gZmV0Y2ggcmVzdW1hYmxlIGFuYWx5c2VzJyB9LFxuICAgICAgeyBzdGF0dXM6IDUwMCB9XG4gICAgKTtcbiAgfVxufVxuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBkZXRlcm1pbmUgdGhlIGxhc3QgY29tcGxldGVkIHN0ZXBcbiAqL1xuZnVuY3Rpb24gZ2V0TGFzdENvbXBsZXRlZFN0ZXAoc3RhdHVzOiBzdHJpbmcpOiBzdHJpbmcge1xuICBzd2l0Y2ggKHN0YXR1cykge1xuICAgIGNhc2UgJ1BFTkRJTkcnOlxuICAgICAgcmV0dXJuICdOb25lJztcbiAgICBjYXNlICdNQVBQSU5HJzpcbiAgICAgIHJldHVybiAnRGF0YWJhc2UgcmVjb3JkIGNyZWF0ZWQnO1xuICAgIGNhc2UgJ1NDUkFQSU5HJzpcbiAgICAgIHJldHVybiAnU2l0ZSBtYXBwaW5nIGNvbXBsZXRlZCc7XG4gICAgY2FzZSAnUFJPQ0VTU0lORyc6XG4gICAgICByZXR1cm4gJ0NvbnRlbnQgc2NyYXBpbmcgY29tcGxldGVkJztcbiAgICBjYXNlICdGQUlMRUQnOlxuICAgICAgcmV0dXJuICdQcm9jZXNzIGZhaWxlZCBhdCBzb21lIHBvaW50JztcbiAgICBjYXNlICdDT01QTEVURUQnOlxuICAgICAgcmV0dXJuICdBbGwgc3RlcHMgY29tcGxldGVkJztcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuICdVbmtub3duJztcbiAgfVxufVxuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBlc3RpbWF0ZSByZXN1bWUgdGltZSBiYXNlZCBvbiBzdGF0dXNcbiAqL1xuZnVuY3Rpb24gZ2V0RXN0aW1hdGVkUmVzdW1lVGltZShzdGF0dXM6IHN0cmluZyk6IHN0cmluZyB7XG4gIHN3aXRjaCAoc3RhdHVzKSB7XG4gICAgY2FzZSAnUEVORElORyc6XG4gICAgY2FzZSAnRkFJTEVEJzpcbiAgICAgIHJldHVybiAnNS0xMCBtaW51dGVzIChmdWxsIHByb2Nlc3MpJztcbiAgICBjYXNlICdNQVBQSU5HJzpcbiAgICAgIHJldHVybiAnNC04IG1pbnV0ZXMgKGZyb20gbWFwcGluZyknO1xuICAgIGNhc2UgJ1NDUkFQSU5HJzpcbiAgICAgIHJldHVybiAnMy02IG1pbnV0ZXMgKGZyb20gc2NyYXBpbmcpJztcbiAgICBjYXNlICdQUk9DRVNTSU5HJzpcbiAgICAgIHJldHVybiAnMS0zIG1pbnV0ZXMgKGZyb20gcHJvY2Vzc2luZyknO1xuICAgIGNhc2UgJ0NPTVBMRVRFRCc6XG4gICAgICByZXR1cm4gJ0FscmVhZHkgY29tcGxldGVkJztcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuICdVbmtub3duJztcbiAgfVxufVxuIl0sIm5hbWVzIjpbIk5leHRSZXNwb25zZSIsInJlc3VtZUZhaWxlZEFuYWx5c2lzIiwiZ2V0UmVzdW1hYmxlQW5hbHlzaXNSZXF1ZXN0cyIsImdldEZhaWxlZEFuYWx5c2lzUmVxdWVzdHMiLCJQT1NUIiwicmVxdWVzdCIsImFuYWx5c2lzSWQiLCJqc29uIiwiZXJyb3IiLCJzdGF0dXMiLCJjb25zb2xlIiwibG9nIiwicmVzdWx0IiwiaWQiLCJtZXNzYWdlIiwidHlwZSIsImNhblJlc3VtZSIsInN1Z2dlc3Rpb25zIiwiRXJyb3IiLCJHRVQiLCJ1cmwiLCJVUkwiLCJzZWFyY2hQYXJhbXMiLCJnZXQiLCJ0YXJnZXRVcmwiLCJhbmFseXNlcyIsInVuZGVmaW5lZCIsImZhaWxlZCIsInJlc3VtYWJsZSIsImZpbHRlciIsInIiLCJmb3JtYXR0ZWRBbmFseXNlcyIsIm1hcCIsImFuYWx5c2lzIiwiY3JlYXRlZEF0IiwidXBkYXRlZEF0IiwicHJvY2Vzc2luZ1RpbWUiLCJpbmNsdWRlcyIsImxhc3RTdGVwIiwiZ2V0TGFzdENvbXBsZXRlZFN0ZXAiLCJlc3RpbWF0ZWRSZXN1bWVUaW1lIiwiZ2V0RXN0aW1hdGVkUmVzdW1lVGltZSIsInRvdGFsIiwibGVuZ3RoIiwidG9TdHJpbmciXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./app/api/resume-analysis/route.ts\n");

/***/ }),

/***/ "(rsc)/./lib/data-processing.ts":
/*!********************************!*\
  !*** ./lib/data-processing.ts ***!
  \********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   deepScrapeWebsite: () => (/* binding */ deepScrapeWebsite),\n/* harmony export */   generateFinalPrompt: () => (/* binding */ generateFinalPrompt),\n/* harmony export */   processContentData: () => (/* binding */ processContentData),\n/* harmony export */   processPerformanceData: () => (/* binding */ processPerformanceData),\n/* harmony export */   processSiteMap: () => (/* binding */ processSiteMap),\n/* harmony export */   resumeFailedAnalysis: () => (/* binding */ resumeFailedAnalysis),\n/* harmony export */   runLighthouseAudit: () => (/* binding */ runLighthouseAudit)\n/* harmony export */ });\n/* harmony import */ var _mcp_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./mcp-utils */ \"(rsc)/./lib/mcp-utils.ts\");\n/* harmony import */ var _firecrawl_mcp_client__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./firecrawl-mcp-client */ \"(rsc)/./lib/firecrawl-mcp-client.ts\");\n/* harmony import */ var _prisma_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./prisma-utils */ \"(rsc)/./lib/prisma-utils.ts\");\n/* harmony import */ var _generate_docs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./generate-docs */ \"(rsc)/./lib/generate-docs.ts\");\n/* harmony import */ var child_process__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! child_process */ \"child_process\");\n/* harmony import */ var child_process__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(child_process__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! util */ \"util\");\n/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(util__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! fs */ \"fs\");\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! path */ \"path\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_7__);\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_firecrawl_mcp_client__WEBPACK_IMPORTED_MODULE_1__]);\n_firecrawl_mcp_client__WEBPACK_IMPORTED_MODULE_1__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n/**\n * Data processing utilities for the Website Rebuild Prompt Generator\n * Handles parsing and structuring data from Firecrawl and Lighthouse\n */ \n\n\n\n\n\n\n\nconst execAsync = (0,util__WEBPACK_IMPORTED_MODULE_5__.promisify)(child_process__WEBPACK_IMPORTED_MODULE_4__.exec);\n/**\n * Process raw Firecrawl site map data into a structured format\n * @param rawData - Raw data from Firecrawl site mapping\n * @returns Processed site structure data\n */ function processSiteMap(rawData) {\n    try {\n        // Extract URLs from the raw data\n        const urls = Array.isArray(rawData) ? rawData : [];\n        // Group URLs by path segments to create a hierarchical structure\n        const structure = {};\n        urls.forEach((url)=>{\n            try {\n                const urlObj = new URL(url);\n                const pathSegments = urlObj.pathname.split('/').filter(Boolean);\n                let currentLevel = structure;\n                pathSegments.forEach((segment, index)=>{\n                    if (!currentLevel[segment]) {\n                        currentLevel[segment] = {};\n                    }\n                    currentLevel = currentLevel[segment];\n                    // Add the full URL as a leaf node if this is the last segment\n                    if (index === pathSegments.length - 1) {\n                        currentLevel['__url'] = url;\n                    }\n                });\n            } catch (error) {\n                console.warn(`Error processing URL: ${url}`, error);\n            }\n        });\n        return {\n            pages: urls,\n            structure,\n            metadata: {\n                createdAt: new Date().toISOString(),\n                version: '1.0.0',\n                totalPages: urls.length\n            }\n        };\n    } catch (error) {\n        console.error('Error processing site map data:', error);\n        return {\n            pages: [],\n            structure: {},\n            metadata: {\n                createdAt: new Date().toISOString(),\n                version: '1.0.0',\n                error: error instanceof Error ? error.message : String(error)\n            }\n        };\n    }\n}\n/**\n * Process raw Firecrawl content scraping data into structured documentation format\n * @param rawData - Raw data from Firecrawl content scraping\n * @returns Processed content data\n */ async function processContentData(rawData) {\n    try {\n        if (!rawData) {\n            throw new Error('No content data provided');\n        }\n        const data = rawData;\n        // Extract HTML content\n        const html = data.html || data.rawHtml || '';\n        // Extract markdown content\n        const markdown = data.markdown || '';\n        // Extract links\n        const links = data.links || [];\n        // Extract assets (CSS, JS, images, etc.)\n        const assets = [];\n        // Use CSS content from Firecrawl if available, otherwise extract from HTML\n        let cssContents = {};\n        // First, try to use cssContents from Firecrawl\n        if (data.cssContents && typeof data.cssContents === 'object') {\n            cssContents = data.cssContents;\n            console.log(`✅ Using CSS content from Firecrawl: ${Object.keys(cssContents).length} files`);\n            // Add CSS files to assets\n            Object.entries(cssContents).forEach(([cssUrl, cssContent])=>{\n                assets.push({\n                    url: cssUrl,\n                    type: 'css',\n                    content: cssContent\n                });\n            });\n        } else {\n            // Fallback: Extract CSS links from HTML and fetch content manually\n            console.log('⚠️ No cssContents from Firecrawl, falling back to manual CSS extraction');\n            const cssLinks = extractResourceLinks(html, 'link[rel=\"stylesheet\"]', 'href');\n            for (const cssUrl of cssLinks){\n                try {\n                    // Skip invalid URLs (like cid: URLs from MHTML, data: URLs, etc.)\n                    if (cssUrl.startsWith('cid:') || cssUrl.startsWith('data:') || cssUrl.startsWith('blob:') || cssUrl.startsWith('javascript:')) {\n                        console.log(`⚠️ Skipping invalid CSS URL: ${cssUrl}`);\n                        assets.push({\n                            url: cssUrl,\n                            type: 'css',\n                            error: 'Invalid URL format'\n                        });\n                        continue;\n                    }\n                    // Resolve relative URLs\n                    const absoluteUrl = cssUrl.startsWith('http') ? cssUrl : new URL(cssUrl, data.url || '').href;\n                    // Fetch CSS content\n                    const cssContent = await fetchCSSContent(absoluteUrl);\n                    if (cssContent) {\n                        cssContents[cssUrl] = cssContent;\n                        console.log(`✅ Extracted CSS content from: ${cssUrl} (${cssContent.length} chars)`);\n                    }\n                    assets.push({\n                        url: cssUrl,\n                        type: 'css',\n                        content: cssContent || undefined\n                    });\n                } catch (error) {\n                    console.error(`❌ Failed to fetch CSS from ${cssUrl}:`, error);\n                    assets.push({\n                        url: cssUrl,\n                        type: 'css',\n                        error: 'Failed to fetch content'\n                    });\n                }\n            }\n        }\n        // Process JS links\n        const jsLinks = extractResourceLinks(html, 'script[src]', 'src');\n        jsLinks.forEach((url)=>{\n            assets.push({\n                url,\n                type: 'javascript' // Use lowercase for consistency\n            });\n        });\n        // Process image links\n        const imageLinks = extractResourceLinks(html, 'img[src]', 'src');\n        imageLinks.forEach((url)=>{\n            assets.push({\n                url,\n                type: 'image' // Use lowercase for consistency\n            });\n        });\n        // Extract metadata\n        const metadata = extractMetadata(html);\n        return {\n            html,\n            markdown,\n            links,\n            assets,\n            metadata,\n            cssContents,\n            screenshot: rawData.screenshot || rawData.data?.screenshot || null,\n            createdAt: new Date().toISOString(),\n            version: '1.0.0'\n        };\n    } catch (error) {\n        console.error('Error processing content data:', error);\n        return {\n            html: '',\n            markdown: '',\n            links: [],\n            assets: [],\n            metadata: {},\n            screenshot: null,\n            createdAt: new Date().toISOString(),\n            version: '1.0.0',\n            error: error instanceof Error ? error.message : String(error)\n        };\n    }\n}\n/**\n * Fetch CSS content from a URL\n * @param url - CSS file URL\n * @returns CSS content as string\n */ async function fetchCSSContent(url) {\n    try {\n        const response = await fetch(url, {\n            headers: {\n                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'\n            },\n            timeout: 10000\n        });\n        if (!response.ok) {\n            throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n        }\n        const contentType = response.headers.get('content-type') || '';\n        if (!contentType.includes('text/css') && !contentType.includes('text/plain')) {\n            console.warn(`Warning: CSS URL returned unexpected content-type: ${contentType}`);\n        }\n        return await response.text();\n    } catch (error) {\n        console.error(`Failed to fetch CSS from ${url}:`, error);\n        return null;\n    }\n}\n/**\n * Extract resource links from HTML content\n * @param html - HTML content\n * @param selector - CSS selector for the elements\n * @param attribute - Attribute to extract\n * @returns Array of resource URLs\n */ function extractResourceLinks(html, selector, attribute) {\n    const links = [];\n    // Simple regex-based extraction (in a real implementation, use a proper HTML parser)\n    const regex = new RegExp(`<${selector.split('[')[0]}[^>]*${attribute}=[\"']([^\"']+)[\"'][^>]*>`, 'gi');\n    let match;\n    while((match = regex.exec(html)) !== null){\n        if (match[1]) {\n            links.push(match[1]);\n        }\n    }\n    return links;\n}\n/**\n * Extract metadata from HTML content\n * @param html - HTML content\n * @returns Metadata object\n */ function extractMetadata(html) {\n    const metadata = {};\n    // Extract title\n    const titleMatch = html.match(/<title[^>]*>(.*?)<\\/title>/i);\n    if (titleMatch && titleMatch[1]) {\n        metadata.title = titleMatch[1];\n    }\n    // Extract meta tags\n    const metaRegex = /<meta[^>]*name=[\"']([^\"']+)[\"'][^>]*content=[\"']([^\"']+)[\"'][^>]*>/gi;\n    let metaMatch;\n    while((metaMatch = metaRegex.exec(html)) !== null){\n        if (metaMatch[1] && metaMatch[2]) {\n            metadata[metaMatch[1]] = metaMatch[2];\n        }\n    }\n    return metadata;\n}\n/**\n * Process Lighthouse performance metrics into a structured format\n * @param rawData - Raw Lighthouse audit data\n * @returns Processed performance metrics\n */ function processPerformanceData(rawData) {\n    try {\n        const data = rawData;\n        if (!rawData || !data.categories) {\n            throw new Error('Invalid Lighthouse data format');\n        }\n        const categories = data.categories;\n        const audits = data.audits;\n        // Extract scores from categories\n        const performance = {\n            score: categories.performance?.score || 0,\n            metrics: {}\n        };\n        const accessibility = {\n            score: categories.accessibility?.score || 0,\n            metrics: {}\n        };\n        const seo = {\n            score: categories.seo?.score || 0,\n            metrics: {}\n        };\n        const bestPractices = {\n            score: categories['best-practices']?.score || 0,\n            metrics: {}\n        };\n        // Extract key metrics from audits\n        if (audits) {\n            // Performance metrics\n            if (audits['first-contentful-paint']) {\n                const audit = audits['first-contentful-paint'];\n                performance.metrics['firstContentfulPaint'] = {\n                    score: audit.score,\n                    value: audit.numericValue\n                };\n            }\n            if (audits['largest-contentful-paint']) {\n                const audit = audits['largest-contentful-paint'];\n                performance.metrics['largestContentfulPaint'] = {\n                    score: audit.score,\n                    value: audit.numericValue\n                };\n            }\n            if (audits['total-blocking-time']) {\n                const audit = audits['total-blocking-time'];\n                performance.metrics['totalBlockingTime'] = {\n                    score: audit.score,\n                    value: audit.numericValue\n                };\n            }\n            if (audits['cumulative-layout-shift']) {\n                const audit = audits['cumulative-layout-shift'];\n                performance.metrics['cumulativeLayoutShift'] = {\n                    score: audit.score,\n                    value: audit.numericValue\n                };\n            }\n            // Accessibility metrics\n            if (audits['aria-required-attr']) {\n                const audit = audits['aria-required-attr'];\n                accessibility.metrics['ariaRequiredAttr'] = {\n                    score: audit.score,\n                    details: audit.details\n                };\n            }\n            // SEO metrics\n            if (audits['meta-description']) {\n                const audit = audits['meta-description'];\n                seo.metrics['metaDescription'] = {\n                    score: audit.score,\n                    details: audit.details\n                };\n            }\n            // Best practices metrics\n            if (audits['doctype']) {\n                const audit = audits['doctype'];\n                bestPractices.metrics['doctype'] = {\n                    score: audit.score,\n                    details: audit.details\n                };\n            }\n        }\n        return {\n            performance,\n            accessibility,\n            seo,\n            bestPractices,\n            metadata: {\n                createdAt: new Date().toISOString(),\n                version: '1.0.0'\n            }\n        };\n    } catch (error) {\n        console.error('Error processing performance data:', error);\n        return {\n            performance: {\n                score: 0,\n                metrics: {}\n            },\n            accessibility: {\n                score: 0,\n                metrics: {}\n            },\n            seo: {\n                score: 0,\n                metrics: {}\n            },\n            bestPractices: {\n                score: 0,\n                metrics: {}\n            },\n            metadata: {\n                createdAt: new Date().toISOString(),\n                version: '1.0.0',\n                error: error instanceof Error ? error.message : String(error)\n            }\n        };\n    }\n}\n/**\n * Combine all processed data into the final prompt structure\n * @param siteMapData - Processed site map data\n * @param contentData - Processed content data\n * @param performanceData - Processed performance data\n * @returns Final structured prompt data\n */ function generateFinalPrompt(siteMapData, contentData, performanceData) {\n    return {\n        siteStructure: siteMapData,\n        content: contentData,\n        performance: performanceData,\n        structuredData: {},\n        metadata: {\n            generatedAt: new Date().toISOString(),\n            version: '1.0.0',\n            generatedFor: 'Claude Sonnet AI IDE'\n        },\n        instructions: {\n            title: 'Website Rebuild Instructions',\n            description: 'This prompt contains comprehensive data for rebuilding the analyzed website with maximum fidelity.',\n            steps: [\n                'Analyze the site structure to understand the overall architecture',\n                'Review the HTML content for each page to understand the markup structure',\n                'Examine the CSS and JavaScript assets to understand styling and functionality',\n                'Consider the performance metrics to optimize the rebuild',\n                'Implement the website following the provided structure and content'\n            ]\n        }\n    };\n}\n/**\n * Perform AI audit of scraped data for quality assurance\n * @param siteMapData - Site mapping data\n * @param contentData - Content scraping data\n * @param performanceData - Performance analysis data\n * @returns Audited and cleaned data\n */ async function performAIAudit(siteMapData, contentData, performanceData) {\n    // TODO: Implement AI audit functionality\n    // This would use OpenAI API to:\n    // 1. Review scraped content for completeness\n    // 2. Identify missing critical elements\n    // 3. Suggest improvements to the rebuild package\n    // 4. Clean up any inconsistencies in the data\n    // 5. Enhance the AI prompt with better instructions\n    console.log('AI audit phase would analyze:', {\n        pages: Object.keys(contentData).length,\n        siteStructure: Object.keys(siteMapData).length,\n        performanceMetrics: Object.keys(performanceData).length\n    });\n    // For now, return the data unchanged\n    return {\n        siteMapData,\n        contentData,\n        performanceData,\n        auditReport: {\n            completeness: 'high',\n            suggestions: [\n                'Consider adding more detailed component analysis',\n                'Include accessibility audit results',\n                'Add mobile responsiveness analysis'\n            ],\n            timestamp: new Date().toISOString()\n        }\n    };\n}\n/**\n * Run Lighthouse CLI for a URL and return the results\n * @param url - The URL to analyze\n * @returns Lighthouse audit results\n */ async function runLighthouseAudit(url) {\n    try {\n        // Create a temporary directory for the output\n        const tempDir = path__WEBPACK_IMPORTED_MODULE_7__.join(process.cwd(), 'temp');\n        if (!fs__WEBPACK_IMPORTED_MODULE_6__.existsSync(tempDir)) {\n            fs__WEBPACK_IMPORTED_MODULE_6__.mkdirSync(tempDir);\n        }\n        const outputPath = path__WEBPACK_IMPORTED_MODULE_7__.join(tempDir, `lighthouse-${Date.now()}.json`);\n        // Run Lighthouse CLI\n        const { stderr } = await execAsync(`npx lighthouse ${url} --output=json --output-path=${outputPath} --chrome-flags=\"--headless --no-sandbox --disable-gpu\"`);\n        if (stderr) {\n            console.warn('Lighthouse stderr:', stderr);\n        }\n        // Read the output file\n        const data = fs__WEBPACK_IMPORTED_MODULE_6__.readFileSync(outputPath, 'utf8');\n        // Clean up\n        fs__WEBPACK_IMPORTED_MODULE_6__.unlinkSync(outputPath);\n        return JSON.parse(data);\n    } catch (error) {\n        console.error('Error running Lighthouse audit:', error);\n        throw error;\n    }\n}\n/**\n * Perform deep scraping of a website using firecrawl\n * @param url - The URL to scrape\n * @param options - Optional scraping configuration\n * @returns Comprehensive scraping results\n */ async function deepScrapeWebsite(url, options = {}) {\n    const startTime = Date.now();\n    let analysis = null;\n    try {\n        console.log('Starting deepScrapeWebsite for:', url);\n        console.log('Environment check - FIRECRAWL_API_KEY exists:', !!process.env.FIRECRAWL_API_KEY);\n        // Create a database record for the analysis\n        analysis = await (0,_prisma_utils__WEBPACK_IMPORTED_MODULE_2__.createWebsiteAnalysisRequest)(url, options);\n        console.log('Created analysis record:', analysis.id);\n        // Update status to MAPPING\n        await (0,_prisma_utils__WEBPACK_IMPORTED_MODULE_2__.updateWebsiteAnalysisStatus)(analysis.id, 'MAPPING');\n        // Step 1: Map the website to discover all URLs (try MCP first)\n        console.log(`Mapping website: ${url}`);\n        let siteMapResult;\n        // Try MCP mapping first if available\n        const mcpAvailable = await (0,_firecrawl_mcp_client__WEBPACK_IMPORTED_MODULE_1__.checkMCPAvailability)();\n        if (mcpAvailable) {\n            try {\n                console.log('🗺️ Using MCP website mapping for enhanced discovery');\n                siteMapResult = await (0,_firecrawl_mcp_client__WEBPACK_IMPORTED_MODULE_1__.mapWebsiteWithMCP)(url, {\n                    maxDepth: 2,\n                    limit: options.maxPages || 100,\n                    allowExternalLinks: false\n                });\n                console.log(`✅ MCP mapping found ${siteMapResult.length} URLs`);\n            } catch (mcpError) {\n                console.error('❌ MCP mapping failed, falling back to standard mapping:', mcpError);\n                siteMapResult = await (0,_mcp_utils__WEBPACK_IMPORTED_MODULE_0__.mapWebsite)(url, {\n                    includeSubdomains: false,\n                    limit: options.maxPages || 100\n                });\n            }\n        } else {\n            console.log('🔄 Using standard website mapping (MCP not available)');\n            siteMapResult = await (0,_mcp_utils__WEBPACK_IMPORTED_MODULE_0__.mapWebsite)(url, {\n                includeSubdomains: false,\n                limit: options.maxPages || 100\n            });\n        }\n        console.log('Site map result:', Array.isArray(siteMapResult) ? `Array with ${siteMapResult.length} URLs` : 'Not an array');\n        // Process the site map data\n        const siteMapData = processSiteMap(siteMapResult);\n        console.log('Processed site map data - pages:', siteMapData.pages?.length || 0);\n        // Update status to SCRAPING\n        await (0,_prisma_utils__WEBPACK_IMPORTED_MODULE_2__.updateWebsiteAnalysisStatus)(analysis.id, 'SCRAPING', {\n            siteMap: siteMapData\n        });\n        // Step 2: Scrape pages using MCP batch processing for efficiency\n        console.log(`Scraping ${siteMapData.pages.length} pages with MCP batch processing...`);\n        const contentResults = {};\n        // If fullSite is true, scrape all pages; otherwise, just scrape the main URL\n        const pagesToScrape = options.fullSite ? siteMapData.pages : [\n            url\n        ];\n        console.log(`DEBUG: fullSite=${options.fullSite}, mapped pages=${siteMapData.pages.length}, pages to scrape=${pagesToScrape.length}`);\n        // Check if MCP is available and use it for batch processing\n        const mcpAvailableForBatch = await (0,_firecrawl_mcp_client__WEBPACK_IMPORTED_MODULE_1__.checkMCPAvailability)();\n        if (mcpAvailableForBatch && pagesToScrape.length > 1) {\n            console.log('🚀 Using MCP batch scraping for efficient processing');\n            try {\n                const formats = [\n                    'markdown',\n                    'html',\n                    'rawHtml',\n                    'links'\n                ];\n                if (options.includeScreenshots) {\n                    formats.push('screenshot@fullPage');\n                }\n                const batchResult = await (0,_firecrawl_mcp_client__WEBPACK_IMPORTED_MODULE_1__.batchScrapeWithMCP)(pagesToScrape, {\n                    formats,\n                    onlyMainContent: false,\n                    waitFor: 5000\n                });\n                // Process batch results - handle MCP response format\n                console.log('🔍 MCP batch result structure:', JSON.stringify(batchResult, null, 2));\n                if (batchResult.content && Array.isArray(batchResult.content)) {\n                    // Handle MCP response format where content is an array of text items\n                    const textContent = batchResult.content.find((item)=>item.type === 'text');\n                    if (textContent && textContent.text) {\n                        try {\n                            // Try to parse the text content as JSON (batch results)\n                            const batchData = JSON.parse(textContent.text);\n                            if (Array.isArray(batchData) && batchData.length === pagesToScrape.length) {\n                                for(let i = 0; i < pagesToScrape.length; i++){\n                                    const pageUrl = pagesToScrape[i];\n                                    const pageData = batchData[i];\n                                    if (pageData) {\n                                        const processedData = await processContentData(pageData);\n                                        contentResults[pageUrl] = processedData;\n                                        console.log(`✅ MCP batch processed: ${pageUrl}`, {\n                                            hasScreenshot: !!processedData?.screenshot,\n                                            screenshotType: typeof processedData?.screenshot\n                                        });\n                                    }\n                                }\n                            } else {\n                                console.log('⚠️ MCP batch data format unexpected, falling back to individual scraping');\n                                mcpAvailableForBatch = false;\n                            }\n                        } catch (parseError) {\n                            console.log('⚠️ Failed to parse MCP batch response, falling back to individual scraping:', parseError);\n                            mcpAvailableForBatch = false;\n                        }\n                    } else {\n                        console.log('⚠️ MCP batch response missing text content, falling back to individual scraping');\n                        mcpAvailableForBatch = false;\n                    }\n                } else {\n                    console.log('⚠️ MCP batch response format unexpected, falling back to individual scraping');\n                    mcpAvailableForBatch = false;\n                }\n                console.log(`✅ MCP batch scraping completed for ${Object.keys(contentResults).length} pages`);\n            } catch (mcpError) {\n                console.error('❌ MCP batch scraping failed, falling back to individual scraping:', mcpError);\n                // Fall back to individual scraping\n                mcpAvailableForBatch = false;\n            }\n        }\n        // Fallback: Individual page scraping (either MCP not available or batch failed)\n        if (!mcpAvailableForBatch || Object.keys(contentResults).length === 0) {\n            console.log('🔄 Using individual page scraping (MCP fallback)');\n            for (const pageUrl of pagesToScrape){\n                console.log(`Scraping page individually: ${pageUrl}`);\n                const formats = [\n                    'markdown',\n                    'html',\n                    'rawHtml',\n                    'links'\n                ];\n                if (options.includeScreenshots) {\n                    formats.push('screenshot@fullPage');\n                }\n                const pageResult = await (0,_mcp_utils__WEBPACK_IMPORTED_MODULE_0__.scrapeWebpage)(pageUrl, {\n                    formats,\n                    onlyMainContent: false,\n                    waitFor: 5000\n                });\n                const processedData = await processContentData(pageResult);\n                contentResults[pageUrl] = processedData;\n                console.log(`Screenshot data for ${pageUrl}:`, {\n                    hasScreenshot: !!processedData?.screenshot,\n                    screenshotType: typeof processedData?.screenshot,\n                    screenshotLength: processedData?.screenshot?.length || 0\n                });\n            }\n        }\n        // Update status to PROCESSING\n        await (0,_prisma_utils__WEBPACK_IMPORTED_MODULE_2__.updateWebsiteAnalysisStatus)(analysis.id, 'PROCESSING', {\n            siteMap: siteMapData,\n            content: contentResults\n        });\n        // Step 3: Run Lighthouse for performance metrics (if enabled)\n        let performanceData = null;\n        if (options.includeLighthouse) {\n            console.log(`Running Lighthouse audit for: ${url}`);\n            try {\n                const lighthouseResult = await runLighthouseAudit(url);\n                performanceData = processPerformanceData(lighthouseResult);\n            } catch (error) {\n                console.error('Error running Lighthouse audit:', error);\n                performanceData = processPerformanceData(null);\n            }\n        }\n        // Step 4: Extract structured data about the website\n        console.log(`Extracting structured data for: ${url}`);\n        const structuredData = await (0,_mcp_utils__WEBPACK_IMPORTED_MODULE_0__.extractStructuredData)([\n            url\n        ], {\n            prompt: 'Extract detailed information about this website including technologies used, design patterns, and key features',\n            schema: {\n                type: 'object',\n                properties: {\n                    technologies: {\n                        type: 'array',\n                        items: {\n                            type: 'string'\n                        },\n                        description: 'List of technologies used in the website'\n                    },\n                    designPatterns: {\n                        type: 'array',\n                        items: {\n                            type: 'string'\n                        },\n                        description: 'List of design patterns used in the website'\n                    },\n                    keyFeatures: {\n                        type: 'array',\n                        items: {\n                            type: 'string'\n                        },\n                        description: 'List of key features of the website'\n                    },\n                    colorPalette: {\n                        type: 'array',\n                        items: {\n                            type: 'string'\n                        },\n                        description: 'List of main colors used in the website'\n                    },\n                    fontFamilies: {\n                        type: 'array',\n                        items: {\n                            type: 'string'\n                        },\n                        description: 'List of font families used in the website'\n                    }\n                }\n            }\n        });\n        // Step 5: Optional AI audit phase for quality check\n        // Note: This could be enabled as a feature flag in the future\n        // const auditedData = await performAIAudit(siteMapData, contentResults, performanceData);\n        // Step 6: Generate the comprehensive website rebuild package\n        const rebuildPackage = await (0,_generate_docs__WEBPACK_IMPORTED_MODULE_3__.generateWebsiteRebuildPackage)(siteMapData, contentResults, performanceData || {}, structuredData, analysis.id);\n        // Save the package as a ZIP file\n        const tempDir = path__WEBPACK_IMPORTED_MODULE_7__.join(process.cwd(), 'temp');\n        if (!fs__WEBPACK_IMPORTED_MODULE_6__.existsSync(tempDir)) {\n            fs__WEBPACK_IMPORTED_MODULE_6__.mkdirSync(tempDir);\n        }\n        const zipBuffer = await rebuildPackage.zip.generateAsync({\n            type: 'nodebuffer'\n        });\n        const zipPath = path__WEBPACK_IMPORTED_MODULE_7__.join(tempDir, `${rebuildPackage.packageName}.zip`);\n        fs__WEBPACK_IMPORTED_MODULE_6__.writeFileSync(zipPath, zipBuffer);\n        // Also generate the legacy JSON format for backward compatibility\n        const legacyPrompt = (0,_generate_docs__WEBPACK_IMPORTED_MODULE_3__.generateSonnetPrompt)(siteMapData, contentResults, performanceData || {}, structuredData);\n        // Update status to COMPLETED with both formats\n        const finalResult = {\n            package: {\n                name: rebuildPackage.packageName,\n                zipPath,\n                manifest: rebuildPackage.manifest\n            },\n            legacy: legacyPrompt\n        };\n        await (0,_prisma_utils__WEBPACK_IMPORTED_MODULE_2__.updateWebsiteAnalysisStatus)(analysis.id, 'COMPLETED', finalResult);\n        return {\n            id: analysis.id,\n            package: rebuildPackage,\n            zipPath,\n            prompt: legacyPrompt\n        };\n    } catch (error) {\n        const processingTime = (Date.now() - startTime) / 1000;\n        const errorMessage = error instanceof Error ? error.message : String(error);\n        console.error('Error performing deep scraping:', error);\n        console.error('Error stack:', error instanceof Error ? error.stack : 'No stack trace');\n        console.error('Environment variables check:', {\n            hasFirecrawlKey: !!process.env.FIRECRAWL_API_KEY,\n            hasOpenAIKey: !!process.env.OPENAI_API_KEY,\n            hasDatabaseUrl: !!process.env.DATABASE_URL\n        });\n        // Mark analysis as failed in database if we have an analysis ID\n        if (analysis?.id) {\n            try {\n                await (0,_prisma_utils__WEBPACK_IMPORTED_MODULE_2__.markAnalysisAsFailed)(analysis.id, errorMessage, processingTime);\n                console.log(`Marked analysis ${analysis.id} as failed in database`);\n            } catch (dbError) {\n                console.error('Failed to update database with error status:', dbError);\n            }\n        }\n        // Provide structured error information\n        const structuredError = {\n            type: 'SCRAPING_ERROR',\n            message: errorMessage,\n            url,\n            processingTime,\n            analysisId: analysis?.id,\n            canResume: !!analysis?.id,\n            timestamp: new Date().toISOString(),\n            suggestions: [\n                'Check if the website is accessible',\n                'Verify Firecrawl API key is valid',\n                'Try resuming the failed analysis',\n                'Contact support if the issue persists'\n            ]\n        };\n        throw structuredError;\n    }\n}\n/**\n * Resume a failed website analysis from the last successful step\n * @param analysisId - The ID of the failed analysis to resume\n * @returns Comprehensive scraping results\n */ async function resumeFailedAnalysis(analysisId) {\n    const startTime = Date.now();\n    try {\n        console.log('Resuming failed analysis:', analysisId);\n        // Get the existing analysis record\n        const { getWebsiteAnalysisById } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./prisma-utils */ \"(rsc)/./lib/prisma-utils.ts\"));\n        const analysis = await getWebsiteAnalysisById(analysisId);\n        if (!analysis) {\n            throw new Error(`Analysis with ID ${analysisId} not found`);\n        }\n        if (analysis.status === 'COMPLETED') {\n            throw new Error(`Analysis ${analysisId} is already completed`);\n        }\n        console.log(`Resuming analysis for URL: ${analysis.url}, current status: ${analysis.status}`);\n        // Extract options from the original analysis\n        const options = analysis.result?.options || {};\n        // Determine where to resume based on current status and available data\n        const existingResult = analysis.result || {};\n        // Resume from the appropriate step\n        if (analysis.status === 'FAILED' || analysis.status === 'PENDING') {\n            // Start from the beginning\n            console.log('Restarting analysis from the beginning');\n            return await deepScrapeWebsite(analysis.url, options);\n        } else if (analysis.status === 'MAPPING') {\n            // Resume from mapping step\n            console.log('Resuming from mapping step');\n            await (0,_prisma_utils__WEBPACK_IMPORTED_MODULE_2__.updateWebsiteAnalysisStatus)(analysisId, 'MAPPING');\n            return await deepScrapeWebsite(analysis.url, options);\n        } else if (analysis.status === 'SCRAPING' && existingResult.siteMap) {\n            // Resume from scraping step with existing site map\n            console.log('Resuming from scraping step with existing site map');\n            // This would require more complex logic to resume mid-scraping\n            // For now, restart the scraping process\n            return await deepScrapeWebsite(analysis.url, options);\n        } else if (analysis.status === 'PROCESSING' && existingResult.content) {\n            // Resume from processing step with existing content\n            console.log('Resuming from processing step with existing content');\n            // This would require extracting the processing logic into a separate function\n            // For now, restart from the beginning\n            return await deepScrapeWebsite(analysis.url, options);\n        }\n        // Default: restart from the beginning\n        console.log('Defaulting to restart from the beginning');\n        return await deepScrapeWebsite(analysis.url, options);\n    } catch (error) {\n        const processingTime = (Date.now() - startTime) / 1000;\n        const errorMessage = error instanceof Error ? error.message : String(error);\n        console.error('Error resuming failed analysis:', error);\n        // Mark as failed again\n        try {\n            await (0,_prisma_utils__WEBPACK_IMPORTED_MODULE_2__.markAnalysisAsFailed)(analysisId, `Resume failed: ${errorMessage}`, processingTime);\n        } catch (dbError) {\n            console.error('Failed to update database with resume error:', dbError);\n        }\n        throw new Error(`Failed to resume analysis ${analysisId}: ${errorMessage}`);\n    }\n}\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q2QsTUFBTXdLLGlCQUFpQixDQUFDbEssS0FBSzZGLEdBQUcsS0FBS1EsU0FBUSxJQUFLO1FBQ2xELE1BQU04RCxlQUFlekssaUJBQWlCVSxRQUFRVixNQUFNVyxPQUFPLEdBQUdDLE9BQU9aO1FBRXJFQyxRQUFRRCxLQUFLLENBQUMsbUNBQW1DQTtRQUVqRCx1QkFBdUI7UUFDdkIsSUFBSTtZQUNGLE1BQU0zQixtRUFBb0JBLENBQUM2TSxZQUFZLENBQUMsZUFBZSxFQUFFVCxjQUFjLEVBQUVEO1FBQzNFLEVBQUUsT0FBT1EsU0FBUztZQUNoQi9LLFFBQVFELEtBQUssQ0FBQyxnREFBZ0RnTDtRQUNoRTtRQUVBLE1BQU0sSUFBSXRLLE1BQU0sQ0FBQywwQkFBMEIsRUFBRXdLLFdBQVcsRUFBRSxFQUFFVCxjQUFjO0lBQzVFO0FBQ0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9kZWFubmV3dG9uL0RvY3VtZW50cy94cmF5L2xpYi9kYXRhLXByb2Nlc3NpbmcudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBEYXRhIHByb2Nlc3NpbmcgdXRpbGl0aWVzIGZvciB0aGUgV2Vic2l0ZSBSZWJ1aWxkIFByb21wdCBHZW5lcmF0b3JcbiAqIEhhbmRsZXMgcGFyc2luZyBhbmQgc3RydWN0dXJpbmcgZGF0YSBmcm9tIEZpcmVjcmF3bCBhbmQgTGlnaHRob3VzZVxuICovXG5cbmltcG9ydCB7IG1hcFdlYnNpdGUsIHNjcmFwZVdlYnBhZ2UsIGV4dHJhY3RTdHJ1Y3R1cmVkRGF0YSB9IGZyb20gJy4vbWNwLXV0aWxzJztcbmltcG9ydCB7IGJhdGNoU2NyYXBlV2l0aE1DUCwgc2NyYXBlV2l0aE1DUCwgbWFwV2Vic2l0ZVdpdGhNQ1AsIGNoZWNrTUNQQXZhaWxhYmlsaXR5IH0gZnJvbSAnLi9maXJlY3Jhd2wtbWNwLWNsaWVudCc7XG5pbXBvcnQgeyBjcmVhdGVXZWJzaXRlQW5hbHlzaXNSZXF1ZXN0LCB1cGRhdGVXZWJzaXRlQW5hbHlzaXNTdGF0dXMsIG1hcmtBbmFseXNpc0FzRmFpbGVkIH0gZnJvbSAnLi9wcmlzbWEtdXRpbHMnO1xuaW1wb3J0IHsgZ2VuZXJhdGVTb25uZXRQcm9tcHQsIGdlbmVyYXRlV2Vic2l0ZVJlYnVpbGRQYWNrYWdlIH0gZnJvbSAnLi9nZW5lcmF0ZS1kb2NzJztcbmltcG9ydCB7IGV4ZWMgfSBmcm9tICdjaGlsZF9wcm9jZXNzJztcbmltcG9ydCB7IHByb21pc2lmeSB9IGZyb20gJ3V0aWwnO1xuaW1wb3J0ICogYXMgZnMgZnJvbSAnZnMnO1xuaW1wb3J0ICogYXMgcGF0aCBmcm9tICdwYXRoJztcblxuY29uc3QgZXhlY0FzeW5jID0gcHJvbWlzaWZ5KGV4ZWMpO1xuXG4vKipcbiAqIFByb2Nlc3MgcmF3IEZpcmVjcmF3bCBzaXRlIG1hcCBkYXRhIGludG8gYSBzdHJ1Y3R1cmVkIGZvcm1hdFxuICogQHBhcmFtIHJhd0RhdGEgLSBSYXcgZGF0YSBmcm9tIEZpcmVjcmF3bCBzaXRlIG1hcHBpbmdcbiAqIEByZXR1cm5zIFByb2Nlc3NlZCBzaXRlIHN0cnVjdHVyZSBkYXRhXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwcm9jZXNzU2l0ZU1hcChyYXdEYXRhOiB1bmtub3duKSB7XG4gIHRyeSB7XG4gICAgLy8gRXh0cmFjdCBVUkxzIGZyb20gdGhlIHJhdyBkYXRhXG4gICAgY29uc3QgdXJscyA9IEFycmF5LmlzQXJyYXkocmF3RGF0YSkgPyByYXdEYXRhIDogW107XG5cbiAgICAvLyBHcm91cCBVUkxzIGJ5IHBhdGggc2VnbWVudHMgdG8gY3JlYXRlIGEgaGllcmFyY2hpY2FsIHN0cnVjdHVyZVxuICAgIGNvbnN0IHN0cnVjdHVyZTogUmVjb3JkPHN0cmluZywgdW5rbm93bj4gPSB7fTtcblxuICAgIHVybHMuZm9yRWFjaCh1cmwgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgdXJsT2JqID0gbmV3IFVSTCh1cmwpO1xuICAgICAgICBjb25zdCBwYXRoU2VnbWVudHMgPSB1cmxPYmoucGF0aG5hbWUuc3BsaXQoJy8nKS5maWx0ZXIoQm9vbGVhbik7XG5cbiAgICAgICAgbGV0IGN1cnJlbnRMZXZlbCA9IHN0cnVjdHVyZTtcbiAgICAgICAgcGF0aFNlZ21lbnRzLmZvckVhY2goKHNlZ21lbnQsIGluZGV4KSA9PiB7XG4gICAgICAgICAgaWYgKCFjdXJyZW50TGV2ZWxbc2VnbWVudF0pIHtcbiAgICAgICAgICAgIGN1cnJlbnRMZXZlbFtzZWdtZW50XSA9IHt9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBjdXJyZW50TGV2ZWwgPSBjdXJyZW50TGV2ZWxbc2VnbWVudF0gYXMgUmVjb3JkPHN0cmluZywgdW5rbm93bj47XG5cbiAgICAgICAgICAvLyBBZGQgdGhlIGZ1bGwgVVJMIGFzIGEgbGVhZiBub2RlIGlmIHRoaXMgaXMgdGhlIGxhc3Qgc2VnbWVudFxuICAgICAgICAgIGlmIChpbmRleCA9PT0gcGF0aFNlZ21lbnRzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIChjdXJyZW50TGV2ZWwgYXMgUmVjb3JkPHN0cmluZywgdW5rbm93bj4pWydfX3VybCddID0gdXJsO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLndhcm4oYEVycm9yIHByb2Nlc3NpbmcgVVJMOiAke3VybH1gLCBlcnJvcik7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgcGFnZXM6IHVybHMsXG4gICAgICBzdHJ1Y3R1cmUsXG4gICAgICBtZXRhZGF0YToge1xuICAgICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgdmVyc2lvbjogJzEuMC4wJyxcbiAgICAgICAgdG90YWxQYWdlczogdXJscy5sZW5ndGhcbiAgICAgIH1cbiAgICB9O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHByb2Nlc3Npbmcgc2l0ZSBtYXAgZGF0YTonLCBlcnJvcik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBhZ2VzOiBbXSxcbiAgICAgIHN0cnVjdHVyZToge30sXG4gICAgICBtZXRhZGF0YToge1xuICAgICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgdmVyc2lvbjogJzEuMC4wJyxcbiAgICAgICAgZXJyb3I6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKVxuICAgICAgfVxuICAgIH07XG4gIH1cbn1cblxuLyoqXG4gKiBQcm9jZXNzIHJhdyBGaXJlY3Jhd2wgY29udGVudCBzY3JhcGluZyBkYXRhIGludG8gc3RydWN0dXJlZCBkb2N1bWVudGF0aW9uIGZvcm1hdFxuICogQHBhcmFtIHJhd0RhdGEgLSBSYXcgZGF0YSBmcm9tIEZpcmVjcmF3bCBjb250ZW50IHNjcmFwaW5nXG4gKiBAcmV0dXJucyBQcm9jZXNzZWQgY29udGVudCBkYXRhXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwcm9jZXNzQ29udGVudERhdGEocmF3RGF0YTogdW5rbm93bikge1xuICB0cnkge1xuICAgIGlmICghcmF3RGF0YSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBjb250ZW50IGRhdGEgcHJvdmlkZWQnKTtcbiAgICB9XG5cbiAgICBjb25zdCBkYXRhID0gcmF3RGF0YSBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPjtcblxuICAgIC8vIEV4dHJhY3QgSFRNTCBjb250ZW50XG4gICAgY29uc3QgaHRtbCA9IChkYXRhLmh0bWwgYXMgc3RyaW5nKSB8fCAoZGF0YS5yYXdIdG1sIGFzIHN0cmluZykgfHwgJyc7XG5cbiAgICAvLyBFeHRyYWN0IG1hcmtkb3duIGNvbnRlbnRcbiAgICBjb25zdCBtYXJrZG93biA9IChkYXRhLm1hcmtkb3duIGFzIHN0cmluZykgfHwgJyc7XG5cbiAgICAvLyBFeHRyYWN0IGxpbmtzXG4gICAgY29uc3QgbGlua3MgPSAoZGF0YS5saW5rcyBhcyBzdHJpbmdbXSkgfHwgW107XG5cbiAgICAvLyBFeHRyYWN0IGFzc2V0cyAoQ1NTLCBKUywgaW1hZ2VzLCBldGMuKVxuICAgIGNvbnN0IGFzc2V0czogUmVjb3JkPHN0cmluZywgdW5rbm93bj5bXSA9IFtdO1xuXG4gICAgLy8gVXNlIENTUyBjb250ZW50IGZyb20gRmlyZWNyYXdsIGlmIGF2YWlsYWJsZSwgb3RoZXJ3aXNlIGV4dHJhY3QgZnJvbSBIVE1MXG4gICAgbGV0IGNzc0NvbnRlbnRzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge307XG5cbiAgICAvLyBGaXJzdCwgdHJ5IHRvIHVzZSBjc3NDb250ZW50cyBmcm9tIEZpcmVjcmF3bFxuICAgIGlmIChkYXRhLmNzc0NvbnRlbnRzICYmIHR5cGVvZiBkYXRhLmNzc0NvbnRlbnRzID09PSAnb2JqZWN0Jykge1xuICAgICAgY3NzQ29udGVudHMgPSBkYXRhLmNzc0NvbnRlbnRzIGFzIFJlY29yZDxzdHJpbmcsIHN0cmluZz47XG4gICAgICBjb25zb2xlLmxvZyhg4pyFIFVzaW5nIENTUyBjb250ZW50IGZyb20gRmlyZWNyYXdsOiAke09iamVjdC5rZXlzKGNzc0NvbnRlbnRzKS5sZW5ndGh9IGZpbGVzYCk7XG5cbiAgICAgIC8vIEFkZCBDU1MgZmlsZXMgdG8gYXNzZXRzXG4gICAgICBPYmplY3QuZW50cmllcyhjc3NDb250ZW50cykuZm9yRWFjaCgoW2Nzc1VybCwgY3NzQ29udGVudF0pID0+IHtcbiAgICAgICAgYXNzZXRzLnB1c2goe1xuICAgICAgICAgIHVybDogY3NzVXJsLFxuICAgICAgICAgIHR5cGU6ICdjc3MnLFxuICAgICAgICAgIGNvbnRlbnQ6IGNzc0NvbnRlbnRcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRmFsbGJhY2s6IEV4dHJhY3QgQ1NTIGxpbmtzIGZyb20gSFRNTCBhbmQgZmV0Y2ggY29udGVudCBtYW51YWxseVxuICAgICAgY29uc29sZS5sb2coJ+KaoO+4jyBObyBjc3NDb250ZW50cyBmcm9tIEZpcmVjcmF3bCwgZmFsbGluZyBiYWNrIHRvIG1hbnVhbCBDU1MgZXh0cmFjdGlvbicpO1xuICAgICAgY29uc3QgY3NzTGlua3MgPSBleHRyYWN0UmVzb3VyY2VMaW5rcyhodG1sLCAnbGlua1tyZWw9XCJzdHlsZXNoZWV0XCJdJywgJ2hyZWYnKTtcblxuICAgICAgZm9yIChjb25zdCBjc3NVcmwgb2YgY3NzTGlua3MpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBTa2lwIGludmFsaWQgVVJMcyAobGlrZSBjaWQ6IFVSTHMgZnJvbSBNSFRNTCwgZGF0YTogVVJMcywgZXRjLilcbiAgICAgICAgICBpZiAoY3NzVXJsLnN0YXJ0c1dpdGgoJ2NpZDonKSB8fCBjc3NVcmwuc3RhcnRzV2l0aCgnZGF0YTonKSB8fCBjc3NVcmwuc3RhcnRzV2l0aCgnYmxvYjonKSB8fCBjc3NVcmwuc3RhcnRzV2l0aCgnamF2YXNjcmlwdDonKSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coYOKaoO+4jyBTa2lwcGluZyBpbnZhbGlkIENTUyBVUkw6ICR7Y3NzVXJsfWApO1xuICAgICAgICAgICAgYXNzZXRzLnB1c2goe1xuICAgICAgICAgICAgICB1cmw6IGNzc1VybCxcbiAgICAgICAgICAgICAgdHlwZTogJ2NzcycsXG4gICAgICAgICAgICAgIGVycm9yOiAnSW52YWxpZCBVUkwgZm9ybWF0J1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBSZXNvbHZlIHJlbGF0aXZlIFVSTHNcbiAgICAgICAgICBjb25zdCBhYnNvbHV0ZVVybCA9IGNzc1VybC5zdGFydHNXaXRoKCdodHRwJykgPyBjc3NVcmwgOiBuZXcgVVJMKGNzc1VybCwgZGF0YS51cmwgfHwgJycpLmhyZWY7XG5cbiAgICAgICAgICAvLyBGZXRjaCBDU1MgY29udGVudFxuICAgICAgICAgIGNvbnN0IGNzc0NvbnRlbnQgPSBhd2FpdCBmZXRjaENTU0NvbnRlbnQoYWJzb2x1dGVVcmwpO1xuICAgICAgICAgIGlmIChjc3NDb250ZW50KSB7XG4gICAgICAgICAgICBjc3NDb250ZW50c1tjc3NVcmxdID0gY3NzQ29udGVudDtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGDinIUgRXh0cmFjdGVkIENTUyBjb250ZW50IGZyb206ICR7Y3NzVXJsfSAoJHtjc3NDb250ZW50Lmxlbmd0aH0gY2hhcnMpYCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYXNzZXRzLnB1c2goe1xuICAgICAgICAgICAgdXJsOiBjc3NVcmwsXG4gICAgICAgICAgICB0eXBlOiAnY3NzJyxcbiAgICAgICAgICAgIGNvbnRlbnQ6IGNzc0NvbnRlbnQgfHwgdW5kZWZpbmVkXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihg4p2MIEZhaWxlZCB0byBmZXRjaCBDU1MgZnJvbSAke2Nzc1VybH06YCwgZXJyb3IpO1xuICAgICAgICAgIGFzc2V0cy5wdXNoKHtcbiAgICAgICAgICAgIHVybDogY3NzVXJsLFxuICAgICAgICAgICAgdHlwZTogJ2NzcycsXG4gICAgICAgICAgICBlcnJvcjogJ0ZhaWxlZCB0byBmZXRjaCBjb250ZW50J1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUHJvY2VzcyBKUyBsaW5rc1xuICAgIGNvbnN0IGpzTGlua3MgPSBleHRyYWN0UmVzb3VyY2VMaW5rcyhodG1sLCAnc2NyaXB0W3NyY10nLCAnc3JjJyk7XG4gICAganNMaW5rcy5mb3JFYWNoKHVybCA9PiB7XG4gICAgICBhc3NldHMucHVzaCh7XG4gICAgICAgIHVybCxcbiAgICAgICAgdHlwZTogJ2phdmFzY3JpcHQnIC8vIFVzZSBsb3dlcmNhc2UgZm9yIGNvbnNpc3RlbmN5XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8vIFByb2Nlc3MgaW1hZ2UgbGlua3NcbiAgICBjb25zdCBpbWFnZUxpbmtzID0gZXh0cmFjdFJlc291cmNlTGlua3MoaHRtbCwgJ2ltZ1tzcmNdJywgJ3NyYycpO1xuICAgIGltYWdlTGlua3MuZm9yRWFjaCh1cmwgPT4ge1xuICAgICAgYXNzZXRzLnB1c2goe1xuICAgICAgICB1cmwsXG4gICAgICAgIHR5cGU6ICdpbWFnZScgLy8gVXNlIGxvd2VyY2FzZSBmb3IgY29uc2lzdGVuY3lcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgLy8gRXh0cmFjdCBtZXRhZGF0YVxuICAgIGNvbnN0IG1ldGFkYXRhID0gZXh0cmFjdE1ldGFkYXRhKGh0bWwpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGh0bWwsXG4gICAgICBtYXJrZG93bixcbiAgICAgIGxpbmtzLFxuICAgICAgYXNzZXRzLFxuICAgICAgbWV0YWRhdGEsXG4gICAgICBjc3NDb250ZW50cywgLy8gSW5jbHVkZSBleHRyYWN0ZWQgQ1NTIGNvbnRlbnRzXG4gICAgICBzY3JlZW5zaG90OiAocmF3RGF0YSBhcyBhbnkpLnNjcmVlbnNob3QgfHwgKHJhd0RhdGEgYXMgYW55KS5kYXRhPy5zY3JlZW5zaG90IHx8IG51bGwsIC8vIFByZXNlcnZlIHNjcmVlbnNob3QgZGF0YSBmcm9tIGJvdGggRmlyZWNyYXdsIGFuZCBmYWxsYmFja1xuICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICB2ZXJzaW9uOiAnMS4wLjAnXG4gICAgfTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBwcm9jZXNzaW5nIGNvbnRlbnQgZGF0YTonLCBlcnJvcik7XG4gICAgcmV0dXJuIHtcbiAgICAgIGh0bWw6ICcnLFxuICAgICAgbWFya2Rvd246ICcnLFxuICAgICAgbGlua3M6IFtdLFxuICAgICAgYXNzZXRzOiBbXSxcbiAgICAgIG1ldGFkYXRhOiB7fSxcbiAgICAgIHNjcmVlbnNob3Q6IG51bGwsXG4gICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgIHZlcnNpb246ICcxLjAuMCcsXG4gICAgICBlcnJvcjogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpXG4gICAgfTtcbiAgfVxufVxuXG4vKipcbiAqIEZldGNoIENTUyBjb250ZW50IGZyb20gYSBVUkxcbiAqIEBwYXJhbSB1cmwgLSBDU1MgZmlsZSBVUkxcbiAqIEByZXR1cm5zIENTUyBjb250ZW50IGFzIHN0cmluZ1xuICovXG5hc3luYyBmdW5jdGlvbiBmZXRjaENTU0NvbnRlbnQodXJsOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZyB8IG51bGw+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgaGVhZGVyczoge1xuICAgICAgICAnVXNlci1BZ2VudCc6ICdNb3ppbGxhLzUuMCAoV2luZG93cyBOVCAxMC4wOyBXaW42NDsgeDY0KSBBcHBsZVdlYktpdC81MzcuMzYgKEtIVE1MLCBsaWtlIEdlY2tvKSBDaHJvbWUvOTEuMC40NDcyLjEyNCBTYWZhcmkvNTM3LjM2J1xuICAgICAgfSxcbiAgICAgIHRpbWVvdXQ6IDEwMDAwXG4gICAgfSk7XG5cbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEhUVFAgJHtyZXNwb25zZS5zdGF0dXN9OiAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCk7XG4gICAgfVxuXG4gICAgY29uc3QgY29udGVudFR5cGUgPSByZXNwb25zZS5oZWFkZXJzLmdldCgnY29udGVudC10eXBlJykgfHwgJyc7XG4gICAgaWYgKCFjb250ZW50VHlwZS5pbmNsdWRlcygndGV4dC9jc3MnKSAmJiAhY29udGVudFR5cGUuaW5jbHVkZXMoJ3RleHQvcGxhaW4nKSkge1xuICAgICAgY29uc29sZS53YXJuKGBXYXJuaW5nOiBDU1MgVVJMIHJldHVybmVkIHVuZXhwZWN0ZWQgY29udGVudC10eXBlOiAke2NvbnRlbnRUeXBlfWApO1xuICAgIH1cblxuICAgIHJldHVybiBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihgRmFpbGVkIHRvIGZldGNoIENTUyBmcm9tICR7dXJsfTpgLCBlcnJvcik7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBFeHRyYWN0IHJlc291cmNlIGxpbmtzIGZyb20gSFRNTCBjb250ZW50XG4gKiBAcGFyYW0gaHRtbCAtIEhUTUwgY29udGVudFxuICogQHBhcmFtIHNlbGVjdG9yIC0gQ1NTIHNlbGVjdG9yIGZvciB0aGUgZWxlbWVudHNcbiAqIEBwYXJhbSBhdHRyaWJ1dGUgLSBBdHRyaWJ1dGUgdG8gZXh0cmFjdFxuICogQHJldHVybnMgQXJyYXkgb2YgcmVzb3VyY2UgVVJMc1xuICovXG5mdW5jdGlvbiBleHRyYWN0UmVzb3VyY2VMaW5rcyhodG1sOiBzdHJpbmcsIHNlbGVjdG9yOiBzdHJpbmcsIGF0dHJpYnV0ZTogc3RyaW5nKTogc3RyaW5nW10ge1xuICBjb25zdCBsaW5rczogc3RyaW5nW10gPSBbXTtcblxuICAvLyBTaW1wbGUgcmVnZXgtYmFzZWQgZXh0cmFjdGlvbiAoaW4gYSByZWFsIGltcGxlbWVudGF0aW9uLCB1c2UgYSBwcm9wZXIgSFRNTCBwYXJzZXIpXG4gIGNvbnN0IHJlZ2V4ID0gbmV3IFJlZ0V4cChgPCR7c2VsZWN0b3Iuc3BsaXQoJ1snKVswXX1bXj5dKiR7YXR0cmlidXRlfT1bXCInXShbXlwiJ10rKVtcIiddW14+XSo+YCwgJ2dpJyk7XG4gIGxldCBtYXRjaDtcblxuICB3aGlsZSAoKG1hdGNoID0gcmVnZXguZXhlYyhodG1sKSkgIT09IG51bGwpIHtcbiAgICBpZiAobWF0Y2hbMV0pIHtcbiAgICAgIGxpbmtzLnB1c2gobWF0Y2hbMV0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBsaW5rcztcbn1cblxuLyoqXG4gKiBFeHRyYWN0IG1ldGFkYXRhIGZyb20gSFRNTCBjb250ZW50XG4gKiBAcGFyYW0gaHRtbCAtIEhUTUwgY29udGVudFxuICogQHJldHVybnMgTWV0YWRhdGEgb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RNZXRhZGF0YShodG1sOiBzdHJpbmcpOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+IHtcbiAgY29uc3QgbWV0YWRhdGE6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7fTtcblxuICAvLyBFeHRyYWN0IHRpdGxlXG4gIGNvbnN0IHRpdGxlTWF0Y2ggPSBodG1sLm1hdGNoKC88dGl0bGVbXj5dKj4oLio/KTxcXC90aXRsZT4vaSk7XG4gIGlmICh0aXRsZU1hdGNoICYmIHRpdGxlTWF0Y2hbMV0pIHtcbiAgICBtZXRhZGF0YS50aXRsZSA9IHRpdGxlTWF0Y2hbMV07XG4gIH1cblxuICAvLyBFeHRyYWN0IG1ldGEgdGFnc1xuICBjb25zdCBtZXRhUmVnZXggPSAvPG1ldGFbXj5dKm5hbWU9W1wiJ10oW15cIiddKylbXCInXVtePl0qY29udGVudD1bXCInXShbXlwiJ10rKVtcIiddW14+XSo+L2dpO1xuICBsZXQgbWV0YU1hdGNoO1xuXG4gIHdoaWxlICgobWV0YU1hdGNoID0gbWV0YVJlZ2V4LmV4ZWMoaHRtbCkpICE9PSBudWxsKSB7XG4gICAgaWYgKG1ldGFNYXRjaFsxXSAmJiBtZXRhTWF0Y2hbMl0pIHtcbiAgICAgIG1ldGFkYXRhW21ldGFNYXRjaFsxXV0gPSBtZXRhTWF0Y2hbMl07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG1ldGFkYXRhO1xufVxuXG4vKipcbiAqIFByb2Nlc3MgTGlnaHRob3VzZSBwZXJmb3JtYW5jZSBtZXRyaWNzIGludG8gYSBzdHJ1Y3R1cmVkIGZvcm1hdFxuICogQHBhcmFtIHJhd0RhdGEgLSBSYXcgTGlnaHRob3VzZSBhdWRpdCBkYXRhXG4gKiBAcmV0dXJucyBQcm9jZXNzZWQgcGVyZm9ybWFuY2UgbWV0cmljc1xuICovXG5leHBvcnQgZnVuY3Rpb24gcHJvY2Vzc1BlcmZvcm1hbmNlRGF0YShyYXdEYXRhOiB1bmtub3duKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgZGF0YSA9IHJhd0RhdGEgYXMgUmVjb3JkPHN0cmluZywgdW5rbm93bj47XG4gICAgaWYgKCFyYXdEYXRhIHx8ICFkYXRhLmNhdGVnb3JpZXMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBMaWdodGhvdXNlIGRhdGEgZm9ybWF0Jyk7XG4gICAgfVxuXG4gICAgY29uc3QgY2F0ZWdvcmllcyA9IGRhdGEuY2F0ZWdvcmllcyBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPjtcbiAgICBjb25zdCBhdWRpdHMgPSBkYXRhLmF1ZGl0cyBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPjtcblxuICAgIC8vIEV4dHJhY3Qgc2NvcmVzIGZyb20gY2F0ZWdvcmllc1xuICAgIGNvbnN0IHBlcmZvcm1hbmNlOiB7XG4gICAgICBzY29yZTogbnVtYmVyO1xuICAgICAgbWV0cmljczogUmVjb3JkPHN0cmluZywgdW5rbm93bj47XG4gICAgfSA9IHtcbiAgICAgIHNjb3JlOiAoY2F0ZWdvcmllcy5wZXJmb3JtYW5jZSBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik/LnNjb3JlIGFzIG51bWJlciB8fCAwLFxuICAgICAgbWV0cmljczoge31cbiAgICB9O1xuXG4gICAgY29uc3QgYWNjZXNzaWJpbGl0eToge1xuICAgICAgc2NvcmU6IG51bWJlcjtcbiAgICAgIG1ldHJpY3M6IFJlY29yZDxzdHJpbmcsIHVua25vd24+O1xuICAgIH0gPSB7XG4gICAgICBzY29yZTogKGNhdGVnb3JpZXMuYWNjZXNzaWJpbGl0eSBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik/LnNjb3JlIGFzIG51bWJlciB8fCAwLFxuICAgICAgbWV0cmljczoge31cbiAgICB9O1xuXG4gICAgY29uc3Qgc2VvOiB7XG4gICAgICBzY29yZTogbnVtYmVyO1xuICAgICAgbWV0cmljczogUmVjb3JkPHN0cmluZywgdW5rbm93bj47XG4gICAgfSA9IHtcbiAgICAgIHNjb3JlOiAoY2F0ZWdvcmllcy5zZW8gYXMgUmVjb3JkPHN0cmluZywgdW5rbm93bj4pPy5zY29yZSBhcyBudW1iZXIgfHwgMCxcbiAgICAgIG1ldHJpY3M6IHt9XG4gICAgfTtcblxuICAgIGNvbnN0IGJlc3RQcmFjdGljZXM6IHtcbiAgICAgIHNjb3JlOiBudW1iZXI7XG4gICAgICBtZXRyaWNzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPjtcbiAgICB9ID0ge1xuICAgICAgc2NvcmU6IChjYXRlZ29yaWVzWydiZXN0LXByYWN0aWNlcyddIGFzIFJlY29yZDxzdHJpbmcsIHVua25vd24+KT8uc2NvcmUgYXMgbnVtYmVyIHx8IDAsXG4gICAgICBtZXRyaWNzOiB7fVxuICAgIH07XG5cbiAgICAvLyBFeHRyYWN0IGtleSBtZXRyaWNzIGZyb20gYXVkaXRzXG4gICAgaWYgKGF1ZGl0cykge1xuICAgICAgLy8gUGVyZm9ybWFuY2UgbWV0cmljc1xuICAgICAgaWYgKGF1ZGl0c1snZmlyc3QtY29udGVudGZ1bC1wYWludCddKSB7XG4gICAgICAgIGNvbnN0IGF1ZGl0ID0gYXVkaXRzWydmaXJzdC1jb250ZW50ZnVsLXBhaW50J10gYXMgUmVjb3JkPHN0cmluZywgdW5rbm93bj47XG4gICAgICAgIHBlcmZvcm1hbmNlLm1ldHJpY3NbJ2ZpcnN0Q29udGVudGZ1bFBhaW50J10gPSB7XG4gICAgICAgICAgc2NvcmU6IGF1ZGl0LnNjb3JlLFxuICAgICAgICAgIHZhbHVlOiBhdWRpdC5udW1lcmljVmFsdWVcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgaWYgKGF1ZGl0c1snbGFyZ2VzdC1jb250ZW50ZnVsLXBhaW50J10pIHtcbiAgICAgICAgY29uc3QgYXVkaXQgPSBhdWRpdHNbJ2xhcmdlc3QtY29udGVudGZ1bC1wYWludCddIGFzIFJlY29yZDxzdHJpbmcsIHVua25vd24+O1xuICAgICAgICBwZXJmb3JtYW5jZS5tZXRyaWNzWydsYXJnZXN0Q29udGVudGZ1bFBhaW50J10gPSB7XG4gICAgICAgICAgc2NvcmU6IGF1ZGl0LnNjb3JlLFxuICAgICAgICAgIHZhbHVlOiBhdWRpdC5udW1lcmljVmFsdWVcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgaWYgKGF1ZGl0c1sndG90YWwtYmxvY2tpbmctdGltZSddKSB7XG4gICAgICAgIGNvbnN0IGF1ZGl0ID0gYXVkaXRzWyd0b3RhbC1ibG9ja2luZy10aW1lJ10gYXMgUmVjb3JkPHN0cmluZywgdW5rbm93bj47XG4gICAgICAgIHBlcmZvcm1hbmNlLm1ldHJpY3NbJ3RvdGFsQmxvY2tpbmdUaW1lJ10gPSB7XG4gICAgICAgICAgc2NvcmU6IGF1ZGl0LnNjb3JlLFxuICAgICAgICAgIHZhbHVlOiBhdWRpdC5udW1lcmljVmFsdWVcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgaWYgKGF1ZGl0c1snY3VtdWxhdGl2ZS1sYXlvdXQtc2hpZnQnXSkge1xuICAgICAgICBjb25zdCBhdWRpdCA9IGF1ZGl0c1snY3VtdWxhdGl2ZS1sYXlvdXQtc2hpZnQnXSBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPjtcbiAgICAgICAgcGVyZm9ybWFuY2UubWV0cmljc1snY3VtdWxhdGl2ZUxheW91dFNoaWZ0J10gPSB7XG4gICAgICAgICAgc2NvcmU6IGF1ZGl0LnNjb3JlLFxuICAgICAgICAgIHZhbHVlOiBhdWRpdC5udW1lcmljVmFsdWVcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgLy8gQWNjZXNzaWJpbGl0eSBtZXRyaWNzXG4gICAgICBpZiAoYXVkaXRzWydhcmlhLXJlcXVpcmVkLWF0dHInXSkge1xuICAgICAgICBjb25zdCBhdWRpdCA9IGF1ZGl0c1snYXJpYS1yZXF1aXJlZC1hdHRyJ10gYXMgUmVjb3JkPHN0cmluZywgdW5rbm93bj47XG4gICAgICAgIGFjY2Vzc2liaWxpdHkubWV0cmljc1snYXJpYVJlcXVpcmVkQXR0ciddID0ge1xuICAgICAgICAgIHNjb3JlOiBhdWRpdC5zY29yZSxcbiAgICAgICAgICBkZXRhaWxzOiBhdWRpdC5kZXRhaWxzXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIC8vIFNFTyBtZXRyaWNzXG4gICAgICBpZiAoYXVkaXRzWydtZXRhLWRlc2NyaXB0aW9uJ10pIHtcbiAgICAgICAgY29uc3QgYXVkaXQgPSBhdWRpdHNbJ21ldGEtZGVzY3JpcHRpb24nXSBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPjtcbiAgICAgICAgc2VvLm1ldHJpY3NbJ21ldGFEZXNjcmlwdGlvbiddID0ge1xuICAgICAgICAgIHNjb3JlOiBhdWRpdC5zY29yZSxcbiAgICAgICAgICBkZXRhaWxzOiBhdWRpdC5kZXRhaWxzXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIC8vIEJlc3QgcHJhY3RpY2VzIG1ldHJpY3NcbiAgICAgIGlmIChhdWRpdHNbJ2RvY3R5cGUnXSkge1xuICAgICAgICBjb25zdCBhdWRpdCA9IGF1ZGl0c1snZG9jdHlwZSddIGFzIFJlY29yZDxzdHJpbmcsIHVua25vd24+O1xuICAgICAgICBiZXN0UHJhY3RpY2VzLm1ldHJpY3NbJ2RvY3R5cGUnXSA9IHtcbiAgICAgICAgICBzY29yZTogYXVkaXQuc2NvcmUsXG4gICAgICAgICAgZGV0YWlsczogYXVkaXQuZGV0YWlsc1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBwZXJmb3JtYW5jZSxcbiAgICAgIGFjY2Vzc2liaWxpdHksXG4gICAgICBzZW8sXG4gICAgICBiZXN0UHJhY3RpY2VzLFxuICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgIHZlcnNpb246ICcxLjAuMCdcbiAgICAgIH1cbiAgICB9O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHByb2Nlc3NpbmcgcGVyZm9ybWFuY2UgZGF0YTonLCBlcnJvcik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBlcmZvcm1hbmNlOiB7XG4gICAgICAgIHNjb3JlOiAwLFxuICAgICAgICBtZXRyaWNzOiB7fVxuICAgICAgfSxcbiAgICAgIGFjY2Vzc2liaWxpdHk6IHtcbiAgICAgICAgc2NvcmU6IDAsXG4gICAgICAgIG1ldHJpY3M6IHt9XG4gICAgICB9LFxuICAgICAgc2VvOiB7XG4gICAgICAgIHNjb3JlOiAwLFxuICAgICAgICBtZXRyaWNzOiB7fVxuICAgICAgfSxcbiAgICAgIGJlc3RQcmFjdGljZXM6IHtcbiAgICAgICAgc2NvcmU6IDAsXG4gICAgICAgIG1ldHJpY3M6IHt9XG4gICAgICB9LFxuICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgIHZlcnNpb246ICcxLjAuMCcsXG4gICAgICAgIGVycm9yOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcilcbiAgICAgIH1cbiAgICB9O1xuICB9XG59XG5cbi8qKlxuICogQ29tYmluZSBhbGwgcHJvY2Vzc2VkIGRhdGEgaW50byB0aGUgZmluYWwgcHJvbXB0IHN0cnVjdHVyZVxuICogQHBhcmFtIHNpdGVNYXBEYXRhIC0gUHJvY2Vzc2VkIHNpdGUgbWFwIGRhdGFcbiAqIEBwYXJhbSBjb250ZW50RGF0YSAtIFByb2Nlc3NlZCBjb250ZW50IGRhdGFcbiAqIEBwYXJhbSBwZXJmb3JtYW5jZURhdGEgLSBQcm9jZXNzZWQgcGVyZm9ybWFuY2UgZGF0YVxuICogQHJldHVybnMgRmluYWwgc3RydWN0dXJlZCBwcm9tcHQgZGF0YVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVGaW5hbFByb21wdChcbiAgc2l0ZU1hcERhdGE6IFJlY29yZDxzdHJpbmcsIHVua25vd24+LFxuICBjb250ZW50RGF0YTogUmVjb3JkPHN0cmluZywgdW5rbm93bj4sXG4gIHBlcmZvcm1hbmNlRGF0YTogUmVjb3JkPHN0cmluZywgdW5rbm93bj5cbikge1xuICByZXR1cm4ge1xuICAgIHNpdGVTdHJ1Y3R1cmU6IHNpdGVNYXBEYXRhLFxuICAgIGNvbnRlbnQ6IGNvbnRlbnREYXRhLFxuICAgIHBlcmZvcm1hbmNlOiBwZXJmb3JtYW5jZURhdGEsXG4gICAgc3RydWN0dXJlZERhdGE6IHt9LCAvLyBJbml0aWFsaXplIGVtcHR5IG9iamVjdCB0byBiZSBmaWxsZWQgbGF0ZXJcbiAgICBtZXRhZGF0YToge1xuICAgICAgZ2VuZXJhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgIHZlcnNpb246ICcxLjAuMCcsXG4gICAgICBnZW5lcmF0ZWRGb3I6ICdDbGF1ZGUgU29ubmV0IEFJIElERSdcbiAgICB9LFxuICAgIGluc3RydWN0aW9uczoge1xuICAgICAgdGl0bGU6ICdXZWJzaXRlIFJlYnVpbGQgSW5zdHJ1Y3Rpb25zJyxcbiAgICAgIGRlc2NyaXB0aW9uOiAnVGhpcyBwcm9tcHQgY29udGFpbnMgY29tcHJlaGVuc2l2ZSBkYXRhIGZvciByZWJ1aWxkaW5nIHRoZSBhbmFseXplZCB3ZWJzaXRlIHdpdGggbWF4aW11bSBmaWRlbGl0eS4nLFxuICAgICAgc3RlcHM6IFtcbiAgICAgICAgJ0FuYWx5emUgdGhlIHNpdGUgc3RydWN0dXJlIHRvIHVuZGVyc3RhbmQgdGhlIG92ZXJhbGwgYXJjaGl0ZWN0dXJlJyxcbiAgICAgICAgJ1JldmlldyB0aGUgSFRNTCBjb250ZW50IGZvciBlYWNoIHBhZ2UgdG8gdW5kZXJzdGFuZCB0aGUgbWFya3VwIHN0cnVjdHVyZScsXG4gICAgICAgICdFeGFtaW5lIHRoZSBDU1MgYW5kIEphdmFTY3JpcHQgYXNzZXRzIHRvIHVuZGVyc3RhbmQgc3R5bGluZyBhbmQgZnVuY3Rpb25hbGl0eScsXG4gICAgICAgICdDb25zaWRlciB0aGUgcGVyZm9ybWFuY2UgbWV0cmljcyB0byBvcHRpbWl6ZSB0aGUgcmVidWlsZCcsXG4gICAgICAgICdJbXBsZW1lbnQgdGhlIHdlYnNpdGUgZm9sbG93aW5nIHRoZSBwcm92aWRlZCBzdHJ1Y3R1cmUgYW5kIGNvbnRlbnQnXG4gICAgICBdXG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIFBlcmZvcm0gQUkgYXVkaXQgb2Ygc2NyYXBlZCBkYXRhIGZvciBxdWFsaXR5IGFzc3VyYW5jZVxuICogQHBhcmFtIHNpdGVNYXBEYXRhIC0gU2l0ZSBtYXBwaW5nIGRhdGFcbiAqIEBwYXJhbSBjb250ZW50RGF0YSAtIENvbnRlbnQgc2NyYXBpbmcgZGF0YVxuICogQHBhcmFtIHBlcmZvcm1hbmNlRGF0YSAtIFBlcmZvcm1hbmNlIGFuYWx5c2lzIGRhdGFcbiAqIEByZXR1cm5zIEF1ZGl0ZWQgYW5kIGNsZWFuZWQgZGF0YVxuICovXG5hc3luYyBmdW5jdGlvbiBwZXJmb3JtQUlBdWRpdChcbiAgc2l0ZU1hcERhdGE6IFJlY29yZDxzdHJpbmcsIHVua25vd24+LFxuICBjb250ZW50RGF0YTogUmVjb3JkPHN0cmluZywgdW5rbm93bj4sXG4gIHBlcmZvcm1hbmNlRGF0YTogUmVjb3JkPHN0cmluZywgdW5rbm93bj5cbikge1xuICAvLyBUT0RPOiBJbXBsZW1lbnQgQUkgYXVkaXQgZnVuY3Rpb25hbGl0eVxuICAvLyBUaGlzIHdvdWxkIHVzZSBPcGVuQUkgQVBJIHRvOlxuICAvLyAxLiBSZXZpZXcgc2NyYXBlZCBjb250ZW50IGZvciBjb21wbGV0ZW5lc3NcbiAgLy8gMi4gSWRlbnRpZnkgbWlzc2luZyBjcml0aWNhbCBlbGVtZW50c1xuICAvLyAzLiBTdWdnZXN0IGltcHJvdmVtZW50cyB0byB0aGUgcmVidWlsZCBwYWNrYWdlXG4gIC8vIDQuIENsZWFuIHVwIGFueSBpbmNvbnNpc3RlbmNpZXMgaW4gdGhlIGRhdGFcbiAgLy8gNS4gRW5oYW5jZSB0aGUgQUkgcHJvbXB0IHdpdGggYmV0dGVyIGluc3RydWN0aW9uc1xuXG4gIGNvbnNvbGUubG9nKCdBSSBhdWRpdCBwaGFzZSB3b3VsZCBhbmFseXplOicsIHtcbiAgICBwYWdlczogT2JqZWN0LmtleXMoY29udGVudERhdGEpLmxlbmd0aCxcbiAgICBzaXRlU3RydWN0dXJlOiBPYmplY3Qua2V5cyhzaXRlTWFwRGF0YSkubGVuZ3RoLFxuICAgIHBlcmZvcm1hbmNlTWV0cmljczogT2JqZWN0LmtleXMocGVyZm9ybWFuY2VEYXRhKS5sZW5ndGhcbiAgfSk7XG5cbiAgLy8gRm9yIG5vdywgcmV0dXJuIHRoZSBkYXRhIHVuY2hhbmdlZFxuICByZXR1cm4ge1xuICAgIHNpdGVNYXBEYXRhLFxuICAgIGNvbnRlbnREYXRhLFxuICAgIHBlcmZvcm1hbmNlRGF0YSxcbiAgICBhdWRpdFJlcG9ydDoge1xuICAgICAgY29tcGxldGVuZXNzOiAnaGlnaCcsXG4gICAgICBzdWdnZXN0aW9uczogW1xuICAgICAgICAnQ29uc2lkZXIgYWRkaW5nIG1vcmUgZGV0YWlsZWQgY29tcG9uZW50IGFuYWx5c2lzJyxcbiAgICAgICAgJ0luY2x1ZGUgYWNjZXNzaWJpbGl0eSBhdWRpdCByZXN1bHRzJyxcbiAgICAgICAgJ0FkZCBtb2JpbGUgcmVzcG9uc2l2ZW5lc3MgYW5hbHlzaXMnXG4gICAgICBdLFxuICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogUnVuIExpZ2h0aG91c2UgQ0xJIGZvciBhIFVSTCBhbmQgcmV0dXJuIHRoZSByZXN1bHRzXG4gKiBAcGFyYW0gdXJsIC0gVGhlIFVSTCB0byBhbmFseXplXG4gKiBAcmV0dXJucyBMaWdodGhvdXNlIGF1ZGl0IHJlc3VsdHNcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJ1bkxpZ2h0aG91c2VBdWRpdCh1cmw6IHN0cmluZyk6IFByb21pc2U8UmVjb3JkPHN0cmluZywgdW5rbm93bj4+IHtcbiAgdHJ5IHtcbiAgICAvLyBDcmVhdGUgYSB0ZW1wb3JhcnkgZGlyZWN0b3J5IGZvciB0aGUgb3V0cHV0XG4gICAgY29uc3QgdGVtcERpciA9IHBhdGguam9pbihwcm9jZXNzLmN3ZCgpLCAndGVtcCcpO1xuICAgIGlmICghZnMuZXhpc3RzU3luYyh0ZW1wRGlyKSkge1xuICAgICAgZnMubWtkaXJTeW5jKHRlbXBEaXIpO1xuICAgIH1cblxuICAgIGNvbnN0IG91dHB1dFBhdGggPSBwYXRoLmpvaW4odGVtcERpciwgYGxpZ2h0aG91c2UtJHtEYXRlLm5vdygpfS5qc29uYCk7XG5cbiAgICAvLyBSdW4gTGlnaHRob3VzZSBDTElcbiAgICBjb25zdCB7IHN0ZGVyciB9ID0gYXdhaXQgZXhlY0FzeW5jKFxuICAgICAgYG5weCBsaWdodGhvdXNlICR7dXJsfSAtLW91dHB1dD1qc29uIC0tb3V0cHV0LXBhdGg9JHtvdXRwdXRQYXRofSAtLWNocm9tZS1mbGFncz1cIi0taGVhZGxlc3MgLS1uby1zYW5kYm94IC0tZGlzYWJsZS1ncHVcImBcbiAgICApO1xuXG4gICAgaWYgKHN0ZGVycikge1xuICAgICAgY29uc29sZS53YXJuKCdMaWdodGhvdXNlIHN0ZGVycjonLCBzdGRlcnIpO1xuICAgIH1cblxuICAgIC8vIFJlYWQgdGhlIG91dHB1dCBmaWxlXG4gICAgY29uc3QgZGF0YSA9IGZzLnJlYWRGaWxlU3luYyhvdXRwdXRQYXRoLCAndXRmOCcpO1xuXG4gICAgLy8gQ2xlYW4gdXBcbiAgICBmcy51bmxpbmtTeW5jKG91dHB1dFBhdGgpO1xuXG4gICAgcmV0dXJuIEpTT04ucGFyc2UoZGF0YSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgcnVubmluZyBMaWdodGhvdXNlIGF1ZGl0OicsIGVycm9yKTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufVxuXG4vKipcbiAqIFBlcmZvcm0gZGVlcCBzY3JhcGluZyBvZiBhIHdlYnNpdGUgdXNpbmcgZmlyZWNyYXdsXG4gKiBAcGFyYW0gdXJsIC0gVGhlIFVSTCB0byBzY3JhcGVcbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9uYWwgc2NyYXBpbmcgY29uZmlndXJhdGlvblxuICogQHJldHVybnMgQ29tcHJlaGVuc2l2ZSBzY3JhcGluZyByZXN1bHRzXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBkZWVwU2NyYXBlV2Vic2l0ZSh1cmw6IHN0cmluZywgb3B0aW9uczoge1xuICBmdWxsU2l0ZT86IGJvb2xlYW47XG4gIGluY2x1ZGVTY3JlZW5zaG90cz86IGJvb2xlYW47XG4gIGluY2x1ZGVMaWdodGhvdXNlPzogYm9vbGVhbjtcbiAgbWF4UGFnZXM/OiBudW1iZXI7XG59ID0ge30pIHtcbiAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgbGV0IGFuYWx5c2lzOiBhbnkgPSBudWxsO1xuXG4gIHRyeSB7XG4gICAgY29uc29sZS5sb2coJ1N0YXJ0aW5nIGRlZXBTY3JhcGVXZWJzaXRlIGZvcjonLCB1cmwpO1xuICAgIGNvbnNvbGUubG9nKCdFbnZpcm9ubWVudCBjaGVjayAtIEZJUkVDUkFXTF9BUElfS0VZIGV4aXN0czonLCAhIXByb2Nlc3MuZW52LkZJUkVDUkFXTF9BUElfS0VZKTtcblxuICAgIC8vIENyZWF0ZSBhIGRhdGFiYXNlIHJlY29yZCBmb3IgdGhlIGFuYWx5c2lzXG4gICAgYW5hbHlzaXMgPSBhd2FpdCBjcmVhdGVXZWJzaXRlQW5hbHlzaXNSZXF1ZXN0KHVybCwgb3B0aW9ucyk7XG4gICAgY29uc29sZS5sb2coJ0NyZWF0ZWQgYW5hbHlzaXMgcmVjb3JkOicsIGFuYWx5c2lzLmlkKTtcblxuICAgIC8vIFVwZGF0ZSBzdGF0dXMgdG8gTUFQUElOR1xuICAgIGF3YWl0IHVwZGF0ZVdlYnNpdGVBbmFseXNpc1N0YXR1cyhhbmFseXNpcy5pZCwgJ01BUFBJTkcnKTtcblxuICAgIC8vIFN0ZXAgMTogTWFwIHRoZSB3ZWJzaXRlIHRvIGRpc2NvdmVyIGFsbCBVUkxzICh0cnkgTUNQIGZpcnN0KVxuICAgIGNvbnNvbGUubG9nKGBNYXBwaW5nIHdlYnNpdGU6ICR7dXJsfWApO1xuICAgIGxldCBzaXRlTWFwUmVzdWx0O1xuXG4gICAgLy8gVHJ5IE1DUCBtYXBwaW5nIGZpcnN0IGlmIGF2YWlsYWJsZVxuICAgIGNvbnN0IG1jcEF2YWlsYWJsZSA9IGF3YWl0IGNoZWNrTUNQQXZhaWxhYmlsaXR5KCk7XG4gICAgaWYgKG1jcEF2YWlsYWJsZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc29sZS5sb2coJ/Cfl7rvuI8gVXNpbmcgTUNQIHdlYnNpdGUgbWFwcGluZyBmb3IgZW5oYW5jZWQgZGlzY292ZXJ5Jyk7XG4gICAgICAgIHNpdGVNYXBSZXN1bHQgPSBhd2FpdCBtYXBXZWJzaXRlV2l0aE1DUCh1cmwsIHtcbiAgICAgICAgICBtYXhEZXB0aDogMixcbiAgICAgICAgICBsaW1pdDogb3B0aW9ucy5tYXhQYWdlcyB8fCAxMDAsXG4gICAgICAgICAgYWxsb3dFeHRlcm5hbExpbmtzOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc29sZS5sb2coYOKchSBNQ1AgbWFwcGluZyBmb3VuZCAke3NpdGVNYXBSZXN1bHQubGVuZ3RofSBVUkxzYCk7XG4gICAgICB9IGNhdGNoIChtY3BFcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCfinYwgTUNQIG1hcHBpbmcgZmFpbGVkLCBmYWxsaW5nIGJhY2sgdG8gc3RhbmRhcmQgbWFwcGluZzonLCBtY3BFcnJvcik7XG4gICAgICAgIHNpdGVNYXBSZXN1bHQgPSBhd2FpdCBtYXBXZWJzaXRlKHVybCwge1xuICAgICAgICAgIGluY2x1ZGVTdWJkb21haW5zOiBmYWxzZSxcbiAgICAgICAgICBsaW1pdDogb3B0aW9ucy5tYXhQYWdlcyB8fCAxMDBcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUubG9nKCfwn5SEIFVzaW5nIHN0YW5kYXJkIHdlYnNpdGUgbWFwcGluZyAoTUNQIG5vdCBhdmFpbGFibGUpJyk7XG4gICAgICBzaXRlTWFwUmVzdWx0ID0gYXdhaXQgbWFwV2Vic2l0ZSh1cmwsIHtcbiAgICAgICAgaW5jbHVkZVN1YmRvbWFpbnM6IGZhbHNlLFxuICAgICAgICBsaW1pdDogb3B0aW9ucy5tYXhQYWdlcyB8fCAxMDBcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGNvbnNvbGUubG9nKCdTaXRlIG1hcCByZXN1bHQ6JywgQXJyYXkuaXNBcnJheShzaXRlTWFwUmVzdWx0KSA/IGBBcnJheSB3aXRoICR7c2l0ZU1hcFJlc3VsdC5sZW5ndGh9IFVSTHNgIDogJ05vdCBhbiBhcnJheScpO1xuXG4gICAgLy8gUHJvY2VzcyB0aGUgc2l0ZSBtYXAgZGF0YVxuICAgIGNvbnN0IHNpdGVNYXBEYXRhID0gcHJvY2Vzc1NpdGVNYXAoc2l0ZU1hcFJlc3VsdCk7XG4gICAgY29uc29sZS5sb2coJ1Byb2Nlc3NlZCBzaXRlIG1hcCBkYXRhIC0gcGFnZXM6Jywgc2l0ZU1hcERhdGEucGFnZXM/Lmxlbmd0aCB8fCAwKTtcblxuICAgIC8vIFVwZGF0ZSBzdGF0dXMgdG8gU0NSQVBJTkdcbiAgICBhd2FpdCB1cGRhdGVXZWJzaXRlQW5hbHlzaXNTdGF0dXMoYW5hbHlzaXMuaWQsICdTQ1JBUElORycsIHsgc2l0ZU1hcDogc2l0ZU1hcERhdGEgfSk7XG5cbiAgICAvLyBTdGVwIDI6IFNjcmFwZSBwYWdlcyB1c2luZyBNQ1AgYmF0Y2ggcHJvY2Vzc2luZyBmb3IgZWZmaWNpZW5jeVxuICAgIGNvbnNvbGUubG9nKGBTY3JhcGluZyAke3NpdGVNYXBEYXRhLnBhZ2VzLmxlbmd0aH0gcGFnZXMgd2l0aCBNQ1AgYmF0Y2ggcHJvY2Vzc2luZy4uLmApO1xuICAgIGNvbnN0IGNvbnRlbnRSZXN1bHRzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+ID0ge307XG5cbiAgICAvLyBJZiBmdWxsU2l0ZSBpcyB0cnVlLCBzY3JhcGUgYWxsIHBhZ2VzOyBvdGhlcndpc2UsIGp1c3Qgc2NyYXBlIHRoZSBtYWluIFVSTFxuICAgIGNvbnN0IHBhZ2VzVG9TY3JhcGUgPSBvcHRpb25zLmZ1bGxTaXRlID8gc2l0ZU1hcERhdGEucGFnZXMgOiBbdXJsXTtcblxuICAgIGNvbnNvbGUubG9nKGBERUJVRzogZnVsbFNpdGU9JHtvcHRpb25zLmZ1bGxTaXRlfSwgbWFwcGVkIHBhZ2VzPSR7c2l0ZU1hcERhdGEucGFnZXMubGVuZ3RofSwgcGFnZXMgdG8gc2NyYXBlPSR7cGFnZXNUb1NjcmFwZS5sZW5ndGh9YCk7XG5cbiAgICAvLyBDaGVjayBpZiBNQ1AgaXMgYXZhaWxhYmxlIGFuZCB1c2UgaXQgZm9yIGJhdGNoIHByb2Nlc3NpbmdcbiAgICBjb25zdCBtY3BBdmFpbGFibGVGb3JCYXRjaCA9IGF3YWl0IGNoZWNrTUNQQXZhaWxhYmlsaXR5KCk7XG5cbiAgICBpZiAobWNwQXZhaWxhYmxlRm9yQmF0Y2ggJiYgcGFnZXNUb1NjcmFwZS5sZW5ndGggPiAxKSB7XG4gICAgICBjb25zb2xlLmxvZygn8J+agCBVc2luZyBNQ1AgYmF0Y2ggc2NyYXBpbmcgZm9yIGVmZmljaWVudCBwcm9jZXNzaW5nJyk7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGZvcm1hdHMgPSBbJ21hcmtkb3duJywgJ2h0bWwnLCAncmF3SHRtbCcsICdsaW5rcyddO1xuICAgICAgICBpZiAob3B0aW9ucy5pbmNsdWRlU2NyZWVuc2hvdHMpIHtcbiAgICAgICAgICBmb3JtYXRzLnB1c2goJ3NjcmVlbnNob3RAZnVsbFBhZ2UnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGJhdGNoUmVzdWx0ID0gYXdhaXQgYmF0Y2hTY3JhcGVXaXRoTUNQKHBhZ2VzVG9TY3JhcGUsIHtcbiAgICAgICAgICBmb3JtYXRzLFxuICAgICAgICAgIG9ubHlNYWluQ29udGVudDogZmFsc2UsXG4gICAgICAgICAgd2FpdEZvcjogNTAwMFxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBQcm9jZXNzIGJhdGNoIHJlc3VsdHMgLSBoYW5kbGUgTUNQIHJlc3BvbnNlIGZvcm1hdFxuICAgICAgICBjb25zb2xlLmxvZygn8J+UjSBNQ1AgYmF0Y2ggcmVzdWx0IHN0cnVjdHVyZTonLCBKU09OLnN0cmluZ2lmeShiYXRjaFJlc3VsdCwgbnVsbCwgMikpO1xuXG4gICAgICAgIGlmIChiYXRjaFJlc3VsdC5jb250ZW50ICYmIEFycmF5LmlzQXJyYXkoYmF0Y2hSZXN1bHQuY29udGVudCkpIHtcbiAgICAgICAgICAvLyBIYW5kbGUgTUNQIHJlc3BvbnNlIGZvcm1hdCB3aGVyZSBjb250ZW50IGlzIGFuIGFycmF5IG9mIHRleHQgaXRlbXNcbiAgICAgICAgICBjb25zdCB0ZXh0Q29udGVudCA9IGJhdGNoUmVzdWx0LmNvbnRlbnQuZmluZCgoaXRlbTogYW55KSA9PiBpdGVtLnR5cGUgPT09ICd0ZXh0Jyk7XG5cbiAgICAgICAgICBpZiAodGV4dENvbnRlbnQgJiYgdGV4dENvbnRlbnQudGV4dCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgLy8gVHJ5IHRvIHBhcnNlIHRoZSB0ZXh0IGNvbnRlbnQgYXMgSlNPTiAoYmF0Y2ggcmVzdWx0cylcbiAgICAgICAgICAgICAgY29uc3QgYmF0Y2hEYXRhID0gSlNPTi5wYXJzZSh0ZXh0Q29udGVudC50ZXh0KTtcblxuICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShiYXRjaERhdGEpICYmIGJhdGNoRGF0YS5sZW5ndGggPT09IHBhZ2VzVG9TY3JhcGUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYWdlc1RvU2NyYXBlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBwYWdlVXJsID0gcGFnZXNUb1NjcmFwZVtpXTtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHBhZ2VEYXRhID0gYmF0Y2hEYXRhW2ldO1xuXG4gICAgICAgICAgICAgICAgICBpZiAocGFnZURhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJvY2Vzc2VkRGF0YSA9IGF3YWl0IHByb2Nlc3NDb250ZW50RGF0YShwYWdlRGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnRSZXN1bHRzW3BhZ2VVcmxdID0gcHJvY2Vzc2VkRGF0YTtcblxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhg4pyFIE1DUCBiYXRjaCBwcm9jZXNzZWQ6ICR7cGFnZVVybH1gLCB7XG4gICAgICAgICAgICAgICAgICAgICAgaGFzU2NyZWVuc2hvdDogISEocHJvY2Vzc2VkRGF0YSBhcyBhbnkpPy5zY3JlZW5zaG90LFxuICAgICAgICAgICAgICAgICAgICAgIHNjcmVlbnNob3RUeXBlOiB0eXBlb2YgKHByb2Nlc3NlZERhdGEgYXMgYW55KT8uc2NyZWVuc2hvdFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ+KaoO+4jyBNQ1AgYmF0Y2ggZGF0YSBmb3JtYXQgdW5leHBlY3RlZCwgZmFsbGluZyBiYWNrIHRvIGluZGl2aWR1YWwgc2NyYXBpbmcnKTtcbiAgICAgICAgICAgICAgICBtY3BBdmFpbGFibGVGb3JCYXRjaCA9IGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChwYXJzZUVycm9yKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKCfimqDvuI8gRmFpbGVkIHRvIHBhcnNlIE1DUCBiYXRjaCByZXNwb25zZSwgZmFsbGluZyBiYWNrIHRvIGluZGl2aWR1YWwgc2NyYXBpbmc6JywgcGFyc2VFcnJvcik7XG4gICAgICAgICAgICAgIG1jcEF2YWlsYWJsZUZvckJhdGNoID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCfimqDvuI8gTUNQIGJhdGNoIHJlc3BvbnNlIG1pc3NpbmcgdGV4dCBjb250ZW50LCBmYWxsaW5nIGJhY2sgdG8gaW5kaXZpZHVhbCBzY3JhcGluZycpO1xuICAgICAgICAgICAgbWNwQXZhaWxhYmxlRm9yQmF0Y2ggPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ+KaoO+4jyBNQ1AgYmF0Y2ggcmVzcG9uc2UgZm9ybWF0IHVuZXhwZWN0ZWQsIGZhbGxpbmcgYmFjayB0byBpbmRpdmlkdWFsIHNjcmFwaW5nJyk7XG4gICAgICAgICAgbWNwQXZhaWxhYmxlRm9yQmF0Y2ggPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnNvbGUubG9nKGDinIUgTUNQIGJhdGNoIHNjcmFwaW5nIGNvbXBsZXRlZCBmb3IgJHtPYmplY3Qua2V5cyhjb250ZW50UmVzdWx0cykubGVuZ3RofSBwYWdlc2ApO1xuXG4gICAgICB9IGNhdGNoIChtY3BFcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCfinYwgTUNQIGJhdGNoIHNjcmFwaW5nIGZhaWxlZCwgZmFsbGluZyBiYWNrIHRvIGluZGl2aWR1YWwgc2NyYXBpbmc6JywgbWNwRXJyb3IpO1xuICAgICAgICAvLyBGYWxsIGJhY2sgdG8gaW5kaXZpZHVhbCBzY3JhcGluZ1xuICAgICAgICBtY3BBdmFpbGFibGVGb3JCYXRjaCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEZhbGxiYWNrOiBJbmRpdmlkdWFsIHBhZ2Ugc2NyYXBpbmcgKGVpdGhlciBNQ1Agbm90IGF2YWlsYWJsZSBvciBiYXRjaCBmYWlsZWQpXG4gICAgaWYgKCFtY3BBdmFpbGFibGVGb3JCYXRjaCB8fCBPYmplY3Qua2V5cyhjb250ZW50UmVzdWx0cykubGVuZ3RoID09PSAwKSB7XG4gICAgICBjb25zb2xlLmxvZygn8J+UhCBVc2luZyBpbmRpdmlkdWFsIHBhZ2Ugc2NyYXBpbmcgKE1DUCBmYWxsYmFjayknKTtcblxuICAgICAgZm9yIChjb25zdCBwYWdlVXJsIG9mIHBhZ2VzVG9TY3JhcGUpIHtcbiAgICAgICAgY29uc29sZS5sb2coYFNjcmFwaW5nIHBhZ2UgaW5kaXZpZHVhbGx5OiAke3BhZ2VVcmx9YCk7XG5cbiAgICAgICAgY29uc3QgZm9ybWF0cyA9IFsnbWFya2Rvd24nLCAnaHRtbCcsICdyYXdIdG1sJywgJ2xpbmtzJ107XG4gICAgICAgIGlmIChvcHRpb25zLmluY2x1ZGVTY3JlZW5zaG90cykge1xuICAgICAgICAgIGZvcm1hdHMucHVzaCgnc2NyZWVuc2hvdEBmdWxsUGFnZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcGFnZVJlc3VsdCA9IGF3YWl0IHNjcmFwZVdlYnBhZ2UocGFnZVVybCwge1xuICAgICAgICAgIGZvcm1hdHMsXG4gICAgICAgICAgb25seU1haW5Db250ZW50OiBmYWxzZSxcbiAgICAgICAgICB3YWl0Rm9yOiA1MDAwXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IHByb2Nlc3NlZERhdGEgPSBhd2FpdCBwcm9jZXNzQ29udGVudERhdGEocGFnZVJlc3VsdCk7XG4gICAgICAgIGNvbnRlbnRSZXN1bHRzW3BhZ2VVcmxdID0gcHJvY2Vzc2VkRGF0YTtcblxuICAgICAgICBjb25zb2xlLmxvZyhgU2NyZWVuc2hvdCBkYXRhIGZvciAke3BhZ2VVcmx9OmAsIHtcbiAgICAgICAgICBoYXNTY3JlZW5zaG90OiAhIShwcm9jZXNzZWREYXRhIGFzIGFueSk/LnNjcmVlbnNob3QsXG4gICAgICAgICAgc2NyZWVuc2hvdFR5cGU6IHR5cGVvZiAocHJvY2Vzc2VkRGF0YSBhcyBhbnkpPy5zY3JlZW5zaG90LFxuICAgICAgICAgIHNjcmVlbnNob3RMZW5ndGg6IChwcm9jZXNzZWREYXRhIGFzIGFueSk/LnNjcmVlbnNob3Q/Lmxlbmd0aCB8fCAwXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFVwZGF0ZSBzdGF0dXMgdG8gUFJPQ0VTU0lOR1xuICAgIGF3YWl0IHVwZGF0ZVdlYnNpdGVBbmFseXNpc1N0YXR1cyhhbmFseXNpcy5pZCwgJ1BST0NFU1NJTkcnLCB7XG4gICAgICBzaXRlTWFwOiBzaXRlTWFwRGF0YSxcbiAgICAgIGNvbnRlbnQ6IGNvbnRlbnRSZXN1bHRzXG4gICAgfSk7XG5cbiAgICAvLyBTdGVwIDM6IFJ1biBMaWdodGhvdXNlIGZvciBwZXJmb3JtYW5jZSBtZXRyaWNzIChpZiBlbmFibGVkKVxuICAgIGxldCBwZXJmb3JtYW5jZURhdGEgPSBudWxsO1xuICAgIGlmIChvcHRpb25zLmluY2x1ZGVMaWdodGhvdXNlKSB7XG4gICAgICBjb25zb2xlLmxvZyhgUnVubmluZyBMaWdodGhvdXNlIGF1ZGl0IGZvcjogJHt1cmx9YCk7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBsaWdodGhvdXNlUmVzdWx0ID0gYXdhaXQgcnVuTGlnaHRob3VzZUF1ZGl0KHVybCk7XG4gICAgICAgIHBlcmZvcm1hbmNlRGF0YSA9IHByb2Nlc3NQZXJmb3JtYW5jZURhdGEobGlnaHRob3VzZVJlc3VsdCk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBydW5uaW5nIExpZ2h0aG91c2UgYXVkaXQ6JywgZXJyb3IpO1xuICAgICAgICBwZXJmb3JtYW5jZURhdGEgPSBwcm9jZXNzUGVyZm9ybWFuY2VEYXRhKG51bGwpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFN0ZXAgNDogRXh0cmFjdCBzdHJ1Y3R1cmVkIGRhdGEgYWJvdXQgdGhlIHdlYnNpdGVcbiAgICBjb25zb2xlLmxvZyhgRXh0cmFjdGluZyBzdHJ1Y3R1cmVkIGRhdGEgZm9yOiAke3VybH1gKTtcbiAgICBjb25zdCBzdHJ1Y3R1cmVkRGF0YSA9IGF3YWl0IGV4dHJhY3RTdHJ1Y3R1cmVkRGF0YShbdXJsXSwge1xuICAgICAgcHJvbXB0OiAnRXh0cmFjdCBkZXRhaWxlZCBpbmZvcm1hdGlvbiBhYm91dCB0aGlzIHdlYnNpdGUgaW5jbHVkaW5nIHRlY2hub2xvZ2llcyB1c2VkLCBkZXNpZ24gcGF0dGVybnMsIGFuZCBrZXkgZmVhdHVyZXMnLFxuICAgICAgc2NoZW1hOiB7XG4gICAgICAgIHR5cGU6ICdvYmplY3QnLFxuICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgdGVjaG5vbG9naWVzOiB7XG4gICAgICAgICAgICB0eXBlOiAnYXJyYXknLFxuICAgICAgICAgICAgaXRlbXM6IHsgdHlwZTogJ3N0cmluZycgfSxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiAnTGlzdCBvZiB0ZWNobm9sb2dpZXMgdXNlZCBpbiB0aGUgd2Vic2l0ZSdcbiAgICAgICAgICB9LFxuICAgICAgICAgIGRlc2lnblBhdHRlcm5zOiB7XG4gICAgICAgICAgICB0eXBlOiAnYXJyYXknLFxuICAgICAgICAgICAgaXRlbXM6IHsgdHlwZTogJ3N0cmluZycgfSxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiAnTGlzdCBvZiBkZXNpZ24gcGF0dGVybnMgdXNlZCBpbiB0aGUgd2Vic2l0ZSdcbiAgICAgICAgICB9LFxuICAgICAgICAgIGtleUZlYXR1cmVzOiB7XG4gICAgICAgICAgICB0eXBlOiAnYXJyYXknLFxuICAgICAgICAgICAgaXRlbXM6IHsgdHlwZTogJ3N0cmluZycgfSxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiAnTGlzdCBvZiBrZXkgZmVhdHVyZXMgb2YgdGhlIHdlYnNpdGUnXG4gICAgICAgICAgfSxcbiAgICAgICAgICBjb2xvclBhbGV0dGU6IHtcbiAgICAgICAgICAgIHR5cGU6ICdhcnJheScsXG4gICAgICAgICAgICBpdGVtczogeyB0eXBlOiAnc3RyaW5nJyB9LFxuICAgICAgICAgICAgZGVzY3JpcHRpb246ICdMaXN0IG9mIG1haW4gY29sb3JzIHVzZWQgaW4gdGhlIHdlYnNpdGUnXG4gICAgICAgICAgfSxcbiAgICAgICAgICBmb250RmFtaWxpZXM6IHtcbiAgICAgICAgICAgIHR5cGU6ICdhcnJheScsXG4gICAgICAgICAgICBpdGVtczogeyB0eXBlOiAnc3RyaW5nJyB9LFxuICAgICAgICAgICAgZGVzY3JpcHRpb246ICdMaXN0IG9mIGZvbnQgZmFtaWxpZXMgdXNlZCBpbiB0aGUgd2Vic2l0ZSdcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFN0ZXAgNTogT3B0aW9uYWwgQUkgYXVkaXQgcGhhc2UgZm9yIHF1YWxpdHkgY2hlY2tcbiAgICAvLyBOb3RlOiBUaGlzIGNvdWxkIGJlIGVuYWJsZWQgYXMgYSBmZWF0dXJlIGZsYWcgaW4gdGhlIGZ1dHVyZVxuICAgIC8vIGNvbnN0IGF1ZGl0ZWREYXRhID0gYXdhaXQgcGVyZm9ybUFJQXVkaXQoc2l0ZU1hcERhdGEsIGNvbnRlbnRSZXN1bHRzLCBwZXJmb3JtYW5jZURhdGEpO1xuXG4gICAgLy8gU3RlcCA2OiBHZW5lcmF0ZSB0aGUgY29tcHJlaGVuc2l2ZSB3ZWJzaXRlIHJlYnVpbGQgcGFja2FnZVxuICAgIGNvbnN0IHJlYnVpbGRQYWNrYWdlID0gYXdhaXQgZ2VuZXJhdGVXZWJzaXRlUmVidWlsZFBhY2thZ2UoXG4gICAgICBzaXRlTWFwRGF0YSxcbiAgICAgIGNvbnRlbnRSZXN1bHRzLFxuICAgICAgcGVyZm9ybWFuY2VEYXRhIHx8IHt9LFxuICAgICAgc3RydWN0dXJlZERhdGEgYXMgUmVjb3JkPHN0cmluZywgdW5rbm93bj4sXG4gICAgICBhbmFseXNpcy5pZFxuICAgICk7XG5cbiAgICAvLyBTYXZlIHRoZSBwYWNrYWdlIGFzIGEgWklQIGZpbGVcbiAgICBjb25zdCB0ZW1wRGlyID0gcGF0aC5qb2luKHByb2Nlc3MuY3dkKCksICd0ZW1wJyk7XG4gICAgaWYgKCFmcy5leGlzdHNTeW5jKHRlbXBEaXIpKSB7XG4gICAgICBmcy5ta2RpclN5bmModGVtcERpcik7XG4gICAgfVxuXG4gICAgY29uc3QgemlwQnVmZmVyID0gYXdhaXQgcmVidWlsZFBhY2thZ2UuemlwLmdlbmVyYXRlQXN5bmMoeyB0eXBlOiAnbm9kZWJ1ZmZlcicgfSk7XG4gICAgY29uc3QgemlwUGF0aCA9IHBhdGguam9pbih0ZW1wRGlyLCBgJHtyZWJ1aWxkUGFja2FnZS5wYWNrYWdlTmFtZX0uemlwYCk7XG4gICAgZnMud3JpdGVGaWxlU3luYyh6aXBQYXRoLCB6aXBCdWZmZXIpO1xuXG4gICAgLy8gQWxzbyBnZW5lcmF0ZSB0aGUgbGVnYWN5IEpTT04gZm9ybWF0IGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG4gICAgY29uc3QgbGVnYWN5UHJvbXB0ID0gZ2VuZXJhdGVTb25uZXRQcm9tcHQoXG4gICAgICBzaXRlTWFwRGF0YSxcbiAgICAgIGNvbnRlbnRSZXN1bHRzLFxuICAgICAgcGVyZm9ybWFuY2VEYXRhIHx8IHt9LFxuICAgICAgc3RydWN0dXJlZERhdGEgYXMgUmVjb3JkPHN0cmluZywgdW5rbm93bj5cbiAgICApO1xuXG4gICAgLy8gVXBkYXRlIHN0YXR1cyB0byBDT01QTEVURUQgd2l0aCBib3RoIGZvcm1hdHNcbiAgICBjb25zdCBmaW5hbFJlc3VsdCA9IHtcbiAgICAgIHBhY2thZ2U6IHtcbiAgICAgICAgbmFtZTogcmVidWlsZFBhY2thZ2UucGFja2FnZU5hbWUsXG4gICAgICAgIHppcFBhdGgsXG4gICAgICAgIG1hbmlmZXN0OiByZWJ1aWxkUGFja2FnZS5tYW5pZmVzdFxuICAgICAgfSxcbiAgICAgIGxlZ2FjeTogbGVnYWN5UHJvbXB0XG4gICAgfTtcblxuICAgIGF3YWl0IHVwZGF0ZVdlYnNpdGVBbmFseXNpc1N0YXR1cyhhbmFseXNpcy5pZCwgJ0NPTVBMRVRFRCcsIGZpbmFsUmVzdWx0KTtcblxuICAgIHJldHVybiB7XG4gICAgICBpZDogYW5hbHlzaXMuaWQsXG4gICAgICBwYWNrYWdlOiByZWJ1aWxkUGFja2FnZSxcbiAgICAgIHppcFBhdGgsXG4gICAgICBwcm9tcHQ6IGxlZ2FjeVByb21wdFxuICAgIH07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc3QgcHJvY2Vzc2luZ1RpbWUgPSAoRGF0ZS5ub3coKSAtIHN0YXJ0VGltZSkgLyAxMDAwO1xuICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKTtcblxuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHBlcmZvcm1pbmcgZGVlcCBzY3JhcGluZzonLCBlcnJvcik7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3Igc3RhY2s6JywgZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLnN0YWNrIDogJ05vIHN0YWNrIHRyYWNlJyk7XG4gICAgY29uc29sZS5lcnJvcignRW52aXJvbm1lbnQgdmFyaWFibGVzIGNoZWNrOicsIHtcbiAgICAgIGhhc0ZpcmVjcmF3bEtleTogISFwcm9jZXNzLmVudi5GSVJFQ1JBV0xfQVBJX0tFWSxcbiAgICAgIGhhc09wZW5BSUtleTogISFwcm9jZXNzLmVudi5PUEVOQUlfQVBJX0tFWSxcbiAgICAgIGhhc0RhdGFiYXNlVXJsOiAhIXByb2Nlc3MuZW52LkRBVEFCQVNFX1VSTFxuICAgIH0pO1xuXG4gICAgLy8gTWFyayBhbmFseXNpcyBhcyBmYWlsZWQgaW4gZGF0YWJhc2UgaWYgd2UgaGF2ZSBhbiBhbmFseXNpcyBJRFxuICAgIGlmIChhbmFseXNpcz8uaWQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IG1hcmtBbmFseXNpc0FzRmFpbGVkKGFuYWx5c2lzLmlkLCBlcnJvck1lc3NhZ2UsIHByb2Nlc3NpbmdUaW1lKTtcbiAgICAgICAgY29uc29sZS5sb2coYE1hcmtlZCBhbmFseXNpcyAke2FuYWx5c2lzLmlkfSBhcyBmYWlsZWQgaW4gZGF0YWJhc2VgKTtcbiAgICAgIH0gY2F0Y2ggKGRiRXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIHVwZGF0ZSBkYXRhYmFzZSB3aXRoIGVycm9yIHN0YXR1czonLCBkYkVycm9yKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBQcm92aWRlIHN0cnVjdHVyZWQgZXJyb3IgaW5mb3JtYXRpb25cbiAgICBjb25zdCBzdHJ1Y3R1cmVkRXJyb3IgPSB7XG4gICAgICB0eXBlOiAnU0NSQVBJTkdfRVJST1InLFxuICAgICAgbWVzc2FnZTogZXJyb3JNZXNzYWdlLFxuICAgICAgdXJsLFxuICAgICAgcHJvY2Vzc2luZ1RpbWUsXG4gICAgICBhbmFseXNpc0lkOiBhbmFseXNpcz8uaWQsXG4gICAgICBjYW5SZXN1bWU6ICEhYW5hbHlzaXM/LmlkLFxuICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICBzdWdnZXN0aW9uczogW1xuICAgICAgICAnQ2hlY2sgaWYgdGhlIHdlYnNpdGUgaXMgYWNjZXNzaWJsZScsXG4gICAgICAgICdWZXJpZnkgRmlyZWNyYXdsIEFQSSBrZXkgaXMgdmFsaWQnLFxuICAgICAgICAnVHJ5IHJlc3VtaW5nIHRoZSBmYWlsZWQgYW5hbHlzaXMnLFxuICAgICAgICAnQ29udGFjdCBzdXBwb3J0IGlmIHRoZSBpc3N1ZSBwZXJzaXN0cydcbiAgICAgIF1cbiAgICB9O1xuXG4gICAgdGhyb3cgc3RydWN0dXJlZEVycm9yO1xuICB9XG59XG5cbi8qKlxuICogUmVzdW1lIGEgZmFpbGVkIHdlYnNpdGUgYW5hbHlzaXMgZnJvbSB0aGUgbGFzdCBzdWNjZXNzZnVsIHN0ZXBcbiAqIEBwYXJhbSBhbmFseXNpc0lkIC0gVGhlIElEIG9mIHRoZSBmYWlsZWQgYW5hbHlzaXMgdG8gcmVzdW1lXG4gKiBAcmV0dXJucyBDb21wcmVoZW5zaXZlIHNjcmFwaW5nIHJlc3VsdHNcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJlc3VtZUZhaWxlZEFuYWx5c2lzKGFuYWx5c2lzSWQ6IHN0cmluZykge1xuICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuXG4gIHRyeSB7XG4gICAgY29uc29sZS5sb2coJ1Jlc3VtaW5nIGZhaWxlZCBhbmFseXNpczonLCBhbmFseXNpc0lkKTtcblxuICAgIC8vIEdldCB0aGUgZXhpc3RpbmcgYW5hbHlzaXMgcmVjb3JkXG4gICAgY29uc3QgeyBnZXRXZWJzaXRlQW5hbHlzaXNCeUlkIH0gPSBhd2FpdCBpbXBvcnQoJy4vcHJpc21hLXV0aWxzJyk7XG4gICAgY29uc3QgYW5hbHlzaXMgPSBhd2FpdCBnZXRXZWJzaXRlQW5hbHlzaXNCeUlkKGFuYWx5c2lzSWQpO1xuXG4gICAgaWYgKCFhbmFseXNpcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBBbmFseXNpcyB3aXRoIElEICR7YW5hbHlzaXNJZH0gbm90IGZvdW5kYCk7XG4gICAgfVxuXG4gICAgaWYgKGFuYWx5c2lzLnN0YXR1cyA9PT0gJ0NPTVBMRVRFRCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQW5hbHlzaXMgJHthbmFseXNpc0lkfSBpcyBhbHJlYWR5IGNvbXBsZXRlZGApO1xuICAgIH1cblxuICAgIGNvbnNvbGUubG9nKGBSZXN1bWluZyBhbmFseXNpcyBmb3IgVVJMOiAke2FuYWx5c2lzLnVybH0sIGN1cnJlbnQgc3RhdHVzOiAke2FuYWx5c2lzLnN0YXR1c31gKTtcblxuICAgIC8vIEV4dHJhY3Qgb3B0aW9ucyBmcm9tIHRoZSBvcmlnaW5hbCBhbmFseXNpc1xuICAgIGNvbnN0IG9wdGlvbnMgPSAoYW5hbHlzaXMucmVzdWx0IGFzIGFueSk/Lm9wdGlvbnMgfHwge307XG5cbiAgICAvLyBEZXRlcm1pbmUgd2hlcmUgdG8gcmVzdW1lIGJhc2VkIG9uIGN1cnJlbnQgc3RhdHVzIGFuZCBhdmFpbGFibGUgZGF0YVxuICAgIGNvbnN0IGV4aXN0aW5nUmVzdWx0ID0gYW5hbHlzaXMucmVzdWx0IGFzIGFueSB8fCB7fTtcblxuICAgIC8vIFJlc3VtZSBmcm9tIHRoZSBhcHByb3ByaWF0ZSBzdGVwXG4gICAgaWYgKGFuYWx5c2lzLnN0YXR1cyA9PT0gJ0ZBSUxFRCcgfHwgYW5hbHlzaXMuc3RhdHVzID09PSAnUEVORElORycpIHtcbiAgICAgIC8vIFN0YXJ0IGZyb20gdGhlIGJlZ2lubmluZ1xuICAgICAgY29uc29sZS5sb2coJ1Jlc3RhcnRpbmcgYW5hbHlzaXMgZnJvbSB0aGUgYmVnaW5uaW5nJyk7XG4gICAgICByZXR1cm4gYXdhaXQgZGVlcFNjcmFwZVdlYnNpdGUoYW5hbHlzaXMudXJsLCBvcHRpb25zKTtcbiAgICB9IGVsc2UgaWYgKGFuYWx5c2lzLnN0YXR1cyA9PT0gJ01BUFBJTkcnKSB7XG4gICAgICAvLyBSZXN1bWUgZnJvbSBtYXBwaW5nIHN0ZXBcbiAgICAgIGNvbnNvbGUubG9nKCdSZXN1bWluZyBmcm9tIG1hcHBpbmcgc3RlcCcpO1xuICAgICAgYXdhaXQgdXBkYXRlV2Vic2l0ZUFuYWx5c2lzU3RhdHVzKGFuYWx5c2lzSWQsICdNQVBQSU5HJyk7XG4gICAgICByZXR1cm4gYXdhaXQgZGVlcFNjcmFwZVdlYnNpdGUoYW5hbHlzaXMudXJsLCBvcHRpb25zKTtcbiAgICB9IGVsc2UgaWYgKGFuYWx5c2lzLnN0YXR1cyA9PT0gJ1NDUkFQSU5HJyAmJiBleGlzdGluZ1Jlc3VsdC5zaXRlTWFwKSB7XG4gICAgICAvLyBSZXN1bWUgZnJvbSBzY3JhcGluZyBzdGVwIHdpdGggZXhpc3Rpbmcgc2l0ZSBtYXBcbiAgICAgIGNvbnNvbGUubG9nKCdSZXN1bWluZyBmcm9tIHNjcmFwaW5nIHN0ZXAgd2l0aCBleGlzdGluZyBzaXRlIG1hcCcpO1xuICAgICAgLy8gVGhpcyB3b3VsZCByZXF1aXJlIG1vcmUgY29tcGxleCBsb2dpYyB0byByZXN1bWUgbWlkLXNjcmFwaW5nXG4gICAgICAvLyBGb3Igbm93LCByZXN0YXJ0IHRoZSBzY3JhcGluZyBwcm9jZXNzXG4gICAgICByZXR1cm4gYXdhaXQgZGVlcFNjcmFwZVdlYnNpdGUoYW5hbHlzaXMudXJsLCBvcHRpb25zKTtcbiAgICB9IGVsc2UgaWYgKGFuYWx5c2lzLnN0YXR1cyA9PT0gJ1BST0NFU1NJTkcnICYmIGV4aXN0aW5nUmVzdWx0LmNvbnRlbnQpIHtcbiAgICAgIC8vIFJlc3VtZSBmcm9tIHByb2Nlc3Npbmcgc3RlcCB3aXRoIGV4aXN0aW5nIGNvbnRlbnRcbiAgICAgIGNvbnNvbGUubG9nKCdSZXN1bWluZyBmcm9tIHByb2Nlc3Npbmcgc3RlcCB3aXRoIGV4aXN0aW5nIGNvbnRlbnQnKTtcbiAgICAgIC8vIFRoaXMgd291bGQgcmVxdWlyZSBleHRyYWN0aW5nIHRoZSBwcm9jZXNzaW5nIGxvZ2ljIGludG8gYSBzZXBhcmF0ZSBmdW5jdGlvblxuICAgICAgLy8gRm9yIG5vdywgcmVzdGFydCBmcm9tIHRoZSBiZWdpbm5pbmdcbiAgICAgIHJldHVybiBhd2FpdCBkZWVwU2NyYXBlV2Vic2l0ZShhbmFseXNpcy51cmwsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIC8vIERlZmF1bHQ6IHJlc3RhcnQgZnJvbSB0aGUgYmVnaW5uaW5nXG4gICAgY29uc29sZS5sb2coJ0RlZmF1bHRpbmcgdG8gcmVzdGFydCBmcm9tIHRoZSBiZWdpbm5pbmcnKTtcbiAgICByZXR1cm4gYXdhaXQgZGVlcFNjcmFwZVdlYnNpdGUoYW5hbHlzaXMudXJsLCBvcHRpb25zKTtcblxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnN0IHByb2Nlc3NpbmdUaW1lID0gKERhdGUubm93KCkgLSBzdGFydFRpbWUpIC8gMTAwMDtcbiAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcik7XG5cbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciByZXN1bWluZyBmYWlsZWQgYW5hbHlzaXM6JywgZXJyb3IpO1xuXG4gICAgLy8gTWFyayBhcyBmYWlsZWQgYWdhaW5cbiAgICB0cnkge1xuICAgICAgYXdhaXQgbWFya0FuYWx5c2lzQXNGYWlsZWQoYW5hbHlzaXNJZCwgYFJlc3VtZSBmYWlsZWQ6ICR7ZXJyb3JNZXNzYWdlfWAsIHByb2Nlc3NpbmdUaW1lKTtcbiAgICB9IGNhdGNoIChkYkVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gdXBkYXRlIGRhdGFiYXNlIHdpdGggcmVzdW1lIGVycm9yOicsIGRiRXJyb3IpO1xuICAgIH1cblxuICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHJlc3VtZSBhbmFseXNpcyAke2FuYWx5c2lzSWR9OiAke2Vycm9yTWVzc2FnZX1gKTtcbiAgfVxufSJdLCJuYW1lcyI6WyJtYXBXZWJzaXRlIiwic2NyYXBlV2VicGFnZSIsImV4dHJhY3RTdHJ1Y3R1cmVkRGF0YSIsImJhdGNoU2NyYXBlV2l0aE1DUCIsIm1hcFdlYnNpdGVXaXRoTUNQIiwiY2hlY2tNQ1BBdmFpbGFiaWxpdHkiLCJjcmVhdGVXZWJzaXRlQW5hbHlzaXNSZXF1ZXN0IiwidXBkYXRlV2Vic2l0ZUFuYWx5c2lzU3RhdHVzIiwibWFya0FuYWx5c2lzQXNGYWlsZWQiLCJnZW5lcmF0ZVNvbm5ldFByb21wdCIsImdlbmVyYXRlV2Vic2l0ZVJlYnVpbGRQYWNrYWdlIiwiZXhlYyIsInByb21pc2lmeSIsImZzIiwicGF0aCIsImV4ZWNBc3luYyIsInByb2Nlc3NTaXRlTWFwIiwicmF3RGF0YSIsInVybHMiLCJBcnJheSIsImlzQXJyYXkiLCJzdHJ1Y3R1cmUiLCJmb3JFYWNoIiwidXJsIiwidXJsT2JqIiwiVVJMIiwicGF0aFNlZ21lbnRzIiwicGF0aG5hbWUiLCJzcGxpdCIsImZpbHRlciIsIkJvb2xlYW4iLCJjdXJyZW50TGV2ZWwiLCJzZWdtZW50IiwiaW5kZXgiLCJsZW5ndGgiLCJlcnJvciIsImNvbnNvbGUiLCJ3YXJuIiwicGFnZXMiLCJtZXRhZGF0YSIsImNyZWF0ZWRBdCIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsInZlcnNpb24iLCJ0b3RhbFBhZ2VzIiwiRXJyb3IiLCJtZXNzYWdlIiwiU3RyaW5nIiwicHJvY2Vzc0NvbnRlbnREYXRhIiwiZGF0YSIsImh0bWwiLCJyYXdIdG1sIiwibWFya2Rvd24iLCJsaW5rcyIsImFzc2V0cyIsImNzc0NvbnRlbnRzIiwibG9nIiwiT2JqZWN0Iiwia2V5cyIsImVudHJpZXMiLCJjc3NVcmwiLCJjc3NDb250ZW50IiwicHVzaCIsInR5cGUiLCJjb250ZW50IiwiY3NzTGlua3MiLCJleHRyYWN0UmVzb3VyY2VMaW5rcyIsInN0YXJ0c1dpdGgiLCJhYnNvbHV0ZVVybCIsImhyZWYiLCJmZXRjaENTU0NvbnRlbnQiLCJ1bmRlZmluZWQiLCJqc0xpbmtzIiwiaW1hZ2VMaW5rcyIsImV4dHJhY3RNZXRhZGF0YSIsInNjcmVlbnNob3QiLCJyZXNwb25zZSIsImZldGNoIiwiaGVhZGVycyIsInRpbWVvdXQiLCJvayIsInN0YXR1cyIsInN0YXR1c1RleHQiLCJjb250ZW50VHlwZSIsImdldCIsImluY2x1ZGVzIiwidGV4dCIsInNlbGVjdG9yIiwiYXR0cmlidXRlIiwicmVnZXgiLCJSZWdFeHAiLCJtYXRjaCIsInRpdGxlTWF0Y2giLCJ0aXRsZSIsIm1ldGFSZWdleCIsIm1ldGFNYXRjaCIsInByb2Nlc3NQZXJmb3JtYW5jZURhdGEiLCJjYXRlZ29yaWVzIiwiYXVkaXRzIiwicGVyZm9ybWFuY2UiLCJzY29yZSIsIm1ldHJpY3MiLCJhY2Nlc3NpYmlsaXR5Iiwic2VvIiwiYmVzdFByYWN0aWNlcyIsImF1ZGl0IiwidmFsdWUiLCJudW1lcmljVmFsdWUiLCJkZXRhaWxzIiwiZ2VuZXJhdGVGaW5hbFByb21wdCIsInNpdGVNYXBEYXRhIiwiY29udGVudERhdGEiLCJwZXJmb3JtYW5jZURhdGEiLCJzaXRlU3RydWN0dXJlIiwic3RydWN0dXJlZERhdGEiLCJnZW5lcmF0ZWRBdCIsImdlbmVyYXRlZEZvciIsImluc3RydWN0aW9ucyIsImRlc2NyaXB0aW9uIiwic3RlcHMiLCJwZXJmb3JtQUlBdWRpdCIsInBlcmZvcm1hbmNlTWV0cmljcyIsImF1ZGl0UmVwb3J0IiwiY29tcGxldGVuZXNzIiwic3VnZ2VzdGlvbnMiLCJ0aW1lc3RhbXAiLCJydW5MaWdodGhvdXNlQXVkaXQiLCJ0ZW1wRGlyIiwiam9pbiIsInByb2Nlc3MiLCJjd2QiLCJleGlzdHNTeW5jIiwibWtkaXJTeW5jIiwib3V0cHV0UGF0aCIsIm5vdyIsInN0ZGVyciIsInJlYWRGaWxlU3luYyIsInVubGlua1N5bmMiLCJKU09OIiwicGFyc2UiLCJkZWVwU2NyYXBlV2Vic2l0ZSIsIm9wdGlvbnMiLCJzdGFydFRpbWUiLCJhbmFseXNpcyIsImVudiIsIkZJUkVDUkFXTF9BUElfS0VZIiwiaWQiLCJzaXRlTWFwUmVzdWx0IiwibWNwQXZhaWxhYmxlIiwibWF4RGVwdGgiLCJsaW1pdCIsIm1heFBhZ2VzIiwiYWxsb3dFeHRlcm5hbExpbmtzIiwibWNwRXJyb3IiLCJpbmNsdWRlU3ViZG9tYWlucyIsInNpdGVNYXAiLCJjb250ZW50UmVzdWx0cyIsInBhZ2VzVG9TY3JhcGUiLCJmdWxsU2l0ZSIsIm1jcEF2YWlsYWJsZUZvckJhdGNoIiwiZm9ybWF0cyIsImluY2x1ZGVTY3JlZW5zaG90cyIsImJhdGNoUmVzdWx0Iiwib25seU1haW5Db250ZW50Iiwid2FpdEZvciIsInN0cmluZ2lmeSIsInRleHRDb250ZW50IiwiZmluZCIsIml0ZW0iLCJiYXRjaERhdGEiLCJpIiwicGFnZVVybCIsInBhZ2VEYXRhIiwicHJvY2Vzc2VkRGF0YSIsImhhc1NjcmVlbnNob3QiLCJzY3JlZW5zaG90VHlwZSIsInBhcnNlRXJyb3IiLCJwYWdlUmVzdWx0Iiwic2NyZWVuc2hvdExlbmd0aCIsImluY2x1ZGVMaWdodGhvdXNlIiwibGlnaHRob3VzZVJlc3VsdCIsInByb21wdCIsInNjaGVtYSIsInByb3BlcnRpZXMiLCJ0ZWNobm9sb2dpZXMiLCJpdGVtcyIsImRlc2lnblBhdHRlcm5zIiwia2V5RmVhdHVyZXMiLCJjb2xvclBhbGV0dGUiLCJmb250RmFtaWxpZXMiLCJyZWJ1aWxkUGFja2FnZSIsInppcEJ1ZmZlciIsInppcCIsImdlbmVyYXRlQXN5bmMiLCJ6aXBQYXRoIiwicGFja2FnZU5hbWUiLCJ3cml0ZUZpbGVTeW5jIiwibGVnYWN5UHJvbXB0IiwiZmluYWxSZXN1bHQiLCJwYWNrYWdlIiwibmFtZSIsIm1hbmlmZXN0IiwibGVnYWN5IiwicHJvY2Vzc2luZ1RpbWUiLCJlcnJvck1lc3NhZ2UiLCJzdGFjayIsImhhc0ZpcmVjcmF3bEtleSIsImhhc09wZW5BSUtleSIsIk9QRU5BSV9BUElfS0VZIiwiaGFzRGF0YWJhc2VVcmwiLCJEQVRBQkFTRV9VUkwiLCJkYkVycm9yIiwic3RydWN0dXJlZEVycm9yIiwiYW5hbHlzaXNJZCIsImNhblJlc3VtZSIsInJlc3VtZUZhaWxlZEFuYWx5c2lzIiwiZ2V0V2Vic2l0ZUFuYWx5c2lzQnlJZCIsInJlc3VsdCIsImV4aXN0aW5nUmVzdWx0Il0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./lib/data-processing.ts\n");

/***/ }),

/***/ "(rsc)/./lib/firecrawl-mcp-client.ts":
/*!*************************************!*\
  !*** ./lib/firecrawl-mcp-client.ts ***!
  \*************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   batchScrapeWithMCP: () => (/* binding */ batchScrapeWithMCP),\n/* harmony export */   checkMCPAvailability: () => (/* binding */ checkMCPAvailability),\n/* harmony export */   closeMCPClient: () => (/* binding */ closeMCPClient),\n/* harmony export */   extractWithMCP: () => (/* binding */ extractWithMCP),\n/* harmony export */   mapWebsiteWithMCP: () => (/* binding */ mapWebsiteWithMCP),\n/* harmony export */   scrapeWithMCP: () => (/* binding */ scrapeWithMCP)\n/* harmony export */ });\n/* harmony import */ var _modelcontextprotocol_sdk_client_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @modelcontextprotocol/sdk/client/index.js */ \"@modelcontextprotocol/sdk/client/index.js\");\n/* harmony import */ var _modelcontextprotocol_sdk_client_stdio_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @modelcontextprotocol/sdk/client/stdio.js */ \"@modelcontextprotocol/sdk/client/stdio.js\");\n/* harmony import */ var child_process__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! child_process */ \"child_process\");\n/* harmony import */ var child_process__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(child_process__WEBPACK_IMPORTED_MODULE_2__);\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_modelcontextprotocol_sdk_client_index_js__WEBPACK_IMPORTED_MODULE_0__, _modelcontextprotocol_sdk_client_stdio_js__WEBPACK_IMPORTED_MODULE_1__]);\n([_modelcontextprotocol_sdk_client_index_js__WEBPACK_IMPORTED_MODULE_0__, _modelcontextprotocol_sdk_client_stdio_js__WEBPACK_IMPORTED_MODULE_1__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n/**\n * Firecrawl MCP Client Integration\n * Uses the official Firecrawl MCP server for enhanced web scraping\n * Provides batch processing, better error handling, and proper screenshot management\n */ \n\n\n// MCP Configuration\nconst MCP_CONFIG = {\n    retryMaxAttempts: 3,\n    retryInitialDelay: 2000,\n    retryBackoffFactor: 2,\n    timeout: 120000,\n    serverCommand: 'npx',\n    serverArgs: [\n        '-y',\n        'firecrawl-mcp'\n    ]\n};\n// Global MCP client instance\nlet mcpClient = null;\nlet mcpTransport = null;\n/**\n * Initialize MCP client connection\n */ async function initializeMCPClient() {\n    if (mcpClient) {\n        return mcpClient;\n    }\n    try {\n        const apiKey = process.env.FIRECRAWL_API_KEY;\n        if (!apiKey || apiKey === 'your_firecrawl_api_key_here') {\n            throw new Error('FIRECRAWL_API_KEY environment variable is required');\n        }\n        console.log('🔄 Initializing Firecrawl MCP client...');\n        // Set up environment variables for the MCP server\n        const env = {\n            ...process.env,\n            FIRECRAWL_API_KEY: apiKey,\n            FIRECRAWL_RETRY_MAX_ATTEMPTS: MCP_CONFIG.retryMaxAttempts.toString(),\n            FIRECRAWL_RETRY_INITIAL_DELAY: MCP_CONFIG.retryInitialDelay.toString(),\n            FIRECRAWL_RETRY_BACKOFF_FACTOR: MCP_CONFIG.retryBackoffFactor.toString()\n        };\n        // Spawn the MCP server process\n        const serverProcess = (0,child_process__WEBPACK_IMPORTED_MODULE_2__.spawn)(MCP_CONFIG.serverCommand, MCP_CONFIG.serverArgs, {\n            env,\n            stdio: [\n                'pipe',\n                'pipe',\n                'pipe'\n            ]\n        });\n        // Create transport and client\n        mcpTransport = new _modelcontextprotocol_sdk_client_stdio_js__WEBPACK_IMPORTED_MODULE_1__.StdioClientTransport({\n            reader: serverProcess.stdout,\n            writer: serverProcess.stdin\n        });\n        mcpClient = new _modelcontextprotocol_sdk_client_index_js__WEBPACK_IMPORTED_MODULE_0__.Client({\n            name: 'xrai-firecrawl-client',\n            version: '1.0.0'\n        }, {\n            capabilities: {}\n        });\n        // Connect to the server\n        await mcpClient.connect(mcpTransport);\n        console.log('✅ Firecrawl MCP client initialized successfully');\n        return mcpClient;\n    } catch (error) {\n        console.error('❌ Failed to initialize MCP client:', error);\n        mcpClient = null;\n        mcpTransport = null;\n        throw error;\n    }\n}\n/**\n * Execute MCP tool with proper error handling and retries\n */ async function executeMCPTool(toolName, arguments_) {\n    let lastError;\n    for(let attempt = 1; attempt <= MCP_CONFIG.retryMaxAttempts; attempt++){\n        try {\n            console.log(`🔄 Executing MCP tool: ${toolName} (attempt ${attempt}/${MCP_CONFIG.retryMaxAttempts})`);\n            const client = await initializeMCPClient();\n            const result = await client.callTool({\n                name: toolName,\n                arguments: arguments_\n            });\n            if (result.isError) {\n                throw new Error(`MCP tool error: ${result.content?.[0]?.text || 'Unknown error'}`);\n            }\n            console.log(`✅ MCP tool ${toolName} completed successfully`);\n            return result;\n        } catch (error) {\n            lastError = error;\n            console.error(`❌ MCP tool ${toolName} attempt ${attempt} failed:`, error instanceof Error ? error.message : String(error));\n            if (attempt === MCP_CONFIG.retryMaxAttempts) {\n                break;\n            }\n            // Calculate delay with exponential backoff\n            const delay = Math.min(MCP_CONFIG.retryInitialDelay * Math.pow(MCP_CONFIG.retryBackoffFactor, attempt - 1), 30000 // Max 30 seconds\n            );\n            console.log(`⏳ Waiting ${delay}ms before retry...`);\n            await new Promise((resolve)=>setTimeout(resolve, delay));\n            // Reset client on error to force reconnection\n            if (mcpClient) {\n                try {\n                    await mcpClient.close();\n                } catch (closeError) {\n                    console.warn('Warning: Failed to close MCP client:', closeError);\n                }\n                mcpClient = null;\n                mcpTransport = null;\n            }\n        }\n    }\n    throw new Error(`MCP tool ${toolName} failed after ${MCP_CONFIG.retryMaxAttempts} attempts. Last error: ${lastError.message}`);\n}\n/**\n * Batch scrape multiple URLs using Firecrawl MCP server\n * This is the primary method for efficient multi-page scraping\n */ async function batchScrapeWithMCP(urls, options) {\n    try {\n        console.log(`🚀 Starting MCP batch scrape for ${urls.length} URLs`);\n        // Prepare MCP batch scrape arguments\n        const mcpArgs = {\n            urls,\n            options: {\n                formats: options?.formats || [\n                    'markdown',\n                    'html',\n                    'screenshot@fullPage',\n                    'links'\n                ],\n                onlyMainContent: options?.onlyMainContent || false,\n                waitFor: options?.waitFor || 5000,\n                mobile: options?.mobile || false\n            }\n        };\n        const result = await executeMCPTool('firecrawl_batch_scrape', mcpArgs);\n        console.log(`✅ MCP batch scrape completed for ${urls.length} URLs`);\n        return result;\n    } catch (error) {\n        console.error('❌ MCP batch scrape failed:', error);\n        throw new Error(`MCP batch scrape failed: ${error instanceof Error ? error.message : String(error)}`);\n    }\n}\n/**\n * Single URL scrape using Firecrawl MCP server\n * Use this for individual page scraping with advanced options\n */ async function scrapeWithMCP(url, options) {\n    try {\n        console.log(`🔄 Starting MCP scrape for: ${url}`);\n        // Prepare MCP scrape arguments\n        const mcpArgs = {\n            url,\n            formats: options?.formats || [\n                'markdown',\n                'html',\n                'screenshot@fullPage',\n                'links'\n            ],\n            onlyMainContent: options?.onlyMainContent || false,\n            waitFor: options?.waitFor || 5000,\n            mobile: options?.mobile || false,\n            actions: options?.actions || []\n        };\n        const result = await executeMCPTool('firecrawl_scrape', mcpArgs);\n        console.log(`✅ MCP scrape completed for: ${url}`);\n        return result;\n    } catch (error) {\n        console.error(`❌ MCP scrape failed for ${url}:`, error);\n        throw new Error(`MCP scrape failed: ${error instanceof Error ? error.message : String(error)}`);\n    }\n}\n/**\n * Map website URLs using Firecrawl MCP server\n * Discovers all accessible URLs on a website\n */ async function mapWebsiteWithMCP(url, options) {\n    try {\n        console.log(`🗺️ Starting MCP website mapping for: ${url}`);\n        // Use the map tool for URL discovery\n        const mcpArgs = {\n            url\n        };\n        const result = await executeMCPTool('firecrawl_map', mcpArgs);\n        // Extract URLs from map result\n        if (result.content && Array.isArray(result.content)) {\n            // Look for text content that contains URLs\n            const textContent = result.content.find((item)=>item.type === 'text');\n            if (textContent && textContent.text) {\n                try {\n                    // Try to parse as JSON first (structured response)\n                    const parsedData = JSON.parse(textContent.text);\n                    if (Array.isArray(parsedData)) {\n                        const urls = parsedData.filter((url)=>url.startsWith('http'));\n                        console.log(`✅ MCP mapping found ${urls.length} URLs (JSON format)`);\n                        return urls;\n                    }\n                } catch (parseError) {\n                    // If not JSON, try to extract URLs from plain text\n                    const urlRegex = /https?:\\/\\/[^\\s]+/g;\n                    const urls = textContent.text.match(urlRegex) || [];\n                    if (urls.length > 0) {\n                        console.log(`✅ MCP mapping found ${urls.length} URLs (text format)`);\n                        return urls;\n                    }\n                }\n            }\n            // Fallback: try to extract from all text items\n            const urls = result.content.filter((item)=>item.type === 'text' && item.text).map((item)=>item.text).filter((text)=>text.startsWith('http'));\n            if (urls.length > 0) {\n                console.log(`✅ MCP mapping found ${urls.length} URLs (fallback format)`);\n                return urls;\n            }\n        }\n        console.log('⚠️ MCP mapping returned unexpected format, using fallback');\n        return [\n            url\n        ]; // Fallback to original URL\n    } catch (error) {\n        console.error('❌ MCP website mapping failed:', error);\n        throw new Error(`MCP mapping failed: ${error instanceof Error ? error.message : String(error)}`);\n    }\n}\n/**\n * Check if MCP server is available and properly configured\n */ async function checkMCPAvailability() {\n    try {\n        const apiKey = process.env.FIRECRAWL_API_KEY;\n        if (!apiKey || apiKey === 'your_firecrawl_api_key_here') {\n            console.log('❌ MCP not available: FIRECRAWL_API_KEY not configured');\n            return false;\n        }\n        console.log('🔍 Testing MCP server availability...');\n        // Try to initialize the MCP client\n        const client = await initializeMCPClient();\n        // List available tools to verify the server is working\n        const tools = await client.listTools();\n        if (tools && tools.tools && tools.tools.length > 0) {\n            const toolNames = tools.tools.map((tool)=>tool.name);\n            console.log(`✅ MCP server available with tools: ${toolNames.join(', ')}`);\n            return true;\n        } else {\n            console.log('⚠️ MCP server connected but no tools available');\n            return false;\n        }\n    } catch (error) {\n        console.log('❌ MCP server not available:', error instanceof Error ? error.message : String(error));\n        // Clean up failed connection\n        if (mcpClient) {\n            try {\n                await mcpClient.close();\n            } catch (closeError) {\n                console.warn('Warning: Failed to close MCP client during availability check:', closeError);\n            }\n            mcpClient = null;\n            mcpTransport = null;\n        }\n        return false;\n    }\n}\n/**\n * Extract structured data using MCP server\n */ async function extractWithMCP(urls, options) {\n    try {\n        console.log(`🔍 Starting MCP extraction for ${urls.length} URLs`);\n        const mcpArgs = {\n            urls,\n            prompt: options?.prompt || 'Extract all relevant information from this webpage',\n            schema: options?.schema\n        };\n        const result = await executeMCPTool('firecrawl_extract', mcpArgs);\n        console.log(`✅ MCP extraction completed for ${urls.length} URLs`);\n        return result;\n    } catch (error) {\n        console.error('❌ MCP extraction failed:', error);\n        throw new Error(`MCP extraction failed: ${error instanceof Error ? error.message : String(error)}`);\n    }\n}\n/**\n * Clean up MCP client connection\n */ async function closeMCPClient() {\n    if (mcpClient) {\n        try {\n            await mcpClient.close();\n            console.log('✅ MCP client connection closed');\n        } catch (error) {\n            console.warn('Warning: Failed to close MCP client:', error);\n        } finally{\n            mcpClient = null;\n            mcpTransport = null;\n        }\n    }\n}\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QVc7UUFDYixJQUFJO1lBQ0YsTUFBTUEsVUFBVThDLEtBQUs7WUFDckJ0QyxRQUFRQyxHQUFHLENBQUM7UUFDZCxFQUFFLE9BQU9lLE9BQU87WUFDZGhCLFFBQVF3QyxJQUFJLENBQUMsd0NBQXdDeEI7UUFDdkQsU0FBVTtZQUNSeEIsWUFBWTtZQUNaQyxlQUFlO1FBQ2pCO0lBQ0Y7QUFDRiIsInNvdXJjZXMiOlsiL1VzZXJzL2RlYW5uZXd0b24vRG9jdW1lbnRzL3hyYXkvbGliL2ZpcmVjcmF3bC1tY3AtY2xpZW50LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogRmlyZWNyYXdsIE1DUCBDbGllbnQgSW50ZWdyYXRpb25cbiAqIFVzZXMgdGhlIG9mZmljaWFsIEZpcmVjcmF3bCBNQ1Agc2VydmVyIGZvciBlbmhhbmNlZCB3ZWIgc2NyYXBpbmdcbiAqIFByb3ZpZGVzIGJhdGNoIHByb2Nlc3NpbmcsIGJldHRlciBlcnJvciBoYW5kbGluZywgYW5kIHByb3BlciBzY3JlZW5zaG90IG1hbmFnZW1lbnRcbiAqL1xuXG5pbXBvcnQgeyBDbGllbnQgfSBmcm9tICdAbW9kZWxjb250ZXh0cHJvdG9jb2wvc2RrL2NsaWVudC9pbmRleC5qcyc7XG5pbXBvcnQgeyBTdGRpb0NsaWVudFRyYW5zcG9ydCB9IGZyb20gJ0Btb2RlbGNvbnRleHRwcm90b2NvbC9zZGsvY2xpZW50L3N0ZGlvLmpzJztcbmltcG9ydCB7IHNwYXduIH0gZnJvbSAnY2hpbGRfcHJvY2Vzcyc7XG5cbi8vIE1DUCBDb25maWd1cmF0aW9uXG5jb25zdCBNQ1BfQ09ORklHID0ge1xuICByZXRyeU1heEF0dGVtcHRzOiAzLFxuICByZXRyeUluaXRpYWxEZWxheTogMjAwMCxcbiAgcmV0cnlCYWNrb2ZmRmFjdG9yOiAyLFxuICB0aW1lb3V0OiAxMjAwMDAsIC8vIDIgbWludXRlc1xuICBzZXJ2ZXJDb21tYW5kOiAnbnB4JyxcbiAgc2VydmVyQXJnczogWycteScsICdmaXJlY3Jhd2wtbWNwJ11cbn07XG5cbi8vIEdsb2JhbCBNQ1AgY2xpZW50IGluc3RhbmNlXG5sZXQgbWNwQ2xpZW50OiBDbGllbnQgfCBudWxsID0gbnVsbDtcbmxldCBtY3BUcmFuc3BvcnQ6IFN0ZGlvQ2xpZW50VHJhbnNwb3J0IHwgbnVsbCA9IG51bGw7XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBNQ1AgY2xpZW50IGNvbm5lY3Rpb25cbiAqL1xuYXN5bmMgZnVuY3Rpb24gaW5pdGlhbGl6ZU1DUENsaWVudCgpOiBQcm9taXNlPENsaWVudD4ge1xuICBpZiAobWNwQ2xpZW50KSB7XG4gICAgcmV0dXJuIG1jcENsaWVudDtcbiAgfVxuXG4gIHRyeSB7XG4gICAgY29uc3QgYXBpS2V5ID0gcHJvY2Vzcy5lbnYuRklSRUNSQVdMX0FQSV9LRVk7XG4gICAgaWYgKCFhcGlLZXkgfHwgYXBpS2V5ID09PSAneW91cl9maXJlY3Jhd2xfYXBpX2tleV9oZXJlJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGSVJFQ1JBV0xfQVBJX0tFWSBlbnZpcm9ubWVudCB2YXJpYWJsZSBpcyByZXF1aXJlZCcpO1xuICAgIH1cblxuICAgIGNvbnNvbGUubG9nKCfwn5SEIEluaXRpYWxpemluZyBGaXJlY3Jhd2wgTUNQIGNsaWVudC4uLicpO1xuXG4gICAgLy8gU2V0IHVwIGVudmlyb25tZW50IHZhcmlhYmxlcyBmb3IgdGhlIE1DUCBzZXJ2ZXJcbiAgICBjb25zdCBlbnYgPSB7XG4gICAgICAuLi5wcm9jZXNzLmVudixcbiAgICAgIEZJUkVDUkFXTF9BUElfS0VZOiBhcGlLZXksXG4gICAgICBGSVJFQ1JBV0xfUkVUUllfTUFYX0FUVEVNUFRTOiBNQ1BfQ09ORklHLnJldHJ5TWF4QXR0ZW1wdHMudG9TdHJpbmcoKSxcbiAgICAgIEZJUkVDUkFXTF9SRVRSWV9JTklUSUFMX0RFTEFZOiBNQ1BfQ09ORklHLnJldHJ5SW5pdGlhbERlbGF5LnRvU3RyaW5nKCksXG4gICAgICBGSVJFQ1JBV0xfUkVUUllfQkFDS09GRl9GQUNUT1I6IE1DUF9DT05GSUcucmV0cnlCYWNrb2ZmRmFjdG9yLnRvU3RyaW5nKClcbiAgICB9O1xuXG4gICAgLy8gU3Bhd24gdGhlIE1DUCBzZXJ2ZXIgcHJvY2Vzc1xuICAgIGNvbnN0IHNlcnZlclByb2Nlc3MgPSBzcGF3bihNQ1BfQ09ORklHLnNlcnZlckNvbW1hbmQsIE1DUF9DT05GSUcuc2VydmVyQXJncywge1xuICAgICAgZW52LFxuICAgICAgc3RkaW86IFsncGlwZScsICdwaXBlJywgJ3BpcGUnXVxuICAgIH0pO1xuXG4gICAgLy8gQ3JlYXRlIHRyYW5zcG9ydCBhbmQgY2xpZW50XG4gICAgbWNwVHJhbnNwb3J0ID0gbmV3IFN0ZGlvQ2xpZW50VHJhbnNwb3J0KHtcbiAgICAgIHJlYWRlcjogc2VydmVyUHJvY2Vzcy5zdGRvdXQsXG4gICAgICB3cml0ZXI6IHNlcnZlclByb2Nlc3Muc3RkaW5cbiAgICB9KTtcblxuICAgIG1jcENsaWVudCA9IG5ldyBDbGllbnQoXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICd4cmFpLWZpcmVjcmF3bC1jbGllbnQnLFxuICAgICAgICB2ZXJzaW9uOiAnMS4wLjAnXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBjYXBhYmlsaXRpZXM6IHt9XG4gICAgICB9XG4gICAgKTtcblxuICAgIC8vIENvbm5lY3QgdG8gdGhlIHNlcnZlclxuICAgIGF3YWl0IG1jcENsaWVudC5jb25uZWN0KG1jcFRyYW5zcG9ydCk7XG5cbiAgICBjb25zb2xlLmxvZygn4pyFIEZpcmVjcmF3bCBNQ1AgY2xpZW50IGluaXRpYWxpemVkIHN1Y2Nlc3NmdWxseScpO1xuICAgIHJldHVybiBtY3BDbGllbnQ7XG5cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCfinYwgRmFpbGVkIHRvIGluaXRpYWxpemUgTUNQIGNsaWVudDonLCBlcnJvcik7XG4gICAgbWNwQ2xpZW50ID0gbnVsbDtcbiAgICBtY3BUcmFuc3BvcnQgPSBudWxsO1xuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5cbi8qKlxuICogRXhlY3V0ZSBNQ1AgdG9vbCB3aXRoIHByb3BlciBlcnJvciBoYW5kbGluZyBhbmQgcmV0cmllc1xuICovXG5hc3luYyBmdW5jdGlvbiBleGVjdXRlTUNQVG9vbCh0b29sTmFtZTogc3RyaW5nLCBhcmd1bWVudHNfOiBhbnkpOiBQcm9taXNlPGFueT4ge1xuICBsZXQgbGFzdEVycm9yOiBFcnJvcjtcblxuICBmb3IgKGxldCBhdHRlbXB0ID0gMTsgYXR0ZW1wdCA8PSBNQ1BfQ09ORklHLnJldHJ5TWF4QXR0ZW1wdHM7IGF0dGVtcHQrKykge1xuICAgIHRyeSB7XG4gICAgICBjb25zb2xlLmxvZyhg8J+UhCBFeGVjdXRpbmcgTUNQIHRvb2w6ICR7dG9vbE5hbWV9IChhdHRlbXB0ICR7YXR0ZW1wdH0vJHtNQ1BfQ09ORklHLnJldHJ5TWF4QXR0ZW1wdHN9KWApO1xuXG4gICAgICBjb25zdCBjbGllbnQgPSBhd2FpdCBpbml0aWFsaXplTUNQQ2xpZW50KCk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNsaWVudC5jYWxsVG9vbCh7XG4gICAgICAgIG5hbWU6IHRvb2xOYW1lLFxuICAgICAgICBhcmd1bWVudHM6IGFyZ3VtZW50c19cbiAgICAgIH0pO1xuXG4gICAgICBpZiAocmVzdWx0LmlzRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBNQ1AgdG9vbCBlcnJvcjogJHtyZXN1bHQuY29udGVudD8uWzBdPy50ZXh0IHx8ICdVbmtub3duIGVycm9yJ31gKTtcbiAgICAgIH1cblxuICAgICAgY29uc29sZS5sb2coYOKchSBNQ1AgdG9vbCAke3Rvb2xOYW1lfSBjb21wbGV0ZWQgc3VjY2Vzc2Z1bGx5YCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxhc3RFcnJvciA9IGVycm9yIGFzIEVycm9yO1xuICAgICAgY29uc29sZS5lcnJvcihg4p2MIE1DUCB0b29sICR7dG9vbE5hbWV9IGF0dGVtcHQgJHthdHRlbXB0fSBmYWlsZWQ6YCwgZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpKTtcblxuICAgICAgaWYgKGF0dGVtcHQgPT09IE1DUF9DT05GSUcucmV0cnlNYXhBdHRlbXB0cykge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgLy8gQ2FsY3VsYXRlIGRlbGF5IHdpdGggZXhwb25lbnRpYWwgYmFja29mZlxuICAgICAgY29uc3QgZGVsYXkgPSBNYXRoLm1pbihcbiAgICAgICAgTUNQX0NPTkZJRy5yZXRyeUluaXRpYWxEZWxheSAqIE1hdGgucG93KE1DUF9DT05GSUcucmV0cnlCYWNrb2ZmRmFjdG9yLCBhdHRlbXB0IC0gMSksXG4gICAgICAgIDMwMDAwIC8vIE1heCAzMCBzZWNvbmRzXG4gICAgICApO1xuXG4gICAgICBjb25zb2xlLmxvZyhg4o+zIFdhaXRpbmcgJHtkZWxheX1tcyBiZWZvcmUgcmV0cnkuLi5gKTtcbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCBkZWxheSkpO1xuXG4gICAgICAvLyBSZXNldCBjbGllbnQgb24gZXJyb3IgdG8gZm9yY2UgcmVjb25uZWN0aW9uXG4gICAgICBpZiAobWNwQ2xpZW50KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYXdhaXQgbWNwQ2xpZW50LmNsb3NlKCk7XG4gICAgICAgIH0gY2F0Y2ggKGNsb3NlRXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ1dhcm5pbmc6IEZhaWxlZCB0byBjbG9zZSBNQ1AgY2xpZW50OicsIGNsb3NlRXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIG1jcENsaWVudCA9IG51bGw7XG4gICAgICAgIG1jcFRyYW5zcG9ydCA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdGhyb3cgbmV3IEVycm9yKGBNQ1AgdG9vbCAke3Rvb2xOYW1lfSBmYWlsZWQgYWZ0ZXIgJHtNQ1BfQ09ORklHLnJldHJ5TWF4QXR0ZW1wdHN9IGF0dGVtcHRzLiBMYXN0IGVycm9yOiAke2xhc3RFcnJvci5tZXNzYWdlfWApO1xufVxuXG4vKipcbiAqIEJhdGNoIHNjcmFwZSBtdWx0aXBsZSBVUkxzIHVzaW5nIEZpcmVjcmF3bCBNQ1Agc2VydmVyXG4gKiBUaGlzIGlzIHRoZSBwcmltYXJ5IG1ldGhvZCBmb3IgZWZmaWNpZW50IG11bHRpLXBhZ2Ugc2NyYXBpbmdcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGJhdGNoU2NyYXBlV2l0aE1DUCh1cmxzOiBzdHJpbmdbXSwgb3B0aW9ucz86IHtcbiAgZm9ybWF0cz86IHN0cmluZ1tdO1xuICBvbmx5TWFpbkNvbnRlbnQ/OiBib29sZWFuO1xuICB3YWl0Rm9yPzogbnVtYmVyO1xuICBtb2JpbGU/OiBib29sZWFuO1xufSk6IFByb21pc2U8YW55PiB7XG4gIHRyeSB7XG4gICAgY29uc29sZS5sb2coYPCfmoAgU3RhcnRpbmcgTUNQIGJhdGNoIHNjcmFwZSBmb3IgJHt1cmxzLmxlbmd0aH0gVVJMc2ApO1xuXG4gICAgLy8gUHJlcGFyZSBNQ1AgYmF0Y2ggc2NyYXBlIGFyZ3VtZW50c1xuICAgIGNvbnN0IG1jcEFyZ3MgPSB7XG4gICAgICB1cmxzLFxuICAgICAgb3B0aW9uczoge1xuICAgICAgICBmb3JtYXRzOiBvcHRpb25zPy5mb3JtYXRzIHx8IFsnbWFya2Rvd24nLCAnaHRtbCcsICdzY3JlZW5zaG90QGZ1bGxQYWdlJywgJ2xpbmtzJ10sXG4gICAgICAgIG9ubHlNYWluQ29udGVudDogb3B0aW9ucz8ub25seU1haW5Db250ZW50IHx8IGZhbHNlLFxuICAgICAgICB3YWl0Rm9yOiBvcHRpb25zPy53YWl0Rm9yIHx8IDUwMDAsXG4gICAgICAgIG1vYmlsZTogb3B0aW9ucz8ubW9iaWxlIHx8IGZhbHNlXG4gICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGV4ZWN1dGVNQ1BUb29sKCdmaXJlY3Jhd2xfYmF0Y2hfc2NyYXBlJywgbWNwQXJncyk7XG5cbiAgICBjb25zb2xlLmxvZyhg4pyFIE1DUCBiYXRjaCBzY3JhcGUgY29tcGxldGVkIGZvciAke3VybHMubGVuZ3RofSBVUkxzYCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcblxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBNQ1AgYmF0Y2ggc2NyYXBlIGZhaWxlZDonLCBlcnJvcik7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBNQ1AgYmF0Y2ggc2NyYXBlIGZhaWxlZDogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcil9YCk7XG4gIH1cbn1cblxuLyoqXG4gKiBTaW5nbGUgVVJMIHNjcmFwZSB1c2luZyBGaXJlY3Jhd2wgTUNQIHNlcnZlclxuICogVXNlIHRoaXMgZm9yIGluZGl2aWR1YWwgcGFnZSBzY3JhcGluZyB3aXRoIGFkdmFuY2VkIG9wdGlvbnNcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNjcmFwZVdpdGhNQ1AodXJsOiBzdHJpbmcsIG9wdGlvbnM/OiB7XG4gIGZvcm1hdHM/OiBzdHJpbmdbXTtcbiAgb25seU1haW5Db250ZW50PzogYm9vbGVhbjtcbiAgd2FpdEZvcj86IG51bWJlcjtcbiAgbW9iaWxlPzogYm9vbGVhbjtcbiAgYWN0aW9ucz86IGFueVtdO1xufSk6IFByb21pc2U8YW55PiB7XG4gIHRyeSB7XG4gICAgY29uc29sZS5sb2coYPCflIQgU3RhcnRpbmcgTUNQIHNjcmFwZSBmb3I6ICR7dXJsfWApO1xuXG4gICAgLy8gUHJlcGFyZSBNQ1Agc2NyYXBlIGFyZ3VtZW50c1xuICAgIGNvbnN0IG1jcEFyZ3MgPSB7XG4gICAgICB1cmwsXG4gICAgICBmb3JtYXRzOiBvcHRpb25zPy5mb3JtYXRzIHx8IFsnbWFya2Rvd24nLCAnaHRtbCcsICdzY3JlZW5zaG90QGZ1bGxQYWdlJywgJ2xpbmtzJ10sXG4gICAgICBvbmx5TWFpbkNvbnRlbnQ6IG9wdGlvbnM/Lm9ubHlNYWluQ29udGVudCB8fCBmYWxzZSxcbiAgICAgIHdhaXRGb3I6IG9wdGlvbnM/LndhaXRGb3IgfHwgNTAwMCxcbiAgICAgIG1vYmlsZTogb3B0aW9ucz8ubW9iaWxlIHx8IGZhbHNlLFxuICAgICAgYWN0aW9uczogb3B0aW9ucz8uYWN0aW9ucyB8fCBbXVxuICAgIH07XG5cbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBleGVjdXRlTUNQVG9vbCgnZmlyZWNyYXdsX3NjcmFwZScsIG1jcEFyZ3MpO1xuXG4gICAgY29uc29sZS5sb2coYOKchSBNQ1Agc2NyYXBlIGNvbXBsZXRlZCBmb3I6ICR7dXJsfWApO1xuICAgIHJldHVybiByZXN1bHQ7XG5cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKGDinYwgTUNQIHNjcmFwZSBmYWlsZWQgZm9yICR7dXJsfTpgLCBlcnJvcik7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBNQ1Agc2NyYXBlIGZhaWxlZDogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcil9YCk7XG4gIH1cbn1cblxuLyoqXG4gKiBNYXAgd2Vic2l0ZSBVUkxzIHVzaW5nIEZpcmVjcmF3bCBNQ1Agc2VydmVyXG4gKiBEaXNjb3ZlcnMgYWxsIGFjY2Vzc2libGUgVVJMcyBvbiBhIHdlYnNpdGVcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIG1hcFdlYnNpdGVXaXRoTUNQKHVybDogc3RyaW5nLCBvcHRpb25zPzoge1xuICBtYXhEZXB0aD86IG51bWJlcjtcbiAgbGltaXQ/OiBudW1iZXI7XG4gIGFsbG93RXh0ZXJuYWxMaW5rcz86IGJvb2xlYW47XG59KTogUHJvbWlzZTxzdHJpbmdbXT4ge1xuICB0cnkge1xuICAgIGNvbnNvbGUubG9nKGDwn5e677iPIFN0YXJ0aW5nIE1DUCB3ZWJzaXRlIG1hcHBpbmcgZm9yOiAke3VybH1gKTtcblxuICAgIC8vIFVzZSB0aGUgbWFwIHRvb2wgZm9yIFVSTCBkaXNjb3ZlcnlcbiAgICBjb25zdCBtY3BBcmdzID0ge1xuICAgICAgdXJsXG4gICAgfTtcblxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGV4ZWN1dGVNQ1BUb29sKCdmaXJlY3Jhd2xfbWFwJywgbWNwQXJncyk7XG5cbiAgICAvLyBFeHRyYWN0IFVSTHMgZnJvbSBtYXAgcmVzdWx0XG4gICAgaWYgKHJlc3VsdC5jb250ZW50ICYmIEFycmF5LmlzQXJyYXkocmVzdWx0LmNvbnRlbnQpKSB7XG4gICAgICAvLyBMb29rIGZvciB0ZXh0IGNvbnRlbnQgdGhhdCBjb250YWlucyBVUkxzXG4gICAgICBjb25zdCB0ZXh0Q29udGVudCA9IHJlc3VsdC5jb250ZW50LmZpbmQoKGl0ZW06IGFueSkgPT4gaXRlbS50eXBlID09PSAndGV4dCcpO1xuXG4gICAgICBpZiAodGV4dENvbnRlbnQgJiYgdGV4dENvbnRlbnQudGV4dCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFRyeSB0byBwYXJzZSBhcyBKU09OIGZpcnN0IChzdHJ1Y3R1cmVkIHJlc3BvbnNlKVxuICAgICAgICAgIGNvbnN0IHBhcnNlZERhdGEgPSBKU09OLnBhcnNlKHRleHRDb250ZW50LnRleHQpO1xuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHBhcnNlZERhdGEpKSB7XG4gICAgICAgICAgICBjb25zdCB1cmxzID0gcGFyc2VkRGF0YS5maWx0ZXIoKHVybDogc3RyaW5nKSA9PiB1cmwuc3RhcnRzV2l0aCgnaHR0cCcpKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGDinIUgTUNQIG1hcHBpbmcgZm91bmQgJHt1cmxzLmxlbmd0aH0gVVJMcyAoSlNPTiBmb3JtYXQpYCk7XG4gICAgICAgICAgICByZXR1cm4gdXJscztcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKHBhcnNlRXJyb3IpIHtcbiAgICAgICAgICAvLyBJZiBub3QgSlNPTiwgdHJ5IHRvIGV4dHJhY3QgVVJMcyBmcm9tIHBsYWluIHRleHRcbiAgICAgICAgICBjb25zdCB1cmxSZWdleCA9IC9odHRwcz86XFwvXFwvW15cXHNdKy9nO1xuICAgICAgICAgIGNvbnN0IHVybHMgPSB0ZXh0Q29udGVudC50ZXh0Lm1hdGNoKHVybFJlZ2V4KSB8fCBbXTtcblxuICAgICAgICAgIGlmICh1cmxzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGDinIUgTUNQIG1hcHBpbmcgZm91bmQgJHt1cmxzLmxlbmd0aH0gVVJMcyAodGV4dCBmb3JtYXQpYCk7XG4gICAgICAgICAgICByZXR1cm4gdXJscztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gRmFsbGJhY2s6IHRyeSB0byBleHRyYWN0IGZyb20gYWxsIHRleHQgaXRlbXNcbiAgICAgIGNvbnN0IHVybHMgPSByZXN1bHQuY29udGVudFxuICAgICAgICAuZmlsdGVyKChpdGVtOiBhbnkpID0+IGl0ZW0udHlwZSA9PT0gJ3RleHQnICYmIGl0ZW0udGV4dClcbiAgICAgICAgLm1hcCgoaXRlbTogYW55KSA9PiBpdGVtLnRleHQpXG4gICAgICAgIC5maWx0ZXIoKHRleHQ6IHN0cmluZykgPT4gdGV4dC5zdGFydHNXaXRoKCdodHRwJykpO1xuXG4gICAgICBpZiAodXJscy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGDinIUgTUNQIG1hcHBpbmcgZm91bmQgJHt1cmxzLmxlbmd0aH0gVVJMcyAoZmFsbGJhY2sgZm9ybWF0KWApO1xuICAgICAgICByZXR1cm4gdXJscztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zb2xlLmxvZygn4pqg77iPIE1DUCBtYXBwaW5nIHJldHVybmVkIHVuZXhwZWN0ZWQgZm9ybWF0LCB1c2luZyBmYWxsYmFjaycpO1xuICAgIHJldHVybiBbdXJsXTsgLy8gRmFsbGJhY2sgdG8gb3JpZ2luYWwgVVJMXG5cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCfinYwgTUNQIHdlYnNpdGUgbWFwcGluZyBmYWlsZWQ6JywgZXJyb3IpO1xuICAgIHRocm93IG5ldyBFcnJvcihgTUNQIG1hcHBpbmcgZmFpbGVkOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKX1gKTtcbiAgfVxufVxuXG4vKipcbiAqIENoZWNrIGlmIE1DUCBzZXJ2ZXIgaXMgYXZhaWxhYmxlIGFuZCBwcm9wZXJseSBjb25maWd1cmVkXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjaGVja01DUEF2YWlsYWJpbGl0eSgpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCBhcGlLZXkgPSBwcm9jZXNzLmVudi5GSVJFQ1JBV0xfQVBJX0tFWTtcbiAgICBpZiAoIWFwaUtleSB8fCBhcGlLZXkgPT09ICd5b3VyX2ZpcmVjcmF3bF9hcGlfa2V5X2hlcmUnKSB7XG4gICAgICBjb25zb2xlLmxvZygn4p2MIE1DUCBub3QgYXZhaWxhYmxlOiBGSVJFQ1JBV0xfQVBJX0tFWSBub3QgY29uZmlndXJlZCcpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnNvbGUubG9nKCfwn5SNIFRlc3RpbmcgTUNQIHNlcnZlciBhdmFpbGFiaWxpdHkuLi4nKTtcblxuICAgIC8vIFRyeSB0byBpbml0aWFsaXplIHRoZSBNQ1AgY2xpZW50XG4gICAgY29uc3QgY2xpZW50ID0gYXdhaXQgaW5pdGlhbGl6ZU1DUENsaWVudCgpO1xuXG4gICAgLy8gTGlzdCBhdmFpbGFibGUgdG9vbHMgdG8gdmVyaWZ5IHRoZSBzZXJ2ZXIgaXMgd29ya2luZ1xuICAgIGNvbnN0IHRvb2xzID0gYXdhaXQgY2xpZW50Lmxpc3RUb29scygpO1xuXG4gICAgaWYgKHRvb2xzICYmIHRvb2xzLnRvb2xzICYmIHRvb2xzLnRvb2xzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IHRvb2xOYW1lcyA9IHRvb2xzLnRvb2xzLm1hcCgodG9vbDogYW55KSA9PiB0b29sLm5hbWUpO1xuICAgICAgY29uc29sZS5sb2coYOKchSBNQ1Agc2VydmVyIGF2YWlsYWJsZSB3aXRoIHRvb2xzOiAke3Rvb2xOYW1lcy5qb2luKCcsICcpfWApO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUubG9nKCfimqDvuI8gTUNQIHNlcnZlciBjb25uZWN0ZWQgYnV0IG5vIHRvb2xzIGF2YWlsYWJsZScpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUubG9nKCfinYwgTUNQIHNlcnZlciBub3QgYXZhaWxhYmxlOicsIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKSk7XG5cbiAgICAvLyBDbGVhbiB1cCBmYWlsZWQgY29ubmVjdGlvblxuICAgIGlmIChtY3BDbGllbnQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IG1jcENsaWVudC5jbG9zZSgpO1xuICAgICAgfSBjYXRjaCAoY2xvc2VFcnJvcikge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1dhcm5pbmc6IEZhaWxlZCB0byBjbG9zZSBNQ1AgY2xpZW50IGR1cmluZyBhdmFpbGFiaWxpdHkgY2hlY2s6JywgY2xvc2VFcnJvcik7XG4gICAgICB9XG4gICAgICBtY3BDbGllbnQgPSBudWxsO1xuICAgICAgbWNwVHJhbnNwb3J0ID0gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLyoqXG4gKiBFeHRyYWN0IHN0cnVjdHVyZWQgZGF0YSB1c2luZyBNQ1Agc2VydmVyXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBleHRyYWN0V2l0aE1DUCh1cmxzOiBzdHJpbmdbXSwgb3B0aW9ucz86IHtcbiAgcHJvbXB0Pzogc3RyaW5nO1xuICBzY2hlbWE/OiBhbnk7XG59KTogUHJvbWlzZTxhbnk+IHtcbiAgdHJ5IHtcbiAgICBjb25zb2xlLmxvZyhg8J+UjSBTdGFydGluZyBNQ1AgZXh0cmFjdGlvbiBmb3IgJHt1cmxzLmxlbmd0aH0gVVJMc2ApO1xuXG4gICAgY29uc3QgbWNwQXJncyA9IHtcbiAgICAgIHVybHMsXG4gICAgICBwcm9tcHQ6IG9wdGlvbnM/LnByb21wdCB8fCAnRXh0cmFjdCBhbGwgcmVsZXZhbnQgaW5mb3JtYXRpb24gZnJvbSB0aGlzIHdlYnBhZ2UnLFxuICAgICAgc2NoZW1hOiBvcHRpb25zPy5zY2hlbWFcbiAgICB9O1xuXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZXhlY3V0ZU1DUFRvb2woJ2ZpcmVjcmF3bF9leHRyYWN0JywgbWNwQXJncyk7XG5cbiAgICBjb25zb2xlLmxvZyhg4pyFIE1DUCBleHRyYWN0aW9uIGNvbXBsZXRlZCBmb3IgJHt1cmxzLmxlbmd0aH0gVVJMc2ApO1xuICAgIHJldHVybiByZXN1bHQ7XG5cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCfinYwgTUNQIGV4dHJhY3Rpb24gZmFpbGVkOicsIGVycm9yKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYE1DUCBleHRyYWN0aW9uIGZhaWxlZDogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcil9YCk7XG4gIH1cbn1cblxuLyoqXG4gKiBDbGVhbiB1cCBNQ1AgY2xpZW50IGNvbm5lY3Rpb25cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNsb3NlTUNQQ2xpZW50KCk6IFByb21pc2U8dm9pZD4ge1xuICBpZiAobWNwQ2xpZW50KSB7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IG1jcENsaWVudC5jbG9zZSgpO1xuICAgICAgY29uc29sZS5sb2coJ+KchSBNQ1AgY2xpZW50IGNvbm5lY3Rpb24gY2xvc2VkJyk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUud2FybignV2FybmluZzogRmFpbGVkIHRvIGNsb3NlIE1DUCBjbGllbnQ6JywgZXJyb3IpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBtY3BDbGllbnQgPSBudWxsO1xuICAgICAgbWNwVHJhbnNwb3J0ID0gbnVsbDtcbiAgICB9XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJDbGllbnQiLCJTdGRpb0NsaWVudFRyYW5zcG9ydCIsInNwYXduIiwiTUNQX0NPTkZJRyIsInJldHJ5TWF4QXR0ZW1wdHMiLCJyZXRyeUluaXRpYWxEZWxheSIsInJldHJ5QmFja29mZkZhY3RvciIsInRpbWVvdXQiLCJzZXJ2ZXJDb21tYW5kIiwic2VydmVyQXJncyIsIm1jcENsaWVudCIsIm1jcFRyYW5zcG9ydCIsImluaXRpYWxpemVNQ1BDbGllbnQiLCJhcGlLZXkiLCJwcm9jZXNzIiwiZW52IiwiRklSRUNSQVdMX0FQSV9LRVkiLCJFcnJvciIsImNvbnNvbGUiLCJsb2ciLCJGSVJFQ1JBV0xfUkVUUllfTUFYX0FUVEVNUFRTIiwidG9TdHJpbmciLCJGSVJFQ1JBV0xfUkVUUllfSU5JVElBTF9ERUxBWSIsIkZJUkVDUkFXTF9SRVRSWV9CQUNLT0ZGX0ZBQ1RPUiIsInNlcnZlclByb2Nlc3MiLCJzdGRpbyIsInJlYWRlciIsInN0ZG91dCIsIndyaXRlciIsInN0ZGluIiwibmFtZSIsInZlcnNpb24iLCJjYXBhYmlsaXRpZXMiLCJjb25uZWN0IiwiZXJyb3IiLCJleGVjdXRlTUNQVG9vbCIsInRvb2xOYW1lIiwiYXJndW1lbnRzXyIsImxhc3RFcnJvciIsImF0dGVtcHQiLCJjbGllbnQiLCJyZXN1bHQiLCJjYWxsVG9vbCIsImFyZ3VtZW50cyIsImlzRXJyb3IiLCJjb250ZW50IiwidGV4dCIsIm1lc3NhZ2UiLCJTdHJpbmciLCJkZWxheSIsIk1hdGgiLCJtaW4iLCJwb3ciLCJQcm9taXNlIiwicmVzb2x2ZSIsInNldFRpbWVvdXQiLCJjbG9zZSIsImNsb3NlRXJyb3IiLCJ3YXJuIiwiYmF0Y2hTY3JhcGVXaXRoTUNQIiwidXJscyIsIm9wdGlvbnMiLCJsZW5ndGgiLCJtY3BBcmdzIiwiZm9ybWF0cyIsIm9ubHlNYWluQ29udGVudCIsIndhaXRGb3IiLCJtb2JpbGUiLCJzY3JhcGVXaXRoTUNQIiwidXJsIiwiYWN0aW9ucyIsIm1hcFdlYnNpdGVXaXRoTUNQIiwiQXJyYXkiLCJpc0FycmF5IiwidGV4dENvbnRlbnQiLCJmaW5kIiwiaXRlbSIsInR5cGUiLCJwYXJzZWREYXRhIiwiSlNPTiIsInBhcnNlIiwiZmlsdGVyIiwic3RhcnRzV2l0aCIsInBhcnNlRXJyb3IiLCJ1cmxSZWdleCIsIm1hdGNoIiwibWFwIiwiY2hlY2tNQ1BBdmFpbGFiaWxpdHkiLCJ0b29scyIsImxpc3RUb29scyIsInRvb2xOYW1lcyIsInRvb2wiLCJqb2luIiwiZXh0cmFjdFdpdGhNQ1AiLCJwcm9tcHQiLCJzY2hlbWEiLCJjbG9zZU1DUENsaWVudCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./lib/firecrawl-mcp-client.ts\n");

/***/ }),

/***/ "(rsc)/./lib/generate-docs.ts":
/*!******************************!*\
  !*** ./lib/generate-docs.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   generateSonnetPrompt: () => (/* binding */ generateSonnetPrompt),\n/* harmony export */   generateWebsiteRebuildPackage: () => (/* binding */ generateWebsiteRebuildPackage)\n/* harmony export */ });\n/* harmony import */ var jszip__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jszip */ \"(rsc)/./node_modules/jszip/lib/index.js\");\n/* harmony import */ var jszip__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jszip__WEBPACK_IMPORTED_MODULE_0__);\n/**\n * Documentation generation utilities for the Website Rebuild Prompt Generator\n * Transforms scraped website data into Claude Sonnet-optimized prompts and comprehensive packages\n */ \n/**\n * Generate a comprehensive website rebuild package\n * @param siteMapData - Processed site map data\n * @param contentData - Processed content data for each page\n * @param performanceData - Processed performance metrics\n * @param structuredData - Extracted structured data about the website\n * @param analysisId - Unique ID for this analysis\n * @returns A comprehensive package with multiple files and folders\n */ async function generateWebsiteRebuildPackage(siteMapData, contentData, performanceData, structuredData, analysisId) {\n    const zip = new (jszip__WEBPACK_IMPORTED_MODULE_0___default())();\n    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');\n    const packageName = `website-rebuild-${timestamp}`;\n    // 1. Generate the main AI prompt (Markdown)\n    const promptMarkdown = generatePromptMarkdown(siteMapData, contentData, performanceData, structuredData);\n    zip.file(`${packageName}/README.md`, promptMarkdown);\n    // 2. Save individual page HTML files\n    const pagesFolder = zip.folder(`${packageName}/pages`);\n    await savePageFiles(pagesFolder, contentData);\n    // 3. Save screenshots\n    const screenshotsFolder = zip.folder(`${packageName}/screenshots`);\n    await saveScreenshots(screenshotsFolder, contentData);\n    // 4. Save downloaded assets\n    const assetsFolder = zip.folder(`${packageName}/assets`);\n    await saveAssets(assetsFolder, contentData);\n    // 4.5. Save extracted CSS files\n    const cssFolder = assetsFolder.folder('css');\n    await saveCSSFiles(cssFolder, contentData);\n    // 5. Generate technical documentation\n    const docsFolder = zip.folder(`${packageName}/docs`);\n    await generateTechnicalDocs(docsFolder, siteMapData, contentData, performanceData, structuredData);\n    // 6. Create package manifest\n    const manifest = generatePackageManifest(siteMapData, contentData, performanceData, structuredData, analysisId);\n    zip.file(`${packageName}/package.json`, JSON.stringify(manifest, null, 2));\n    return {\n        zip,\n        packageName,\n        manifest\n    };\n}\n/**\n * Legacy function for backward compatibility\n * @param siteMapData - Processed site map data\n * @param contentData - Processed content data for each page\n * @param performanceData - Processed performance metrics\n * @param structuredData - Extracted structured data about the website\n * @returns A structured prompt object optimized for Claude Sonnet\n */ function generateSonnetPrompt(siteMapData, contentData, performanceData, structuredData) {\n    // Create the base prompt structure\n    const prompt = {\n        metadata: {\n            generatedAt: new Date().toISOString(),\n            version: '1.0.0',\n            generatedFor: 'Claude Sonnet AI IDE',\n            promptType: 'website-reconstruction'\n        },\n        siteOverview: generateSiteOverview(siteMapData, structuredData),\n        pageDetails: generatePageDetails(contentData),\n        components: identifyComponents(contentData),\n        assets: extractAssetReferences(contentData),\n        performanceConsiderations: generatePerformanceGuidelines(performanceData),\n        reconstructionInstructions: generateReconstructionInstructions(siteMapData, structuredData)\n    };\n    return prompt;\n}\n/**\n * Generate a comprehensive site overview section\n * @param siteMapData - Processed site map data\n * @param structuredData - Extracted structured data about the website\n * @returns Site overview section\n */ function generateSiteOverview(siteMapData, structuredData) {\n    const pageCount = siteMapData.pages?.length || 0;\n    const technologies = structuredData?.technologies || [];\n    const designPatterns = structuredData?.designPatterns || [];\n    const colorPalette = structuredData?.colorPalette || [];\n    const fontFamilies = structuredData?.fontFamilies || [];\n    return {\n        title: 'Site Overview',\n        description: `This website consists of ${pageCount} pages with the following structure and characteristics:`,\n        structure: siteMapData.structure || {},\n        pageHierarchy: generatePageHierarchy(siteMapData),\n        technologies,\n        designPatterns,\n        colorPalette,\n        fontFamilies,\n        keyFeatures: structuredData?.keyFeatures || []\n    };\n}\n/**\n * Generate a hierarchical representation of the site's pages\n * @param siteMapData - Processed site map data\n * @returns Hierarchical page structure\n */ function generatePageHierarchy(siteMapData) {\n    const pages = siteMapData.pages || [];\n    const hierarchy = {};\n    // Group pages by path depth\n    pages.forEach((url)=>{\n        try {\n            const urlObj = new URL(url);\n            const path = urlObj.pathname;\n            const segments = path.split('/').filter(Boolean);\n            const depth = segments.length;\n            if (!hierarchy[depth]) {\n                hierarchy[depth] = [];\n            }\n            hierarchy[depth].push({\n                url,\n                path,\n                segments\n            });\n        } catch (error) {\n            console.warn(`Error processing URL for hierarchy: ${url}`, error);\n        }\n    });\n    return hierarchy;\n}\n/**\n * Generate detailed information for each page\n * @param contentData - Processed content data for each page\n * @returns Page-by-page details\n */ function generatePageDetails(contentData) {\n    const pageDetails = {};\n    // Process each page's content data\n    Object.entries(contentData).forEach(([url, data])=>{\n        try {\n            const urlObj = new URL(url);\n            const path = urlObj.pathname;\n            const pageName = path === '/' ? 'Homepage' : path.split('/').filter(Boolean).pop() || path;\n            const pageData = data;\n            pageDetails[url] = {\n                title: pageData.metadata?.title || pageName,\n                path,\n                htmlStructure: generateHtmlStructureSummary(pageData.html || ''),\n                cssClasses: extractCssClasses(pageData.html || ''),\n                metadata: pageData.metadata || {},\n                assets: pageData.assets || [],\n                links: pageData.links || []\n            };\n        } catch (error) {\n            console.warn(`Error processing page details for: ${url}`, error);\n        }\n    });\n    return pageDetails;\n}\n/**\n * Generate a summary of the HTML structure\n * @param html - Raw HTML content\n * @returns HTML structure summary\n */ function generateHtmlStructureSummary(html) {\n    // Extract main structural elements\n    const headMatch = html.match(/<head[^>]*>([\\s\\S]*?)<\\/head>/i);\n    const bodyMatch = html.match(/<body[^>]*>([\\s\\S]*?)<\\/body>/i);\n    const headContent = headMatch ? headMatch[1] : '';\n    const bodyContent = bodyMatch ? bodyMatch[1] : '';\n    // Extract key sections\n    const headerMatch = bodyContent.match(/<header[^>]*>([\\s\\S]*?)<\\/header>/i);\n    const mainMatch = bodyContent.match(/<main[^>]*>([\\s\\S]*?)<\\/main>/i);\n    const footerMatch = bodyContent.match(/<footer[^>]*>([\\s\\S]*?)<\\/footer>/i);\n    // Count elements by type\n    const elementCounts = {};\n    const elementRegex = /<([a-z0-9]+)[\\s>]/gi;\n    let match;\n    while((match = elementRegex.exec(html)) !== null){\n        const tag = match[1].toLowerCase();\n        elementCounts[tag] = (elementCounts[tag] || 0) + 1;\n    }\n    return {\n        doctype: html.match(/<!DOCTYPE[^>]*>/i)?.[0] || 'No doctype found',\n        headElements: {\n            title: headContent.match(/<title[^>]*>([\\s\\S]*?)<\\/title>/i)?.[1] || '',\n            metaTags: (headContent.match(/<meta[^>]*>/gi) || []).length,\n            styleSheets: (headContent.match(/<link[^>]*rel=[\"']stylesheet[\"'][^>]*>/gi) || []).length,\n            scripts: (headContent.match(/<script[^>]*>/gi) || []).length\n        },\n        bodyStructure: {\n            hasHeader: !!headerMatch,\n            hasMain: !!mainMatch,\n            hasFooter: !!footerMatch,\n            navMenus: (bodyContent.match(/<nav[^>]*>/gi) || []).length,\n            sections: (bodyContent.match(/<section[^>]*>/gi) || []).length,\n            articles: (bodyContent.match(/<article[^>]*>/gi) || []).length,\n            asides: (bodyContent.match(/<aside[^>]*>/gi) || []).length\n        },\n        elementCounts\n    };\n}\n/**\n * Clean component content for better AI consumption\n * @param content - Raw HTML component content\n * @returns Cleaned and formatted component content\n */ function cleanComponentContent(content) {\n    if (!content) return 'No content available';\n    // Remove excessive whitespace but preserve structure\n    let cleaned = content.replace(/\\s+/g, ' ').replace(/>\\s+</g, '><').trim();\n    // If content is very long, provide a meaningful preview with key attributes\n    if (cleaned.length > 1000) {\n        // Extract key information: tag name, classes, IDs, and first level of content\n        const tagMatch = cleaned.match(/^<(\\w+)([^>]*)>/);\n        if (tagMatch) {\n            const tagName = tagMatch[1];\n            const attributes = tagMatch[2];\n            // Extract class and id attributes\n            const classMatch = attributes.match(/class=[\"']([^\"']*)[\"']/);\n            const idMatch = attributes.match(/id=[\"']([^\"']*)[\"']/);\n            let summary = `<${tagName}`;\n            if (classMatch) summary += ` class=\"${classMatch[1]}\"`;\n            if (idMatch) summary += ` id=\"${idMatch[1]}\"`;\n            summary += '>';\n            // Add first level content preview\n            const contentMatch = cleaned.match(/>([^<]{0,200})/);\n            if (contentMatch && contentMatch[1].trim()) {\n                summary += contentMatch[1].trim();\n                if (contentMatch[1].length > 200) summary += '...';\n            }\n            summary += `</${tagName}>`;\n            return summary + '\\n\\n**Note**: Full component content available in pages/ folder';\n        }\n    }\n    return cleaned;\n}\n/**\n * Extract CSS classes from HTML content\n * @param html - Raw HTML content\n * @returns Array of unique CSS classes\n */ function extractCssClasses(html) {\n    const classes = new Set();\n    const classRegex = /class=[\"']([^\"']+)[\"']/gi;\n    let match;\n    while((match = classRegex.exec(html)) !== null){\n        if (match[1]) {\n            match[1].split(/\\s+/).forEach((cls)=>{\n                if (cls) classes.add(cls);\n            });\n        }\n    }\n    return Array.from(classes);\n}\n/**\n * Identify common components across pages\n * @param contentData - Processed content data for each page\n * @returns Identified components\n */ function identifyComponents(contentData) {\n    const components = {\n        navigation: [],\n        footer: [],\n        header: [],\n        sidebar: [],\n        cards: [],\n        forms: [],\n        custom: []\n    };\n    // Process each page to identify components\n    Object.entries(contentData).forEach(([url, data])=>{\n        const pageData = data;\n        const html = pageData.html || '';\n        // Extract navigation components\n        const navMatches = html.match(/<nav[^>]*>([\\s\\S]*?)<\\/nav>/gi) || [];\n        navMatches.forEach((nav, index)=>{\n            components.navigation.push({\n                source: url,\n                index,\n                content: nav\n            });\n        });\n        // Extract footer components\n        const footerMatches = html.match(/<footer[^>]*>([\\s\\S]*?)<\\/footer>/gi) || [];\n        footerMatches.forEach((footer, index)=>{\n            components.footer.push({\n                source: url,\n                index,\n                content: footer\n            });\n        });\n        // Extract header components\n        const headerMatches = html.match(/<header[^>]*>([\\s\\S]*?)<\\/header>/gi) || [];\n        headerMatches.forEach((header, index)=>{\n            components.header.push({\n                source: url,\n                index,\n                content: header\n            });\n        });\n        // Extract sidebar components\n        const sidebarMatches = html.match(/<aside[^>]*>([\\s\\S]*?)<\\/aside>/gi) || [];\n        sidebarMatches.forEach((sidebar, index)=>{\n            components.sidebar.push({\n                source: url,\n                index,\n                content: sidebar\n            });\n        });\n        // Extract form components\n        const formMatches = html.match(/<form[^>]*>([\\s\\S]*?)<\\/form>/gi) || [];\n        formMatches.forEach((form, index)=>{\n            components.forms.push({\n                source: url,\n                index,\n                content: form\n            });\n        });\n        // Identify card-like components (divs with certain classes)\n        const cardClassRegex = /class=[\"'][^\"']*card[^\"']*[\"']/i;\n        const divMatches = html.match(/<div[^>]*>([\\s\\S]*?)<\\/div>/gi) || [];\n        divMatches.forEach((div, index)=>{\n            if (cardClassRegex.test(div)) {\n                components.cards.push({\n                    source: url,\n                    index,\n                    content: div\n                });\n            }\n        });\n    });\n    // Deduplicate components by comparing content\n    const deduplicated = {};\n    Object.entries(components).forEach(([type, items])=>{\n        const uniqueItems = new Map();\n        items.forEach((item)=>{\n            // Create a simplified version of the content for comparison\n            const simplifiedContent = item.content.replace(/\\s+/g, ' ').replace(/class=[\"'][^\"']*[\"']/gi, '').replace(/id=[\"'][^\"']*[\"']/gi, '').replace(/style=[\"'][^\"']*[\"']/gi, '');\n            if (!uniqueItems.has(simplifiedContent)) {\n                uniqueItems.set(simplifiedContent, item);\n            }\n        });\n        deduplicated[type] = Array.from(uniqueItems.values());\n    });\n    return deduplicated;\n}\n/**\n * Extract asset references from content data\n * @param contentData - Processed content data for each page\n * @returns Asset references\n */ function extractAssetReferences(contentData) {\n    const assets = {\n        css: new Set(),\n        javascript: new Set(),\n        images: new Set(),\n        fonts: new Set(),\n        videos: new Set(),\n        other: new Set()\n    };\n    // Process each page to extract asset references\n    Object.entries(contentData).forEach(([_url, data])=>{\n        const pageData = data;\n        const pageAssets = pageData.assets || [];\n        pageAssets.forEach((asset)=>{\n            const assetUrl = asset.url;\n            const assetType = asset.type?.toLowerCase() || 'other';\n            switch(assetType){\n                case 'css':\n                    assets.css.add(assetUrl);\n                    break;\n                case 'javascript':\n                    assets.javascript.add(assetUrl);\n                    break;\n                case 'image':\n                    assets.images.add(assetUrl);\n                    break;\n                case 'font':\n                    assets.fonts.add(assetUrl);\n                    break;\n                case 'video':\n                    assets.videos.add(assetUrl);\n                    break;\n                default:\n                    assets.other.add(assetUrl);\n                    break;\n            }\n        });\n    });\n    // Convert Sets to Arrays for the final output\n    const result = {};\n    Object.entries(assets).forEach(([type, urls])=>{\n        result[type] = Array.from(urls);\n    });\n    return result;\n}\n/**\n * Generate performance guidelines based on Lighthouse metrics\n * @param performanceData - Processed performance metrics\n * @returns Performance guidelines\n */ function generatePerformanceGuidelines(performanceData) {\n    if (!performanceData) {\n        return {\n            title: 'Performance Considerations',\n            description: 'No performance data available.',\n            recommendations: []\n        };\n    }\n    const performance = performanceData.performance || {};\n    const accessibility = performanceData.accessibility || {};\n    const seo = performanceData.seo || {};\n    const bestPractices = performanceData.bestPractices || {};\n    const recommendations = [];\n    // Add performance recommendations\n    const perfScore = performance.score || 0;\n    if (perfScore < 0.9) {\n        recommendations.push('Optimize page load performance to improve user experience');\n        const metrics = performance.metrics || {};\n        const fcp = metrics.firstContentfulPaint?.value;\n        const lcp = metrics.largestContentfulPaint?.value;\n        const tbt = metrics.totalBlockingTime?.value;\n        const cls = metrics.cumulativeLayoutShift?.value;\n        if (fcp > 1000) {\n            recommendations.push('Reduce First Contentful Paint time to under 1 second');\n        }\n        if (lcp > 2500) {\n            recommendations.push('Optimize Largest Contentful Paint to under 2.5 seconds');\n        }\n        if (tbt > 200) {\n            recommendations.push('Reduce Total Blocking Time to improve interactivity');\n        }\n        if (cls > 0.1) {\n            recommendations.push('Minimize Cumulative Layout Shift to improve visual stability');\n        }\n    }\n    // Add accessibility recommendations\n    if (accessibility.score < 0.9) {\n        recommendations.push('Improve accessibility to ensure the site is usable by everyone');\n    }\n    // Add SEO recommendations\n    if (seo.score < 0.9) {\n        recommendations.push('Enhance SEO practices to improve search engine visibility');\n    }\n    // Add best practices recommendations\n    if (bestPractices.score < 0.9) {\n        recommendations.push('Follow web best practices for security and quality');\n    }\n    return {\n        title: 'Performance Considerations',\n        description: 'Consider these performance metrics when rebuilding the website:',\n        scores: {\n            performance: performance.score || 0,\n            accessibility: accessibility.score || 0,\n            seo: seo.score || 0,\n            bestPractices: bestPractices.score || 0\n        },\n        metrics: {\n            firstContentfulPaint: performance.metrics?.firstContentfulPaint,\n            largestContentfulPaint: performance.metrics?.largestContentfulPaint,\n            totalBlockingTime: performance.metrics?.totalBlockingTime,\n            cumulativeLayoutShift: performance.metrics?.cumulativeLayoutShift\n        },\n        recommendations\n    };\n}\n/**\n * Generate step-by-step reconstruction instructions\n * @param siteMapData - Processed site map data\n * @param structuredData - Extracted structured data about the website\n * @returns Reconstruction instructions\n */ function generateReconstructionInstructions(_siteMapData, structuredData) {\n    const technologies = structuredData?.technologies || [];\n    const hasFrontendFramework = technologies.some((tech)=>/react|vue|angular|svelte|next|nuxt/i.test(tech));\n    const steps = [\n        {\n            title: '1. Project Setup',\n            description: 'Set up the development environment and project structure',\n            tasks: [\n                'Create a new project directory',\n                `Initialize the project with ${hasFrontendFramework ? 'the appropriate framework' : 'HTML, CSS, and JavaScript files'}`,\n                'Set up the folder structure for assets, components, and pages',\n                'Install necessary dependencies'\n            ]\n        },\n        {\n            title: '2. Asset Collection',\n            description: 'Gather and organize all required assets',\n            tasks: [\n                'Download or recreate all CSS files',\n                'Download or recreate all JavaScript files',\n                'Collect all images, fonts, and other media assets',\n                'Organize assets in the appropriate directories'\n            ]\n        },\n        {\n            title: '3. Component Development',\n            description: 'Build reusable components identified in the analysis',\n            tasks: [\n                'Create the header component',\n                'Create the navigation component',\n                'Create the footer component',\n                'Develop any sidebar components',\n                'Build card and form components',\n                'Implement any custom components specific to the site'\n            ]\n        },\n        {\n            title: '4. Page Construction',\n            description: 'Build individual pages using the components',\n            tasks: [\n                'Create the homepage with appropriate layout and components',\n                'Develop secondary pages following the site hierarchy',\n                'Implement responsive design for all pages',\n                'Ensure consistent styling across the site'\n            ]\n        },\n        {\n            title: '5. Functionality Implementation',\n            description: 'Add interactive features and functionality',\n            tasks: [\n                'Implement navigation and routing',\n                'Add form validation and submission handling',\n                'Implement any interactive elements (sliders, accordions, etc.)',\n                'Add any required API integrations or data fetching'\n            ]\n        },\n        {\n            title: '6. Testing and Optimization',\n            description: 'Test the site and optimize performance',\n            tasks: [\n                'Test the site across different browsers and devices',\n                'Optimize images and assets for performance',\n                'Implement performance best practices',\n                'Ensure accessibility compliance',\n                'Validate HTML and CSS'\n            ]\n        },\n        {\n            title: '7. Deployment',\n            description: 'Prepare the site for deployment',\n            tasks: [\n                'Bundle and minify assets',\n                'Configure appropriate caching strategies',\n                'Set up any required server configurations',\n                'Deploy the site to the hosting environment'\n            ]\n        }\n    ];\n    return {\n        title: 'Reconstruction Instructions',\n        description: 'Follow these steps to rebuild the website with maximum fidelity:',\n        steps\n    };\n}\n/**\n * Generate Claude Sonnet-specific reconstruction instructions\n * @param siteMapData - Processed site map data\n * @param structuredData - Extracted structured data about the website\n * @param components - Identified components\n * @param assets - Asset references\n * @returns Claude Sonnet-optimized instructions\n */ function generateClaudeSonnetInstructions(siteMapData, structuredData, components, assets) {\n    const technologies = structuredData?.technologies || [];\n    const pageCount = siteMapData.pages?.length || 0;\n    const componentCount = Object.values(components).reduce((sum, items)=>sum + items.length, 0);\n    const assetCount = Object.values(assets).reduce((sum, items)=>sum + items.length, 0);\n    // Determine recommended tech stack based on analysis\n    const recommendedFramework = technologies.some((t)=>/react|next/i.test(t)) ? 'Next.js' : technologies.some((t)=>/vue|nuxt/i.test(t)) ? 'Nuxt.js' : technologies.some((t)=>/svelte|sveltekit/i.test(t)) ? 'SvelteKit' : 'Vite + vanilla JS';\n    const recommendedStyling = technologies.some((t)=>/tailwind/i.test(t)) ? 'Tailwind CSS' : technologies.some((t)=>/styled-components/i.test(t)) ? 'Styled Components' : technologies.some((t)=>/emotion/i.test(t)) ? 'Emotion' : 'CSS Modules';\n    return {\n        title: 'Claude Sonnet Reconstruction Protocol',\n        description: `Optimized workflow for rebuilding ${pageCount} pages with ${componentCount} components and ${assetCount} assets`,\n        framework: recommendedFramework,\n        styling: recommendedStyling,\n        workflow: [\n            {\n                phase: 'Analysis & Planning',\n                duration: '15-30 minutes',\n                tasks: [\n                    'Review all screenshots to understand visual hierarchy',\n                    'Analyze component patterns across pages',\n                    'Identify responsive breakpoints and layout systems',\n                    'Plan component architecture and reusability',\n                    'Document color palette and typography system'\n                ]\n            },\n            {\n                phase: 'Environment Setup',\n                duration: '10-15 minutes',\n                tasks: [\n                    `Initialize ${recommendedFramework} project`,\n                    `Configure ${recommendedStyling} for styling`,\n                    'Set up development tools (ESLint, Prettier, TypeScript)',\n                    'Create folder structure for components and pages',\n                    'Install additional dependencies as needed'\n                ]\n            },\n            {\n                phase: 'Asset Integration',\n                duration: '20-30 minutes',\n                tasks: [\n                    'Run asset download script from assets/ folder',\n                    'Optimize images for web (WebP conversion, compression)',\n                    'Set up font loading strategy',\n                    'Configure asset bundling and optimization',\n                    'Test asset loading in development environment'\n                ]\n            },\n            {\n                phase: 'Component Development',\n                duration: '60-90 minutes',\n                tasks: [\n                    'Build layout components (Header, Footer, Navigation)',\n                    'Create UI components (Buttons, Cards, Forms)',\n                    'Implement interactive components (Modals, Dropdowns)',\n                    'Add responsive behavior and mobile optimization',\n                    'Test component isolation and reusability'\n                ]\n            },\n            {\n                phase: 'Page Assembly',\n                duration: '45-60 minutes',\n                tasks: [\n                    'Construct homepage using components',\n                    'Build remaining pages following hierarchy',\n                    'Implement routing and navigation',\n                    'Add page-specific functionality',\n                    'Ensure consistent layout and styling'\n                ]\n            },\n            {\n                phase: 'Quality Assurance',\n                duration: '30-45 minutes',\n                tasks: [\n                    'Cross-browser testing (Chrome, Firefox, Safari)',\n                    'Responsive testing across device sizes',\n                    'Accessibility audit and WCAG compliance',\n                    'Performance optimization and Lighthouse scoring',\n                    'Code review and refactoring'\n                ]\n            }\n        ],\n        bestPractices: [\n            'Use semantic HTML5 elements for better accessibility',\n            'Implement mobile-first responsive design',\n            'Optimize images and use modern formats (WebP, AVIF)',\n            'Minimize JavaScript bundle size and use code splitting',\n            'Follow component composition patterns for reusability',\n            'Use CSS custom properties for consistent theming',\n            'Implement proper error boundaries and loading states',\n            'Add proper meta tags for SEO optimization'\n        ],\n        qualityChecks: [\n            'Visual comparison with original screenshots',\n            'Lighthouse performance score > 90',\n            'Accessibility score > 95',\n            'Cross-browser compatibility verified',\n            'Mobile responsiveness tested',\n            'Code quality and maintainability reviewed'\n        ]\n    };\n}\n/**\n * Generate Claude Sonnet-optimized AI prompt as Markdown\n * @param siteMapData - Processed site map data\n * @param contentData - Processed content data for each page\n * @param performanceData - Processed performance metrics\n * @param structuredData - Extracted structured data about the website\n * @returns Claude Sonnet-optimized Markdown content\n */ function generatePromptMarkdown(siteMapData, contentData, performanceData, structuredData) {\n    const siteOverview = generateSiteOverview(siteMapData, structuredData);\n    const pageDetails = generatePageDetails(contentData);\n    const components = identifyComponents(contentData);\n    const assets = extractAssetReferences(contentData);\n    const performance = generatePerformanceGuidelines(performanceData);\n    const instructions = generateClaudeSonnetInstructions(siteMapData, structuredData, components, assets);\n    const pageCount = siteMapData.pages?.length || 0;\n    const technologies = structuredData?.technologies || [];\n    const designPatterns = structuredData?.designPatterns || [];\n    const primaryUrl = siteMapData.pages?.[0] || Object.keys(contentData)[0] || 'Target Website';\n    return `# 🎯 CLAUDE SONNET WEBSITE RECONSTRUCTION PROMPT\n\n## 🚀 MISSION CONTEXT\nYou are Claude Sonnet, an elite AI developer with access to a comprehensive website analysis package. Your task is to rebuild the website **${primaryUrl}** with pixel-perfect accuracy using modern web development practices.\n\n## 📦 PACKAGE CONTENTS\nThis analysis package contains:\n- **${pageCount} pages** with full-page screenshots and extracted code\n- **${Object.values(components).reduce((sum, items)=>sum + items.length, 0)} identified components** across ${Object.keys(components).length} categories\n- **${Object.values(assets).reduce((sum, items)=>sum + items.length, 0)} assets** categorized and ready for download\n- **Performance benchmarks** from Lighthouse analysis\n- **Technical specifications** and component documentation\n\n## 🎨 VISUAL ANALYSIS WORKFLOW\n\n### Step 1: Screenshot Review Protocol\n1. **Open screenshots/ folder** - These are full-page captures showing exact visual targets\n2. **Analyze layout patterns** - Identify grid systems, spacing, typography hierarchy\n3. **Note responsive breakpoints** - Look for mobile/tablet/desktop variations\n4. **Catalog interactive elements** - Buttons, forms, navigation, animations\n5. **Document color palette** - Extract exact colors from visual elements\n\n### Step 2: Code Structure Analysis\n1. **Review pages/ folder** - Contains extracted HTML/CSS for each page\n2. **Identify semantic structure** - Headers, main content, sidebars, footers\n3. **Extract CSS patterns** - Classes, IDs, styling approaches\n4. **Note JavaScript functionality** - Interactive elements and behaviors\n\n## 🏗️ CLAUDE SONNET RECONSTRUCTION STRATEGY\n\n### Phase 1: Foundation Setup\n\\`\\`\\`bash\n# Create project structure optimized for modern development\nmkdir website-rebuild && cd website-rebuild\nnpm init -y\nnpm install -D tailwindcss postcss autoprefixer vite\n# OR use your preferred framework (Next.js, Nuxt, SvelteKit)\n\\`\\`\\`\n\n### Phase 2: Component-First Development\nBased on the analysis, implement these components in order:\n\n${Object.entries(components).map(([type, items])=>`\n#### ${type.charAt(0).toUpperCase() + type.slice(1)} Components (${items.length} identified)\n- **Priority**: ${type === 'header' || type === 'navigation' ? 'HIGH' : type === 'footer' ? 'MEDIUM' : 'LOW'}\n- **Implementation**: Create reusable ${type} component(s)\n- **Files**: Check docs/components.md for detailed analysis\n`).join('')}\n\n### Phase 3: Page Assembly\nReconstruct pages in this order:\n1. **Homepage** (primary entry point)\n2. **Navigation pages** (main menu items)\n3. **Content pages** (secondary pages)\n4. **Utility pages** (404, contact, etc.)\n\n## 🎯 CLAUDE SONNET SPECIFIC INSTRUCTIONS\n\n### Code Quality Standards\n- **Use semantic HTML5** - Proper heading hierarchy, landmarks, ARIA labels\n- **Implement responsive design** - Mobile-first approach with progressive enhancement\n- **Optimize performance** - Meet or exceed original Lighthouse scores\n- **Follow accessibility guidelines** - WCAG 2.1 AA compliance\n- **Use modern CSS** - Flexbox, Grid, custom properties, logical properties\n\n### Technology Recommendations\nBased on analysis, the original site uses: **${technologies.join(', ') || 'Standard HTML/CSS/JS'}**\n\n**Recommended modern stack:**\n- **Framework**: ${technologies.some((t)=>/react|next/i.test(t)) ? 'Next.js' : technologies.some((t)=>/vue|nuxt/i.test(t)) ? 'Nuxt.js' : 'Vite + vanilla JS'}\n- **Styling**: ${technologies.some((t)=>/tailwind/i.test(t)) ? 'Tailwind CSS' : 'CSS Modules or Styled Components'}\n- **Build tool**: Vite for optimal development experience\n\n### Performance Targets\n${performance.recommendations.length > 0 ? performance.recommendations.map((rec)=>`- ${rec}`).join('\\n') : '- Achieve 90+ Lighthouse scores across all metrics'}\n\n## 📋 IMPLEMENTATION CHECKLIST\n\n### ✅ Visual Fidelity\n- [ ] Layout matches screenshots exactly\n- [ ] Typography hierarchy preserved\n- [ ] Color palette accurate\n- [ ] Spacing and proportions correct\n- [ ] Interactive states implemented\n\n### ✅ Technical Excellence\n- [ ] Semantic HTML structure\n- [ ] Responsive design working\n- [ ] Performance optimized\n- [ ] Accessibility compliant\n- [ ] Cross-browser compatible\n\n### ✅ Functionality\n- [ ] Navigation working\n- [ ] Forms functional\n- [ ] Interactive elements responsive\n- [ ] Loading states implemented\n- [ ] Error handling in place\n\n## 🔧 DEBUGGING RESOURCES\n\n### File References\n- **Visual targets**: \\`screenshots/\\` folder\n- **Code examples**: \\`pages/\\` folder\n- **Component analysis**: \\`docs/components.md\\`\n- **Performance data**: \\`docs/performance.md\\`\n- **Asset inventory**: \\`assets/manifest.json\\`\n\n### Common Issues & Solutions\n1. **Missing assets**: Use \\`assets/download-assets.sh\\` script\n2. **Layout differences**: Compare with screenshots pixel by pixel\n3. **Performance issues**: Reference original Lighthouse scores\n4. **Responsive problems**: Test across all device sizes\n\n## 🎨 DESIGN SYSTEM EXTRACTION\n\n### Colors Identified\n${structuredData?.colorPalette?.map((color)=>`- \\`${color}\\``).join('\\n') || '- Extract from screenshots'}\n\n### Typography\n${structuredData?.fontFamilies?.map((font)=>`- ${font}`).join('\\n') || '- Analyze from page HTML'}\n\n### Design Patterns\n${designPatterns.map((pattern)=>`- ${pattern}`).join('\\n') || '- Standard web patterns identified'}\n\n## 🚀 DEPLOYMENT READINESS\n\nWhen reconstruction is complete:\n1. **Test thoroughly** across devices and browsers\n2. **Validate HTML/CSS** using W3C validators\n3. **Run Lighthouse audit** to verify performance\n4. **Deploy to staging** for final review\n5. **Go live** with confidence\n\n---\n\n**Generated**: ${new Date().toISOString()}\n**Package Version**: 2.0.0 (Claude Sonnet Optimized)\n**Analysis ID**: ${Math.random().toString(36).substr(2, 9)}\n\n> 💡 **Claude Sonnet Tip**: Start with the homepage screenshot and work systematically through each component. Your attention to detail and modern development practices will ensure a superior rebuild.\n`;\n}\n/**\n * Save individual page HTML files\n * @param folder - JSZip folder for pages\n * @param contentData - Processed content data for each page\n */ async function savePageFiles(folder, contentData) {\n    for (const [url, data] of Object.entries(contentData)){\n        try {\n            const pageData = data;\n            const html = pageData.html || '';\n            const markdown = pageData.markdown || '';\n            // Generate a clean filename from the URL\n            const urlObj = new URL(url);\n            const path = urlObj.pathname;\n            let filename = path === '/' ? 'homepage' : path.split('/').filter(Boolean).join('-');\n            if (!filename) filename = 'homepage';\n            // Save HTML file\n            folder.file(`${filename}.html`, html);\n            // Save Markdown file\n            folder.file(`${filename}.md`, markdown);\n            // Save metadata\n            const metadata = {\n                url,\n                title: pageData.metadata?.title || filename,\n                extractedAt: new Date().toISOString(),\n                assets: pageData.assets || [],\n                links: pageData.links || []\n            };\n            folder.file(`${filename}.json`, JSON.stringify(metadata, null, 2));\n        } catch (error) {\n            console.warn(`Error saving page file for: ${url}`, error);\n        }\n    }\n}\n/**\n * Save extracted CSS files\n * @param folder - JSZip folder for CSS files\n * @param contentData - Processed content data for each page\n */ async function saveCSSFiles(folder, contentData) {\n    let cssFileCount = 0;\n    for (const [url, data] of Object.entries(contentData)){\n        try {\n            const pageData = data;\n            const cssContents = pageData.cssContents || {};\n            // Save each CSS file with content\n            for (const [cssUrl, cssContent] of Object.entries(cssContents)){\n                if (cssContent && cssContent.trim()) {\n                    // Generate a clean filename from the CSS URL\n                    const urlObj = new URL(cssUrl, url);\n                    const pathname = urlObj.pathname;\n                    let filename = pathname.split('/').pop() || 'style.css';\n                    // Ensure .css extension\n                    if (!filename.endsWith('.css')) {\n                        filename += '.css';\n                    }\n                    // Avoid filename conflicts\n                    let finalFilename = filename;\n                    let counter = 1;\n                    while(folder.file(finalFilename)){\n                        const baseName = filename.replace('.css', '');\n                        finalFilename = `${baseName}-${counter}.css`;\n                        counter++;\n                    }\n                    // Save CSS file with content\n                    folder.file(finalFilename, cssContent);\n                    cssFileCount++;\n                    console.log(`✅ Saved CSS file: ${finalFilename} (${cssContent.length} chars)`);\n                }\n            }\n        } catch (error) {\n            console.warn(`Error saving CSS files for: ${url}`, error);\n        }\n    }\n    // Create a README if no CSS files were saved\n    if (cssFileCount === 0) {\n        folder.file('README.txt', `No CSS files were extracted during the scan.\n\nThis could be due to:\n1. Website uses inline styles only\n2. CSS files are loaded dynamically via JavaScript\n3. CSS URLs are relative and couldn't be resolved\n4. Network issues during CSS content fetching\n5. CSS files are protected or require authentication\n\nTo get CSS files:\n- Check the original website's developer tools\n- Look for CSS links in the HTML files in pages/ folder\n- Use the asset manifest to download CSS files manually\n`);\n    }\n    console.log(`💾 Saved ${cssFileCount} CSS files`);\n}\n/**\n * Save screenshots from the scraped data\n * @param folder - JSZip folder for screenshots\n * @param contentData - Processed content data for each page\n */ async function saveScreenshots(folder, contentData) {\n    let screenshotCount = 0;\n    for (const [url, data] of Object.entries(contentData)){\n        try {\n            const pageData = data;\n            // Debug: Log the structure of pageData to understand what Firecrawl returns\n            console.log(`Screenshot debug for ${url}:`, Object.keys(pageData));\n            // Check multiple possible locations for screenshot data\n            const screenshotData = pageData.screenshot || pageData.screenshotUrl || pageData.image || pageData.rawData?.screenshot;\n            if (screenshotData) {\n                // Generate a clean filename from the URL\n                const urlObj = new URL(url);\n                const path = urlObj.pathname;\n                let filename = path === '/' ? 'homepage' : path.split('/').filter(Boolean).join('-');\n                if (!filename) filename = 'homepage';\n                // Handle different screenshot data formats\n                if (typeof screenshotData === 'string') {\n                    // If it's a base64 string\n                    if (screenshotData.startsWith('data:image/')) {\n                        const base64Data = screenshotData.split(',')[1];\n                        folder.file(`${filename}.png`, base64Data, {\n                            base64: true\n                        });\n                        screenshotCount++;\n                        console.log(`Saved screenshot for ${url} as ${filename}.png`);\n                    } else if (screenshotData.startsWith('http')) {\n                        // If it's a URL, download the image and save it\n                        try {\n                            console.log(`Downloading screenshot from URL: ${screenshotData}`);\n                            const response = await fetch(screenshotData);\n                            if (response.ok) {\n                                const imageBuffer = await response.arrayBuffer();\n                                folder.file(`${filename}.png`, imageBuffer);\n                                screenshotCount++;\n                                console.log(`Downloaded and saved screenshot for ${url} as ${filename}.png`);\n                            } else {\n                                console.warn(`Failed to download screenshot from ${screenshotData}: ${response.status}`);\n                                folder.file(`${filename}-screenshot-url.txt`, screenshotData);\n                            }\n                        } catch (error) {\n                            console.warn(`Error downloading screenshot from ${screenshotData}:`, error);\n                            folder.file(`${filename}-screenshot-url.txt`, screenshotData);\n                        }\n                    } else {\n                        // Try to save as base64 anyway\n                        folder.file(`${filename}.png`, screenshotData, {\n                            base64: true\n                        });\n                        screenshotCount++;\n                        console.log(`Saved screenshot (assumed base64) for ${url} as ${filename}.png`);\n                    }\n                }\n            } else {\n                console.warn(`No screenshot data found for: ${url}`);\n                // Create a placeholder file to indicate missing screenshot\n                folder.file(`${url.replace(/[^a-zA-Z0-9]/g, '_')}-no-screenshot.txt`, `Screenshot not available for ${url}\\nThis may be due to:\\n- Firecrawl API limitations\\n- Website blocking screenshots\\n- Configuration issues`);\n            }\n        } catch (error) {\n            console.warn(`Error saving screenshot for: ${url}`, error);\n        }\n    }\n    console.log(`Total screenshots saved: ${screenshotCount}`);\n    // If no screenshots were saved, add a README explaining why\n    if (screenshotCount === 0) {\n        folder.file('README.txt', `No screenshots were captured during the scan.\n\nThis could be due to:\n1. Firecrawl API configuration issues\n2. Website blocking screenshot capture\n3. API rate limits or timeouts\n4. Missing screenshot format in API request\n\nTo enable screenshots:\n- Verify FIRECRAWL_API_KEY is set correctly\n- Check Firecrawl account limits\n- Ensure target website allows screenshot capture`);\n    }\n}\n/**\n * Save downloaded assets\n * @param folder - JSZip folder for assets\n * @param contentData - Processed content data for each page\n */ async function saveAssets(folder, contentData) {\n    const allAssets = new Set();\n    // Collect all unique assets from all pages\n    Object.values(contentData).forEach((data)=>{\n        const pageData = data;\n        const assets = pageData.assets || [];\n        assets.forEach((asset)=>{\n            const assetUrl = asset.url;\n            if (assetUrl) {\n                allAssets.add(assetUrl);\n            }\n        });\n    });\n    // Create asset manifest\n    const assetManifest = {\n        totalAssets: allAssets.size,\n        assetTypes: {},\n        downloadInstructions: 'Assets listed below should be downloaded from their original URLs',\n        generatedAt: new Date().toISOString()\n    };\n    // Categorize assets by type\n    allAssets.forEach((assetUrl)=>{\n        try {\n            // Handle relative URLs by creating a proper URL\n            let url;\n            if (assetUrl.startsWith('http://') || assetUrl.startsWith('https://')) {\n                url = new URL(assetUrl);\n            } else if (assetUrl.startsWith('//')) {\n                url = new URL('https:' + assetUrl);\n            } else {\n                // For relative URLs, use the first page URL as base\n                const baseUrl = Object.keys(contentData)[0] || 'https://example.com';\n                url = new URL(assetUrl, baseUrl);\n            }\n            const pathname = url.pathname.toLowerCase();\n            let category = 'other';\n            if (pathname.match(/\\.(jpg|jpeg|png|gif|svg|webp)$/)) {\n                category = 'images';\n            } else if (pathname.match(/\\.(css)$/)) {\n                category = 'css';\n            } else if (pathname.match(/\\.(js)$/)) {\n                category = 'javascript';\n            } else if (pathname.match(/\\.(woff|woff2|ttf|otf|eot)$/)) {\n                category = 'fonts';\n            } else if (pathname.match(/\\.(mp4|webm|ogg|avi)$/)) {\n                category = 'videos';\n            }\n            if (!assetManifest.assetTypes[category]) {\n                assetManifest.assetTypes[category] = [];\n            }\n            assetManifest.assetTypes[category].push(assetUrl);\n        } catch (error) {\n            console.warn(`Error categorizing asset: ${assetUrl}`, error);\n        }\n    });\n    // Save asset manifest\n    folder.file('manifest.json', JSON.stringify(assetManifest, null, 2));\n    // Create download script\n    const downloadScript = `#!/bin/bash\n# Asset Download Script\n# Run this script to download all assets from the original website\n\nmkdir -p images css javascript fonts videos other\n\n${Object.entries(assetManifest.assetTypes).map(([category, urls])=>urls.map((url)=>{\n            const filename = url.split('/').pop() || 'unknown';\n            return `curl -o \"${category}/${filename}\" \"${url}\"`;\n        }).join('\\n')).join('\\n')}\n\necho \"Asset download complete!\"\n`;\n    folder.file('download-assets.sh', downloadScript);\n    // Create Windows batch file version\n    const windowsScript = downloadScript.replace('#!/bin/bash', '@echo off');\n    folder.file('download-assets.bat', windowsScript);\n}\n/**\n * Generate technical documentation files\n * @param folder - JSZip folder for documentation\n * @param siteMapData - Processed site map data\n * @param contentData - Processed content data for each page\n * @param performanceData - Processed performance metrics\n * @param structuredData - Extracted structured data about the website\n */ async function generateTechnicalDocs(folder, siteMapData, contentData, performanceData, structuredData) {\n    // Generate component analysis\n    const components = identifyComponents(contentData);\n    const componentsMd = `# Component Analysis\n\nThis document provides a detailed analysis of the components identified across the website.\n\n${Object.entries(components).map(([type, items])=>`\n## ${type.charAt(0).toUpperCase() + type.slice(1)} Components\n\nFound ${items.length} unique ${type} components:\n\n${items.map((item, index)=>`\n### ${type.charAt(0).toUpperCase() + type.slice(1)} ${index + 1}\n- **Source**: ${item.source}\n- **Content Preview**: ${cleanComponentContent(item.content)}\n\n`).join('')}\n`).join('')}\n`;\n    folder.file('components.md', componentsMd);\n    // Generate performance analysis\n    const performance = generatePerformanceGuidelines(performanceData);\n    const performanceMd = `# Performance Analysis\n\n${performance.description}\n\n## Scores\n${Object.entries(performance.scores || {}).map(([metric, score])=>`- **${metric.charAt(0).toUpperCase() + metric.slice(1)}**: ${Math.round(score * 100)}%`).join('\\n')}\n\n## Key Metrics\n${Object.entries(performance.metrics || {}).map(([metric, data])=>`- **${metric}**: ${JSON.stringify(data)}`).join('\\n')}\n\n## Recommendations\n${performance.recommendations.map((rec)=>`- ${rec}`).join('\\n')}\n`;\n    folder.file('performance.md', performanceMd);\n    // Generate technical specifications\n    const techSpecsMd = `# Technical Specifications\n\n## Site Structure\n- **Total Pages**: ${siteMapData.pages?.length || 0}\n- **Technologies**: ${structuredData?.technologies?.join(', ') || 'Standard HTML/CSS/JS'}\n- **Design Patterns**: ${structuredData?.designPatterns?.join(', ') || 'Standard web patterns'}\n\n## Page Hierarchy\n${JSON.stringify(generatePageHierarchy(siteMapData), null, 2)}\n\n## Asset Summary\n${Object.entries(extractAssetReferences(contentData)).map(([type, items])=>`- **${type.charAt(0).toUpperCase() + type.slice(1)}**: ${items.length} files`).join('\\n')}\n\n## Color Palette\n${structuredData?.colorPalette?.map((color)=>`- ${color}`).join('\\n') || 'Not specified'}\n\n## Font Families\n${structuredData?.fontFamilies?.map((font)=>`- ${font}`).join('\\n') || 'Not specified'}\n\n## Key Features\n${structuredData?.keyFeatures?.map((feature)=>`- ${feature}`).join('\\n') || 'Not specified'}\n`;\n    folder.file('technical-specs.md', techSpecsMd);\n}\n/**\n * Generate package manifest\n * @param siteMapData - Processed site map data\n * @param contentData - Processed content data for each page\n * @param performanceData - Processed performance metrics\n * @param structuredData - Extracted structured data about the website\n * @param analysisId - Unique ID for this analysis\n * @returns Package manifest object\n */ function generatePackageManifest(siteMapData, contentData, performanceData, structuredData, analysisId) {\n    return {\n        name: 'website-rebuild-package',\n        version: '1.0.0',\n        description: 'Comprehensive website rebuild package generated by WRPG',\n        analysisId,\n        generatedAt: new Date().toISOString(),\n        source: {\n            pages: siteMapData.pages || [],\n            totalPages: siteMapData.pages?.length || 0\n        },\n        technologies: structuredData?.technologies || [],\n        designPatterns: structuredData?.designPatterns || [],\n        colorPalette: structuredData?.colorPalette || [],\n        fontFamilies: structuredData?.fontFamilies || [],\n        keyFeatures: structuredData?.keyFeatures || [],\n        performance: {\n            scores: performanceData?.performance?.score ? {\n                performance: performanceData.performance.score,\n                accessibility: performanceData.accessibility?.score,\n                seo: performanceData.seo?.score,\n                bestPractices: performanceData.bestPractices?.score\n            } : null\n        },\n        assets: extractAssetReferences(contentData),\n        components: Object.fromEntries(Object.entries(identifyComponents(contentData)).map(([type, items])=>[\n                type,\n                items.length\n            ])),\n        files: {\n            'README.md': 'Main AI prompt and instructions',\n            'package.json': 'Package manifest and metadata',\n            'pages/': 'Individual page HTML and Markdown files',\n            'screenshots/': 'Full-page screenshots of all pages',\n            'assets/': 'Asset manifest and download scripts',\n            'docs/': 'Technical documentation and analysis'\n        },\n        usage: {\n            quickStart: [\n                'Review screenshots/ folder for visual design',\n                'Examine pages/ folder for HTML structure',\n                'Check assets/ folder for resources',\n                'Follow README.md reconstruction instructions'\n            ],\n            aiInstructions: 'Use this package with Claude Sonnet or similar AI for website reconstruction'\n        }\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QTRCLGFBQWEsSUFBSXpCLE9BQU9DLFdBQVc7UUFDbkN1SSxRQUFRO1lBQ045RixPQUFPLFlBQWFBLEtBQUssSUFBaUIsRUFBRTtZQUM1Q2dPLFlBQVksWUFBYWhPLEtBQUssRUFBZ0JDLFVBQVU7UUFDMUQ7UUFDQUMsY0FBYyxnQkFBaUJBLGdCQUE2QixFQUFFO1FBQzlEQyxnQkFBZ0IsZ0JBQWlCQSxrQkFBK0IsRUFBRTtRQUNsRUMsY0FBYyxnQkFBaUJBLGdCQUE2QixFQUFFO1FBQzlEQyxjQUFjLGdCQUFpQkEsZ0JBQTZCLEVBQUU7UUFDOURNLGFBQWEsZ0JBQWlCQSxlQUE0QixFQUFFO1FBQzVEcUgsYUFBYTtZQUNYZSxRQUFRLGlCQUEwQmYsYUFBYUssUUFBUTtnQkFDckRMLGFBQWEsZ0JBQXlCQSxXQUFXLENBQUNLLEtBQUs7Z0JBQ3ZESixlQUFlLGdCQUF5QkEsYUFBYSxFQUFFSTtnQkFDdkRILEtBQUssZ0JBQXlCQSxHQUFHLEVBQUVHO2dCQUNuQ0YsZUFBZSxnQkFBeUJBLGFBQWEsRUFBRUU7WUFDekQsSUFBSTtRQUNOO1FBQ0E1SSxRQUFRQyx1QkFBdUIxQztRQUMvQnVDLFlBQVlxQyxPQUFPcU0sV0FBVyxDQUM1QnJNLE9BQU9DLE9BQU8sQ0FBQ3JDLG1CQUFtQnhDLGNBQWN1TixHQUFHLENBQUMsQ0FBQyxDQUFDOUQsTUFBTUMsTUFBTSxHQUFLO2dCQUNyRUQ7Z0JBQ0NDLE1BQW9CekcsTUFBTTthQUM1QjtRQUVIaU8sT0FBTztZQUNMLGFBQWE7WUFDYixnQkFBZ0I7WUFDaEIsVUFBVTtZQUNWLGdCQUFnQjtZQUNoQixXQUFXO1lBQ1gsU0FBUztRQUNYO1FBQ0FDLE9BQU87WUFDTEMsWUFBWTtnQkFDVjtnQkFDQTtnQkFDQTtnQkFDQTthQUNEO1lBQ0RDLGdCQUFnQjtRQUNsQjtJQUNGO0FBQ0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9kZWFubmV3dG9uL0RvY3VtZW50cy94cmF5L2xpYi9nZW5lcmF0ZS1kb2NzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogRG9jdW1lbnRhdGlvbiBnZW5lcmF0aW9uIHV0aWxpdGllcyBmb3IgdGhlIFdlYnNpdGUgUmVidWlsZCBQcm9tcHQgR2VuZXJhdG9yXG4gKiBUcmFuc2Zvcm1zIHNjcmFwZWQgd2Vic2l0ZSBkYXRhIGludG8gQ2xhdWRlIFNvbm5ldC1vcHRpbWl6ZWQgcHJvbXB0cyBhbmQgY29tcHJlaGVuc2l2ZSBwYWNrYWdlc1xuICovXG5cbmltcG9ydCBKU1ppcCBmcm9tICdqc3ppcCc7XG5cbi8qKlxuICogR2VuZXJhdGUgYSBjb21wcmVoZW5zaXZlIHdlYnNpdGUgcmVidWlsZCBwYWNrYWdlXG4gKiBAcGFyYW0gc2l0ZU1hcERhdGEgLSBQcm9jZXNzZWQgc2l0ZSBtYXAgZGF0YVxuICogQHBhcmFtIGNvbnRlbnREYXRhIC0gUHJvY2Vzc2VkIGNvbnRlbnQgZGF0YSBmb3IgZWFjaCBwYWdlXG4gKiBAcGFyYW0gcGVyZm9ybWFuY2VEYXRhIC0gUHJvY2Vzc2VkIHBlcmZvcm1hbmNlIG1ldHJpY3NcbiAqIEBwYXJhbSBzdHJ1Y3R1cmVkRGF0YSAtIEV4dHJhY3RlZCBzdHJ1Y3R1cmVkIGRhdGEgYWJvdXQgdGhlIHdlYnNpdGVcbiAqIEBwYXJhbSBhbmFseXNpc0lkIC0gVW5pcXVlIElEIGZvciB0aGlzIGFuYWx5c2lzXG4gKiBAcmV0dXJucyBBIGNvbXByZWhlbnNpdmUgcGFja2FnZSB3aXRoIG11bHRpcGxlIGZpbGVzIGFuZCBmb2xkZXJzXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZW5lcmF0ZVdlYnNpdGVSZWJ1aWxkUGFja2FnZShcbiAgc2l0ZU1hcERhdGE6IFJlY29yZDxzdHJpbmcsIHVua25vd24+LFxuICBjb250ZW50RGF0YTogUmVjb3JkPHN0cmluZywgdW5rbm93bj4sXG4gIHBlcmZvcm1hbmNlRGF0YTogUmVjb3JkPHN0cmluZywgdW5rbm93bj4sXG4gIHN0cnVjdHVyZWREYXRhOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPixcbiAgYW5hbHlzaXNJZDogc3RyaW5nXG4pIHtcbiAgY29uc3QgemlwID0gbmV3IEpTWmlwKCk7XG4gIGNvbnN0IHRpbWVzdGFtcCA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKS5yZXBsYWNlKC9bOi5dL2csICctJyk7XG4gIGNvbnN0IHBhY2thZ2VOYW1lID0gYHdlYnNpdGUtcmVidWlsZC0ke3RpbWVzdGFtcH1gO1xuXG4gIC8vIDEuIEdlbmVyYXRlIHRoZSBtYWluIEFJIHByb21wdCAoTWFya2Rvd24pXG4gIGNvbnN0IHByb21wdE1hcmtkb3duID0gZ2VuZXJhdGVQcm9tcHRNYXJrZG93bihzaXRlTWFwRGF0YSwgY29udGVudERhdGEsIHBlcmZvcm1hbmNlRGF0YSwgc3RydWN0dXJlZERhdGEpO1xuICB6aXAuZmlsZShgJHtwYWNrYWdlTmFtZX0vUkVBRE1FLm1kYCwgcHJvbXB0TWFya2Rvd24pO1xuXG4gIC8vIDIuIFNhdmUgaW5kaXZpZHVhbCBwYWdlIEhUTUwgZmlsZXNcbiAgY29uc3QgcGFnZXNGb2xkZXIgPSB6aXAuZm9sZGVyKGAke3BhY2thZ2VOYW1lfS9wYWdlc2ApO1xuICBhd2FpdCBzYXZlUGFnZUZpbGVzKHBhZ2VzRm9sZGVyISwgY29udGVudERhdGEpO1xuXG4gIC8vIDMuIFNhdmUgc2NyZWVuc2hvdHNcbiAgY29uc3Qgc2NyZWVuc2hvdHNGb2xkZXIgPSB6aXAuZm9sZGVyKGAke3BhY2thZ2VOYW1lfS9zY3JlZW5zaG90c2ApO1xuICBhd2FpdCBzYXZlU2NyZWVuc2hvdHMoc2NyZWVuc2hvdHNGb2xkZXIhLCBjb250ZW50RGF0YSk7XG5cbiAgLy8gNC4gU2F2ZSBkb3dubG9hZGVkIGFzc2V0c1xuICBjb25zdCBhc3NldHNGb2xkZXIgPSB6aXAuZm9sZGVyKGAke3BhY2thZ2VOYW1lfS9hc3NldHNgKTtcbiAgYXdhaXQgc2F2ZUFzc2V0cyhhc3NldHNGb2xkZXIhLCBjb250ZW50RGF0YSk7XG5cbiAgLy8gNC41LiBTYXZlIGV4dHJhY3RlZCBDU1MgZmlsZXNcbiAgY29uc3QgY3NzRm9sZGVyID0gYXNzZXRzRm9sZGVyIS5mb2xkZXIoJ2NzcycpO1xuICBhd2FpdCBzYXZlQ1NTRmlsZXMoY3NzRm9sZGVyISwgY29udGVudERhdGEpO1xuXG4gIC8vIDUuIEdlbmVyYXRlIHRlY2huaWNhbCBkb2N1bWVudGF0aW9uXG4gIGNvbnN0IGRvY3NGb2xkZXIgPSB6aXAuZm9sZGVyKGAke3BhY2thZ2VOYW1lfS9kb2NzYCk7XG4gIGF3YWl0IGdlbmVyYXRlVGVjaG5pY2FsRG9jcyhkb2NzRm9sZGVyISwgc2l0ZU1hcERhdGEsIGNvbnRlbnREYXRhLCBwZXJmb3JtYW5jZURhdGEsIHN0cnVjdHVyZWREYXRhKTtcblxuICAvLyA2LiBDcmVhdGUgcGFja2FnZSBtYW5pZmVzdFxuICBjb25zdCBtYW5pZmVzdCA9IGdlbmVyYXRlUGFja2FnZU1hbmlmZXN0KHNpdGVNYXBEYXRhLCBjb250ZW50RGF0YSwgcGVyZm9ybWFuY2VEYXRhLCBzdHJ1Y3R1cmVkRGF0YSwgYW5hbHlzaXNJZCk7XG4gIHppcC5maWxlKGAke3BhY2thZ2VOYW1lfS9wYWNrYWdlLmpzb25gLCBKU09OLnN0cmluZ2lmeShtYW5pZmVzdCwgbnVsbCwgMikpO1xuXG4gIHJldHVybiB7XG4gICAgemlwLFxuICAgIHBhY2thZ2VOYW1lLFxuICAgIG1hbmlmZXN0XG4gIH07XG59XG5cbi8qKlxuICogTGVnYWN5IGZ1bmN0aW9uIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG4gKiBAcGFyYW0gc2l0ZU1hcERhdGEgLSBQcm9jZXNzZWQgc2l0ZSBtYXAgZGF0YVxuICogQHBhcmFtIGNvbnRlbnREYXRhIC0gUHJvY2Vzc2VkIGNvbnRlbnQgZGF0YSBmb3IgZWFjaCBwYWdlXG4gKiBAcGFyYW0gcGVyZm9ybWFuY2VEYXRhIC0gUHJvY2Vzc2VkIHBlcmZvcm1hbmNlIG1ldHJpY3NcbiAqIEBwYXJhbSBzdHJ1Y3R1cmVkRGF0YSAtIEV4dHJhY3RlZCBzdHJ1Y3R1cmVkIGRhdGEgYWJvdXQgdGhlIHdlYnNpdGVcbiAqIEByZXR1cm5zIEEgc3RydWN0dXJlZCBwcm9tcHQgb2JqZWN0IG9wdGltaXplZCBmb3IgQ2xhdWRlIFNvbm5ldFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVTb25uZXRQcm9tcHQoXG4gIHNpdGVNYXBEYXRhOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPixcbiAgY29udGVudERhdGE6IFJlY29yZDxzdHJpbmcsIHVua25vd24+LFxuICBwZXJmb3JtYW5jZURhdGE6IFJlY29yZDxzdHJpbmcsIHVua25vd24+LFxuICBzdHJ1Y3R1cmVkRGF0YTogUmVjb3JkPHN0cmluZywgdW5rbm93bj5cbikge1xuICAvLyBDcmVhdGUgdGhlIGJhc2UgcHJvbXB0IHN0cnVjdHVyZVxuICBjb25zdCBwcm9tcHQgPSB7XG4gICAgbWV0YWRhdGE6IHtcbiAgICAgIGdlbmVyYXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICB2ZXJzaW9uOiAnMS4wLjAnLFxuICAgICAgZ2VuZXJhdGVkRm9yOiAnQ2xhdWRlIFNvbm5ldCBBSSBJREUnLFxuICAgICAgcHJvbXB0VHlwZTogJ3dlYnNpdGUtcmVjb25zdHJ1Y3Rpb24nXG4gICAgfSxcbiAgICBzaXRlT3ZlcnZpZXc6IGdlbmVyYXRlU2l0ZU92ZXJ2aWV3KHNpdGVNYXBEYXRhLCBzdHJ1Y3R1cmVkRGF0YSksXG4gICAgcGFnZURldGFpbHM6IGdlbmVyYXRlUGFnZURldGFpbHMoY29udGVudERhdGEpLFxuICAgIGNvbXBvbmVudHM6IGlkZW50aWZ5Q29tcG9uZW50cyhjb250ZW50RGF0YSksXG4gICAgYXNzZXRzOiBleHRyYWN0QXNzZXRSZWZlcmVuY2VzKGNvbnRlbnREYXRhKSxcbiAgICBwZXJmb3JtYW5jZUNvbnNpZGVyYXRpb25zOiBnZW5lcmF0ZVBlcmZvcm1hbmNlR3VpZGVsaW5lcyhwZXJmb3JtYW5jZURhdGEpLFxuICAgIHJlY29uc3RydWN0aW9uSW5zdHJ1Y3Rpb25zOiBnZW5lcmF0ZVJlY29uc3RydWN0aW9uSW5zdHJ1Y3Rpb25zKHNpdGVNYXBEYXRhLCBzdHJ1Y3R1cmVkRGF0YSlcbiAgfTtcblxuICByZXR1cm4gcHJvbXB0O1xufVxuXG4vKipcbiAqIEdlbmVyYXRlIGEgY29tcHJlaGVuc2l2ZSBzaXRlIG92ZXJ2aWV3IHNlY3Rpb25cbiAqIEBwYXJhbSBzaXRlTWFwRGF0YSAtIFByb2Nlc3NlZCBzaXRlIG1hcCBkYXRhXG4gKiBAcGFyYW0gc3RydWN0dXJlZERhdGEgLSBFeHRyYWN0ZWQgc3RydWN0dXJlZCBkYXRhIGFib3V0IHRoZSB3ZWJzaXRlXG4gKiBAcmV0dXJucyBTaXRlIG92ZXJ2aWV3IHNlY3Rpb25cbiAqL1xuZnVuY3Rpb24gZ2VuZXJhdGVTaXRlT3ZlcnZpZXcoc2l0ZU1hcERhdGE6IFJlY29yZDxzdHJpbmcsIHVua25vd24+LCBzdHJ1Y3R1cmVkRGF0YTogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pIHtcbiAgY29uc3QgcGFnZUNvdW50ID0gKHNpdGVNYXBEYXRhLnBhZ2VzIGFzIHVua25vd25bXSk/Lmxlbmd0aCB8fCAwO1xuICBjb25zdCB0ZWNobm9sb2dpZXMgPSAoc3RydWN0dXJlZERhdGE/LnRlY2hub2xvZ2llcyBhcyBzdHJpbmdbXSkgfHwgW107XG4gIGNvbnN0IGRlc2lnblBhdHRlcm5zID0gKHN0cnVjdHVyZWREYXRhPy5kZXNpZ25QYXR0ZXJucyBhcyBzdHJpbmdbXSkgfHwgW107XG4gIGNvbnN0IGNvbG9yUGFsZXR0ZSA9IChzdHJ1Y3R1cmVkRGF0YT8uY29sb3JQYWxldHRlIGFzIHN0cmluZ1tdKSB8fCBbXTtcbiAgY29uc3QgZm9udEZhbWlsaWVzID0gKHN0cnVjdHVyZWREYXRhPy5mb250RmFtaWxpZXMgYXMgc3RyaW5nW10pIHx8IFtdO1xuXG4gIHJldHVybiB7XG4gICAgdGl0bGU6ICdTaXRlIE92ZXJ2aWV3JyxcbiAgICBkZXNjcmlwdGlvbjogYFRoaXMgd2Vic2l0ZSBjb25zaXN0cyBvZiAke3BhZ2VDb3VudH0gcGFnZXMgd2l0aCB0aGUgZm9sbG93aW5nIHN0cnVjdHVyZSBhbmQgY2hhcmFjdGVyaXN0aWNzOmAsXG4gICAgc3RydWN0dXJlOiBzaXRlTWFwRGF0YS5zdHJ1Y3R1cmUgfHwge30sXG4gICAgcGFnZUhpZXJhcmNoeTogZ2VuZXJhdGVQYWdlSGllcmFyY2h5KHNpdGVNYXBEYXRhKSxcbiAgICB0ZWNobm9sb2dpZXMsXG4gICAgZGVzaWduUGF0dGVybnMsXG4gICAgY29sb3JQYWxldHRlLFxuICAgIGZvbnRGYW1pbGllcyxcbiAgICBrZXlGZWF0dXJlczogKHN0cnVjdHVyZWREYXRhPy5rZXlGZWF0dXJlcyBhcyBzdHJpbmdbXSkgfHwgW11cbiAgfTtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZSBhIGhpZXJhcmNoaWNhbCByZXByZXNlbnRhdGlvbiBvZiB0aGUgc2l0ZSdzIHBhZ2VzXG4gKiBAcGFyYW0gc2l0ZU1hcERhdGEgLSBQcm9jZXNzZWQgc2l0ZSBtYXAgZGF0YVxuICogQHJldHVybnMgSGllcmFyY2hpY2FsIHBhZ2Ugc3RydWN0dXJlXG4gKi9cbmZ1bmN0aW9uIGdlbmVyYXRlUGFnZUhpZXJhcmNoeShzaXRlTWFwRGF0YTogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pIHtcbiAgY29uc3QgcGFnZXMgPSAoc2l0ZU1hcERhdGEucGFnZXMgYXMgc3RyaW5nW10pIHx8IFtdO1xuICBjb25zdCBoaWVyYXJjaHk6IFJlY29yZDxzdHJpbmcsIHVua25vd25bXT4gPSB7fTtcblxuICAvLyBHcm91cCBwYWdlcyBieSBwYXRoIGRlcHRoXG4gIHBhZ2VzLmZvckVhY2goKHVybDogc3RyaW5nKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHVybE9iaiA9IG5ldyBVUkwodXJsKTtcbiAgICAgIGNvbnN0IHBhdGggPSB1cmxPYmoucGF0aG5hbWU7XG4gICAgICBjb25zdCBzZWdtZW50cyA9IHBhdGguc3BsaXQoJy8nKS5maWx0ZXIoQm9vbGVhbik7XG4gICAgICBjb25zdCBkZXB0aCA9IHNlZ21lbnRzLmxlbmd0aDtcblxuICAgICAgaWYgKCFoaWVyYXJjaHlbZGVwdGhdKSB7XG4gICAgICAgIGhpZXJhcmNoeVtkZXB0aF0gPSBbXTtcbiAgICAgIH1cblxuICAgICAgaGllcmFyY2h5W2RlcHRoXS5wdXNoKHtcbiAgICAgICAgdXJsLFxuICAgICAgICBwYXRoLFxuICAgICAgICBzZWdtZW50c1xuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUud2FybihgRXJyb3IgcHJvY2Vzc2luZyBVUkwgZm9yIGhpZXJhcmNoeTogJHt1cmx9YCwgZXJyb3IpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGhpZXJhcmNoeTtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZSBkZXRhaWxlZCBpbmZvcm1hdGlvbiBmb3IgZWFjaCBwYWdlXG4gKiBAcGFyYW0gY29udGVudERhdGEgLSBQcm9jZXNzZWQgY29udGVudCBkYXRhIGZvciBlYWNoIHBhZ2VcbiAqIEByZXR1cm5zIFBhZ2UtYnktcGFnZSBkZXRhaWxzXG4gKi9cbmZ1bmN0aW9uIGdlbmVyYXRlUGFnZURldGFpbHMoY29udGVudERhdGE6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KSB7XG4gIGNvbnN0IHBhZ2VEZXRhaWxzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPiA9IHt9O1xuXG4gIC8vIFByb2Nlc3MgZWFjaCBwYWdlJ3MgY29udGVudCBkYXRhXG4gIE9iamVjdC5lbnRyaWVzKGNvbnRlbnREYXRhKS5mb3JFYWNoKChbdXJsLCBkYXRhXSkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB1cmxPYmogPSBuZXcgVVJMKHVybCk7XG4gICAgICBjb25zdCBwYXRoID0gdXJsT2JqLnBhdGhuYW1lO1xuICAgICAgY29uc3QgcGFnZU5hbWUgPSBwYXRoID09PSAnLycgPyAnSG9tZXBhZ2UnIDogcGF0aC5zcGxpdCgnLycpLmZpbHRlcihCb29sZWFuKS5wb3AoKSB8fCBwYXRoO1xuICAgICAgY29uc3QgcGFnZURhdGEgPSBkYXRhIGFzIFJlY29yZDxzdHJpbmcsIHVua25vd24+O1xuXG4gICAgICBwYWdlRGV0YWlsc1t1cmxdID0ge1xuICAgICAgICB0aXRsZTogKHBhZ2VEYXRhLm1ldGFkYXRhIGFzIFJlY29yZDxzdHJpbmcsIHVua25vd24+KT8udGl0bGUgfHwgcGFnZU5hbWUsXG4gICAgICAgIHBhdGgsXG4gICAgICAgIGh0bWxTdHJ1Y3R1cmU6IGdlbmVyYXRlSHRtbFN0cnVjdHVyZVN1bW1hcnkoKHBhZ2VEYXRhLmh0bWwgYXMgc3RyaW5nKSB8fCAnJyksXG4gICAgICAgIGNzc0NsYXNzZXM6IGV4dHJhY3RDc3NDbGFzc2VzKChwYWdlRGF0YS5odG1sIGFzIHN0cmluZykgfHwgJycpLFxuICAgICAgICBtZXRhZGF0YTogKHBhZ2VEYXRhLm1ldGFkYXRhIGFzIFJlY29yZDxzdHJpbmcsIHVua25vd24+KSB8fCB7fSxcbiAgICAgICAgYXNzZXRzOiAocGFnZURhdGEuYXNzZXRzIGFzIHVua25vd25bXSkgfHwgW10sXG4gICAgICAgIGxpbmtzOiAocGFnZURhdGEubGlua3MgYXMgc3RyaW5nW10pIHx8IFtdXG4gICAgICB9O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLndhcm4oYEVycm9yIHByb2Nlc3NpbmcgcGFnZSBkZXRhaWxzIGZvcjogJHt1cmx9YCwgZXJyb3IpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHBhZ2VEZXRhaWxzO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlIGEgc3VtbWFyeSBvZiB0aGUgSFRNTCBzdHJ1Y3R1cmVcbiAqIEBwYXJhbSBodG1sIC0gUmF3IEhUTUwgY29udGVudFxuICogQHJldHVybnMgSFRNTCBzdHJ1Y3R1cmUgc3VtbWFyeVxuICovXG5mdW5jdGlvbiBnZW5lcmF0ZUh0bWxTdHJ1Y3R1cmVTdW1tYXJ5KGh0bWw6IHN0cmluZykge1xuICAvLyBFeHRyYWN0IG1haW4gc3RydWN0dXJhbCBlbGVtZW50c1xuICBjb25zdCBoZWFkTWF0Y2ggPSBodG1sLm1hdGNoKC88aGVhZFtePl0qPihbXFxzXFxTXSo/KTxcXC9oZWFkPi9pKTtcbiAgY29uc3QgYm9keU1hdGNoID0gaHRtbC5tYXRjaCgvPGJvZHlbXj5dKj4oW1xcc1xcU10qPyk8XFwvYm9keT4vaSk7XG5cbiAgY29uc3QgaGVhZENvbnRlbnQgPSBoZWFkTWF0Y2ggPyBoZWFkTWF0Y2hbMV0gOiAnJztcbiAgY29uc3QgYm9keUNvbnRlbnQgPSBib2R5TWF0Y2ggPyBib2R5TWF0Y2hbMV0gOiAnJztcblxuICAvLyBFeHRyYWN0IGtleSBzZWN0aW9uc1xuICBjb25zdCBoZWFkZXJNYXRjaCA9IGJvZHlDb250ZW50Lm1hdGNoKC88aGVhZGVyW14+XSo+KFtcXHNcXFNdKj8pPFxcL2hlYWRlcj4vaSk7XG4gIGNvbnN0IG1haW5NYXRjaCA9IGJvZHlDb250ZW50Lm1hdGNoKC88bWFpbltePl0qPihbXFxzXFxTXSo/KTxcXC9tYWluPi9pKTtcbiAgY29uc3QgZm9vdGVyTWF0Y2ggPSBib2R5Q29udGVudC5tYXRjaCgvPGZvb3RlcltePl0qPihbXFxzXFxTXSo/KTxcXC9mb290ZXI+L2kpO1xuXG4gIC8vIENvdW50IGVsZW1lbnRzIGJ5IHR5cGVcbiAgY29uc3QgZWxlbWVudENvdW50czogUmVjb3JkPHN0cmluZywgbnVtYmVyPiA9IHt9O1xuICBjb25zdCBlbGVtZW50UmVnZXggPSAvPChbYS16MC05XSspW1xccz5dL2dpO1xuICBsZXQgbWF0Y2g7XG5cbiAgd2hpbGUgKChtYXRjaCA9IGVsZW1lbnRSZWdleC5leGVjKGh0bWwpKSAhPT0gbnVsbCkge1xuICAgIGNvbnN0IHRhZyA9IG1hdGNoWzFdLnRvTG93ZXJDYXNlKCk7XG4gICAgZWxlbWVudENvdW50c1t0YWddID0gKGVsZW1lbnRDb3VudHNbdGFnXSB8fCAwKSArIDE7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGRvY3R5cGU6IGh0bWwubWF0Y2goLzwhRE9DVFlQRVtePl0qPi9pKT8uWzBdIHx8ICdObyBkb2N0eXBlIGZvdW5kJyxcbiAgICBoZWFkRWxlbWVudHM6IHtcbiAgICAgIHRpdGxlOiBoZWFkQ29udGVudC5tYXRjaCgvPHRpdGxlW14+XSo+KFtcXHNcXFNdKj8pPFxcL3RpdGxlPi9pKT8uWzFdIHx8ICcnLFxuICAgICAgbWV0YVRhZ3M6IChoZWFkQ29udGVudC5tYXRjaCgvPG1ldGFbXj5dKj4vZ2kpIHx8IFtdKS5sZW5ndGgsXG4gICAgICBzdHlsZVNoZWV0czogKGhlYWRDb250ZW50Lm1hdGNoKC88bGlua1tePl0qcmVsPVtcIiddc3R5bGVzaGVldFtcIiddW14+XSo+L2dpKSB8fCBbXSkubGVuZ3RoLFxuICAgICAgc2NyaXB0czogKGhlYWRDb250ZW50Lm1hdGNoKC88c2NyaXB0W14+XSo+L2dpKSB8fCBbXSkubGVuZ3RoXG4gICAgfSxcbiAgICBib2R5U3RydWN0dXJlOiB7XG4gICAgICBoYXNIZWFkZXI6ICEhaGVhZGVyTWF0Y2gsXG4gICAgICBoYXNNYWluOiAhIW1haW5NYXRjaCxcbiAgICAgIGhhc0Zvb3RlcjogISFmb290ZXJNYXRjaCxcbiAgICAgIG5hdk1lbnVzOiAoYm9keUNvbnRlbnQubWF0Y2goLzxuYXZbXj5dKj4vZ2kpIHx8IFtdKS5sZW5ndGgsXG4gICAgICBzZWN0aW9uczogKGJvZHlDb250ZW50Lm1hdGNoKC88c2VjdGlvbltePl0qPi9naSkgfHwgW10pLmxlbmd0aCxcbiAgICAgIGFydGljbGVzOiAoYm9keUNvbnRlbnQubWF0Y2goLzxhcnRpY2xlW14+XSo+L2dpKSB8fCBbXSkubGVuZ3RoLFxuICAgICAgYXNpZGVzOiAoYm9keUNvbnRlbnQubWF0Y2goLzxhc2lkZVtePl0qPi9naSkgfHwgW10pLmxlbmd0aFxuICAgIH0sXG4gICAgZWxlbWVudENvdW50c1xuICB9O1xufVxuXG4vKipcbiAqIENsZWFuIGNvbXBvbmVudCBjb250ZW50IGZvciBiZXR0ZXIgQUkgY29uc3VtcHRpb25cbiAqIEBwYXJhbSBjb250ZW50IC0gUmF3IEhUTUwgY29tcG9uZW50IGNvbnRlbnRcbiAqIEByZXR1cm5zIENsZWFuZWQgYW5kIGZvcm1hdHRlZCBjb21wb25lbnQgY29udGVudFxuICovXG5mdW5jdGlvbiBjbGVhbkNvbXBvbmVudENvbnRlbnQoY29udGVudDogc3RyaW5nKTogc3RyaW5nIHtcbiAgaWYgKCFjb250ZW50KSByZXR1cm4gJ05vIGNvbnRlbnQgYXZhaWxhYmxlJztcblxuICAvLyBSZW1vdmUgZXhjZXNzaXZlIHdoaXRlc3BhY2UgYnV0IHByZXNlcnZlIHN0cnVjdHVyZVxuICBsZXQgY2xlYW5lZCA9IGNvbnRlbnRcbiAgICAucmVwbGFjZSgvXFxzKy9nLCAnICcpXG4gICAgLnJlcGxhY2UoLz5cXHMrPC9nLCAnPjwnKVxuICAgIC50cmltKCk7XG5cbiAgLy8gSWYgY29udGVudCBpcyB2ZXJ5IGxvbmcsIHByb3ZpZGUgYSBtZWFuaW5nZnVsIHByZXZpZXcgd2l0aCBrZXkgYXR0cmlidXRlc1xuICBpZiAoY2xlYW5lZC5sZW5ndGggPiAxMDAwKSB7XG4gICAgLy8gRXh0cmFjdCBrZXkgaW5mb3JtYXRpb246IHRhZyBuYW1lLCBjbGFzc2VzLCBJRHMsIGFuZCBmaXJzdCBsZXZlbCBvZiBjb250ZW50XG4gICAgY29uc3QgdGFnTWF0Y2ggPSBjbGVhbmVkLm1hdGNoKC9ePChcXHcrKShbXj5dKik+Lyk7XG4gICAgaWYgKHRhZ01hdGNoKSB7XG4gICAgICBjb25zdCB0YWdOYW1lID0gdGFnTWF0Y2hbMV07XG4gICAgICBjb25zdCBhdHRyaWJ1dGVzID0gdGFnTWF0Y2hbMl07XG5cbiAgICAgIC8vIEV4dHJhY3QgY2xhc3MgYW5kIGlkIGF0dHJpYnV0ZXNcbiAgICAgIGNvbnN0IGNsYXNzTWF0Y2ggPSBhdHRyaWJ1dGVzLm1hdGNoKC9jbGFzcz1bXCInXShbXlwiJ10qKVtcIiddLyk7XG4gICAgICBjb25zdCBpZE1hdGNoID0gYXR0cmlidXRlcy5tYXRjaCgvaWQ9W1wiJ10oW15cIiddKilbXCInXS8pO1xuXG4gICAgICBsZXQgc3VtbWFyeSA9IGA8JHt0YWdOYW1lfWA7XG4gICAgICBpZiAoY2xhc3NNYXRjaCkgc3VtbWFyeSArPSBgIGNsYXNzPVwiJHtjbGFzc01hdGNoWzFdfVwiYDtcbiAgICAgIGlmIChpZE1hdGNoKSBzdW1tYXJ5ICs9IGAgaWQ9XCIke2lkTWF0Y2hbMV19XCJgO1xuICAgICAgc3VtbWFyeSArPSAnPic7XG5cbiAgICAgIC8vIEFkZCBmaXJzdCBsZXZlbCBjb250ZW50IHByZXZpZXdcbiAgICAgIGNvbnN0IGNvbnRlbnRNYXRjaCA9IGNsZWFuZWQubWF0Y2goLz4oW148XXswLDIwMH0pLyk7XG4gICAgICBpZiAoY29udGVudE1hdGNoICYmIGNvbnRlbnRNYXRjaFsxXS50cmltKCkpIHtcbiAgICAgICAgc3VtbWFyeSArPSBjb250ZW50TWF0Y2hbMV0udHJpbSgpO1xuICAgICAgICBpZiAoY29udGVudE1hdGNoWzFdLmxlbmd0aCA+IDIwMCkgc3VtbWFyeSArPSAnLi4uJztcbiAgICAgIH1cblxuICAgICAgc3VtbWFyeSArPSBgPC8ke3RhZ05hbWV9PmA7XG4gICAgICByZXR1cm4gc3VtbWFyeSArICdcXG5cXG4qKk5vdGUqKjogRnVsbCBjb21wb25lbnQgY29udGVudCBhdmFpbGFibGUgaW4gcGFnZXMvIGZvbGRlcic7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNsZWFuZWQ7XG59XG5cbi8qKlxuICogRXh0cmFjdCBDU1MgY2xhc3NlcyBmcm9tIEhUTUwgY29udGVudFxuICogQHBhcmFtIGh0bWwgLSBSYXcgSFRNTCBjb250ZW50XG4gKiBAcmV0dXJucyBBcnJheSBvZiB1bmlxdWUgQ1NTIGNsYXNzZXNcbiAqL1xuZnVuY3Rpb24gZXh0cmFjdENzc0NsYXNzZXMoaHRtbDogc3RyaW5nKSB7XG4gIGNvbnN0IGNsYXNzZXM6IFNldDxzdHJpbmc+ID0gbmV3IFNldCgpO1xuICBjb25zdCBjbGFzc1JlZ2V4ID0gL2NsYXNzPVtcIiddKFteXCInXSspW1wiJ10vZ2k7XG4gIGxldCBtYXRjaDtcblxuICB3aGlsZSAoKG1hdGNoID0gY2xhc3NSZWdleC5leGVjKGh0bWwpKSAhPT0gbnVsbCkge1xuICAgIGlmIChtYXRjaFsxXSkge1xuICAgICAgbWF0Y2hbMV0uc3BsaXQoL1xccysvKS5mb3JFYWNoKGNscyA9PiB7XG4gICAgICAgIGlmIChjbHMpIGNsYXNzZXMuYWRkKGNscyk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gQXJyYXkuZnJvbShjbGFzc2VzKTtcbn1cblxuLyoqXG4gKiBJZGVudGlmeSBjb21tb24gY29tcG9uZW50cyBhY3Jvc3MgcGFnZXNcbiAqIEBwYXJhbSBjb250ZW50RGF0YSAtIFByb2Nlc3NlZCBjb250ZW50IGRhdGEgZm9yIGVhY2ggcGFnZVxuICogQHJldHVybnMgSWRlbnRpZmllZCBjb21wb25lbnRzXG4gKi9cbmZ1bmN0aW9uIGlkZW50aWZ5Q29tcG9uZW50cyhjb250ZW50RGF0YTogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pIHtcbiAgY29uc3QgY29tcG9uZW50czogUmVjb3JkPHN0cmluZywgdW5rbm93bltdPiA9IHtcbiAgICBuYXZpZ2F0aW9uOiBbXSxcbiAgICBmb290ZXI6IFtdLFxuICAgIGhlYWRlcjogW10sXG4gICAgc2lkZWJhcjogW10sXG4gICAgY2FyZHM6IFtdLFxuICAgIGZvcm1zOiBbXSxcbiAgICBjdXN0b206IFtdXG4gIH07XG5cbiAgLy8gUHJvY2VzcyBlYWNoIHBhZ2UgdG8gaWRlbnRpZnkgY29tcG9uZW50c1xuICBPYmplY3QuZW50cmllcyhjb250ZW50RGF0YSkuZm9yRWFjaCgoW3VybCwgZGF0YV0pID0+IHtcbiAgICBjb25zdCBwYWdlRGF0YSA9IGRhdGEgYXMgUmVjb3JkPHN0cmluZywgdW5rbm93bj47XG4gICAgY29uc3QgaHRtbCA9IChwYWdlRGF0YS5odG1sIGFzIHN0cmluZykgfHwgJyc7XG5cbiAgICAvLyBFeHRyYWN0IG5hdmlnYXRpb24gY29tcG9uZW50c1xuICAgIGNvbnN0IG5hdk1hdGNoZXMgPSBodG1sLm1hdGNoKC88bmF2W14+XSo+KFtcXHNcXFNdKj8pPFxcL25hdj4vZ2kpIHx8IFtdO1xuICAgIG5hdk1hdGNoZXMuZm9yRWFjaCgobmF2OiBzdHJpbmcsIGluZGV4OiBudW1iZXIpID0+IHtcbiAgICAgIGNvbXBvbmVudHMubmF2aWdhdGlvbi5wdXNoKHtcbiAgICAgICAgc291cmNlOiB1cmwsXG4gICAgICAgIGluZGV4LFxuICAgICAgICBjb250ZW50OiBuYXZcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgLy8gRXh0cmFjdCBmb290ZXIgY29tcG9uZW50c1xuICAgIGNvbnN0IGZvb3Rlck1hdGNoZXMgPSBodG1sLm1hdGNoKC88Zm9vdGVyW14+XSo+KFtcXHNcXFNdKj8pPFxcL2Zvb3Rlcj4vZ2kpIHx8IFtdO1xuICAgIGZvb3Rlck1hdGNoZXMuZm9yRWFjaCgoZm9vdGVyOiBzdHJpbmcsIGluZGV4OiBudW1iZXIpID0+IHtcbiAgICAgIGNvbXBvbmVudHMuZm9vdGVyLnB1c2goe1xuICAgICAgICBzb3VyY2U6IHVybCxcbiAgICAgICAgaW5kZXgsXG4gICAgICAgIGNvbnRlbnQ6IGZvb3RlclxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICAvLyBFeHRyYWN0IGhlYWRlciBjb21wb25lbnRzXG4gICAgY29uc3QgaGVhZGVyTWF0Y2hlcyA9IGh0bWwubWF0Y2goLzxoZWFkZXJbXj5dKj4oW1xcc1xcU10qPyk8XFwvaGVhZGVyPi9naSkgfHwgW107XG4gICAgaGVhZGVyTWF0Y2hlcy5mb3JFYWNoKChoZWFkZXI6IHN0cmluZywgaW5kZXg6IG51bWJlcikgPT4ge1xuICAgICAgY29tcG9uZW50cy5oZWFkZXIucHVzaCh7XG4gICAgICAgIHNvdXJjZTogdXJsLFxuICAgICAgICBpbmRleCxcbiAgICAgICAgY29udGVudDogaGVhZGVyXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8vIEV4dHJhY3Qgc2lkZWJhciBjb21wb25lbnRzXG4gICAgY29uc3Qgc2lkZWJhck1hdGNoZXMgPSBodG1sLm1hdGNoKC88YXNpZGVbXj5dKj4oW1xcc1xcU10qPyk8XFwvYXNpZGU+L2dpKSB8fCBbXTtcbiAgICBzaWRlYmFyTWF0Y2hlcy5mb3JFYWNoKChzaWRlYmFyOiBzdHJpbmcsIGluZGV4OiBudW1iZXIpID0+IHtcbiAgICAgIGNvbXBvbmVudHMuc2lkZWJhci5wdXNoKHtcbiAgICAgICAgc291cmNlOiB1cmwsXG4gICAgICAgIGluZGV4LFxuICAgICAgICBjb250ZW50OiBzaWRlYmFyXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8vIEV4dHJhY3QgZm9ybSBjb21wb25lbnRzXG4gICAgY29uc3QgZm9ybU1hdGNoZXMgPSBodG1sLm1hdGNoKC88Zm9ybVtePl0qPihbXFxzXFxTXSo/KTxcXC9mb3JtPi9naSkgfHwgW107XG4gICAgZm9ybU1hdGNoZXMuZm9yRWFjaCgoZm9ybTogc3RyaW5nLCBpbmRleDogbnVtYmVyKSA9PiB7XG4gICAgICBjb21wb25lbnRzLmZvcm1zLnB1c2goe1xuICAgICAgICBzb3VyY2U6IHVybCxcbiAgICAgICAgaW5kZXgsXG4gICAgICAgIGNvbnRlbnQ6IGZvcm1cbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgLy8gSWRlbnRpZnkgY2FyZC1saWtlIGNvbXBvbmVudHMgKGRpdnMgd2l0aCBjZXJ0YWluIGNsYXNzZXMpXG4gICAgY29uc3QgY2FyZENsYXNzUmVnZXggPSAvY2xhc3M9W1wiJ11bXlwiJ10qY2FyZFteXCInXSpbXCInXS9pO1xuICAgIGNvbnN0IGRpdk1hdGNoZXMgPSBodG1sLm1hdGNoKC88ZGl2W14+XSo+KFtcXHNcXFNdKj8pPFxcL2Rpdj4vZ2kpIHx8IFtdO1xuICAgIGRpdk1hdGNoZXMuZm9yRWFjaCgoZGl2OiBzdHJpbmcsIGluZGV4OiBudW1iZXIpID0+IHtcbiAgICAgIGlmIChjYXJkQ2xhc3NSZWdleC50ZXN0KGRpdikpIHtcbiAgICAgICAgY29tcG9uZW50cy5jYXJkcy5wdXNoKHtcbiAgICAgICAgICBzb3VyY2U6IHVybCxcbiAgICAgICAgICBpbmRleCxcbiAgICAgICAgICBjb250ZW50OiBkaXZcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuXG4gIC8vIERlZHVwbGljYXRlIGNvbXBvbmVudHMgYnkgY29tcGFyaW5nIGNvbnRlbnRcbiAgY29uc3QgZGVkdXBsaWNhdGVkOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duW10+ID0ge307XG4gIE9iamVjdC5lbnRyaWVzKGNvbXBvbmVudHMpLmZvckVhY2goKFt0eXBlLCBpdGVtc10pID0+IHtcbiAgICBjb25zdCB1bmlxdWVJdGVtcyA9IG5ldyBNYXAoKTtcbiAgICAoaXRlbXMgYXMgUmVjb3JkPHN0cmluZywgdW5rbm93bj5bXSkuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgIC8vIENyZWF0ZSBhIHNpbXBsaWZpZWQgdmVyc2lvbiBvZiB0aGUgY29udGVudCBmb3IgY29tcGFyaXNvblxuICAgICAgY29uc3Qgc2ltcGxpZmllZENvbnRlbnQgPSAoaXRlbS5jb250ZW50IGFzIHN0cmluZylcbiAgICAgICAgLnJlcGxhY2UoL1xccysvZywgJyAnKVxuICAgICAgICAucmVwbGFjZSgvY2xhc3M9W1wiJ11bXlwiJ10qW1wiJ10vZ2ksICcnKVxuICAgICAgICAucmVwbGFjZSgvaWQ9W1wiJ11bXlwiJ10qW1wiJ10vZ2ksICcnKVxuICAgICAgICAucmVwbGFjZSgvc3R5bGU9W1wiJ11bXlwiJ10qW1wiJ10vZ2ksICcnKTtcblxuICAgICAgaWYgKCF1bmlxdWVJdGVtcy5oYXMoc2ltcGxpZmllZENvbnRlbnQpKSB7XG4gICAgICAgIHVuaXF1ZUl0ZW1zLnNldChzaW1wbGlmaWVkQ29udGVudCwgaXRlbSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBkZWR1cGxpY2F0ZWRbdHlwZV0gPSBBcnJheS5mcm9tKHVuaXF1ZUl0ZW1zLnZhbHVlcygpKTtcbiAgfSk7XG5cbiAgcmV0dXJuIGRlZHVwbGljYXRlZDtcbn1cblxuLyoqXG4gKiBFeHRyYWN0IGFzc2V0IHJlZmVyZW5jZXMgZnJvbSBjb250ZW50IGRhdGFcbiAqIEBwYXJhbSBjb250ZW50RGF0YSAtIFByb2Nlc3NlZCBjb250ZW50IGRhdGEgZm9yIGVhY2ggcGFnZVxuICogQHJldHVybnMgQXNzZXQgcmVmZXJlbmNlc1xuICovXG5mdW5jdGlvbiBleHRyYWN0QXNzZXRSZWZlcmVuY2VzKGNvbnRlbnREYXRhOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPikge1xuICBjb25zdCBhc3NldHM6IFJlY29yZDxzdHJpbmcsIFNldDxzdHJpbmc+PiA9IHtcbiAgICBjc3M6IG5ldyBTZXQoKSxcbiAgICBqYXZhc2NyaXB0OiBuZXcgU2V0KCksXG4gICAgaW1hZ2VzOiBuZXcgU2V0KCksXG4gICAgZm9udHM6IG5ldyBTZXQoKSxcbiAgICB2aWRlb3M6IG5ldyBTZXQoKSxcbiAgICBvdGhlcjogbmV3IFNldCgpXG4gIH07XG5cbiAgLy8gUHJvY2VzcyBlYWNoIHBhZ2UgdG8gZXh0cmFjdCBhc3NldCByZWZlcmVuY2VzXG4gIE9iamVjdC5lbnRyaWVzKGNvbnRlbnREYXRhKS5mb3JFYWNoKChbX3VybCwgZGF0YV0pID0+IHtcbiAgICBjb25zdCBwYWdlRGF0YSA9IGRhdGEgYXMgUmVjb3JkPHN0cmluZywgdW5rbm93bj47XG4gICAgY29uc3QgcGFnZUFzc2V0cyA9IChwYWdlRGF0YS5hc3NldHMgYXMgUmVjb3JkPHN0cmluZywgdW5rbm93bj5bXSkgfHwgW107XG5cbiAgICBwYWdlQXNzZXRzLmZvckVhY2goKGFzc2V0OiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPikgPT4ge1xuICAgICAgY29uc3QgYXNzZXRVcmwgPSBhc3NldC51cmwgYXMgc3RyaW5nO1xuICAgICAgY29uc3QgYXNzZXRUeXBlID0gKGFzc2V0LnR5cGUgYXMgc3RyaW5nKT8udG9Mb3dlckNhc2UoKSB8fCAnb3RoZXInO1xuXG4gICAgICBzd2l0Y2ggKGFzc2V0VHlwZSkge1xuICAgICAgICBjYXNlICdjc3MnOlxuICAgICAgICAgIGFzc2V0cy5jc3MuYWRkKGFzc2V0VXJsKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnamF2YXNjcmlwdCc6XG4gICAgICAgICAgYXNzZXRzLmphdmFzY3JpcHQuYWRkKGFzc2V0VXJsKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnaW1hZ2UnOlxuICAgICAgICAgIGFzc2V0cy5pbWFnZXMuYWRkKGFzc2V0VXJsKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnZm9udCc6XG4gICAgICAgICAgYXNzZXRzLmZvbnRzLmFkZChhc3NldFVybCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3ZpZGVvJzpcbiAgICAgICAgICBhc3NldHMudmlkZW9zLmFkZChhc3NldFVybCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgYXNzZXRzLm90aGVyLmFkZChhc3NldFVybCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuXG4gIC8vIENvbnZlcnQgU2V0cyB0byBBcnJheXMgZm9yIHRoZSBmaW5hbCBvdXRwdXRcbiAgY29uc3QgcmVzdWx0OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmdbXT4gPSB7fTtcbiAgT2JqZWN0LmVudHJpZXMoYXNzZXRzKS5mb3JFYWNoKChbdHlwZSwgdXJsc10pID0+IHtcbiAgICByZXN1bHRbdHlwZV0gPSBBcnJheS5mcm9tKHVybHMpO1xuICB9KTtcblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEdlbmVyYXRlIHBlcmZvcm1hbmNlIGd1aWRlbGluZXMgYmFzZWQgb24gTGlnaHRob3VzZSBtZXRyaWNzXG4gKiBAcGFyYW0gcGVyZm9ybWFuY2VEYXRhIC0gUHJvY2Vzc2VkIHBlcmZvcm1hbmNlIG1ldHJpY3NcbiAqIEByZXR1cm5zIFBlcmZvcm1hbmNlIGd1aWRlbGluZXNcbiAqL1xuZnVuY3Rpb24gZ2VuZXJhdGVQZXJmb3JtYW5jZUd1aWRlbGluZXMocGVyZm9ybWFuY2VEYXRhOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPikge1xuICBpZiAoIXBlcmZvcm1hbmNlRGF0YSkge1xuICAgIHJldHVybiB7XG4gICAgICB0aXRsZTogJ1BlcmZvcm1hbmNlIENvbnNpZGVyYXRpb25zJyxcbiAgICAgIGRlc2NyaXB0aW9uOiAnTm8gcGVyZm9ybWFuY2UgZGF0YSBhdmFpbGFibGUuJyxcbiAgICAgIHJlY29tbWVuZGF0aW9uczogW11cbiAgICB9O1xuICB9XG5cbiAgY29uc3QgcGVyZm9ybWFuY2UgPSAocGVyZm9ybWFuY2VEYXRhLnBlcmZvcm1hbmNlIGFzIFJlY29yZDxzdHJpbmcsIHVua25vd24+KSB8fCB7fTtcbiAgY29uc3QgYWNjZXNzaWJpbGl0eSA9IChwZXJmb3JtYW5jZURhdGEuYWNjZXNzaWJpbGl0eSBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPikgfHwge307XG4gIGNvbnN0IHNlbyA9IChwZXJmb3JtYW5jZURhdGEuc2VvIGFzIFJlY29yZDxzdHJpbmcsIHVua25vd24+KSB8fCB7fTtcbiAgY29uc3QgYmVzdFByYWN0aWNlcyA9IChwZXJmb3JtYW5jZURhdGEuYmVzdFByYWN0aWNlcyBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPikgfHwge307XG5cbiAgY29uc3QgcmVjb21tZW5kYXRpb25zOiBzdHJpbmdbXSA9IFtdO1xuXG4gIC8vIEFkZCBwZXJmb3JtYW5jZSByZWNvbW1lbmRhdGlvbnNcbiAgY29uc3QgcGVyZlNjb3JlID0gKHBlcmZvcm1hbmNlLnNjb3JlIGFzIG51bWJlcikgfHwgMDtcbiAgaWYgKHBlcmZTY29yZSA8IDAuOSkge1xuICAgIHJlY29tbWVuZGF0aW9ucy5wdXNoKCdPcHRpbWl6ZSBwYWdlIGxvYWQgcGVyZm9ybWFuY2UgdG8gaW1wcm92ZSB1c2VyIGV4cGVyaWVuY2UnKTtcblxuICAgIGNvbnN0IG1ldHJpY3MgPSAocGVyZm9ybWFuY2UubWV0cmljcyBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPikgfHwge307XG4gICAgY29uc3QgZmNwID0gKG1ldHJpY3MuZmlyc3RDb250ZW50ZnVsUGFpbnQgYXMgUmVjb3JkPHN0cmluZywgdW5rbm93bj4pPy52YWx1ZSBhcyBudW1iZXI7XG4gICAgY29uc3QgbGNwID0gKG1ldHJpY3MubGFyZ2VzdENvbnRlbnRmdWxQYWludCBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik/LnZhbHVlIGFzIG51bWJlcjtcbiAgICBjb25zdCB0YnQgPSAobWV0cmljcy50b3RhbEJsb2NraW5nVGltZSBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik/LnZhbHVlIGFzIG51bWJlcjtcbiAgICBjb25zdCBjbHMgPSAobWV0cmljcy5jdW11bGF0aXZlTGF5b3V0U2hpZnQgYXMgUmVjb3JkPHN0cmluZywgdW5rbm93bj4pPy52YWx1ZSBhcyBudW1iZXI7XG5cbiAgICBpZiAoZmNwID4gMTAwMCkge1xuICAgICAgcmVjb21tZW5kYXRpb25zLnB1c2goJ1JlZHVjZSBGaXJzdCBDb250ZW50ZnVsIFBhaW50IHRpbWUgdG8gdW5kZXIgMSBzZWNvbmQnKTtcbiAgICB9XG4gICAgaWYgKGxjcCA+IDI1MDApIHtcbiAgICAgIHJlY29tbWVuZGF0aW9ucy5wdXNoKCdPcHRpbWl6ZSBMYXJnZXN0IENvbnRlbnRmdWwgUGFpbnQgdG8gdW5kZXIgMi41IHNlY29uZHMnKTtcbiAgICB9XG4gICAgaWYgKHRidCA+IDIwMCkge1xuICAgICAgcmVjb21tZW5kYXRpb25zLnB1c2goJ1JlZHVjZSBUb3RhbCBCbG9ja2luZyBUaW1lIHRvIGltcHJvdmUgaW50ZXJhY3Rpdml0eScpO1xuICAgIH1cbiAgICBpZiAoY2xzID4gMC4xKSB7XG4gICAgICByZWNvbW1lbmRhdGlvbnMucHVzaCgnTWluaW1pemUgQ3VtdWxhdGl2ZSBMYXlvdXQgU2hpZnQgdG8gaW1wcm92ZSB2aXN1YWwgc3RhYmlsaXR5Jyk7XG4gICAgfVxuICB9XG5cbiAgLy8gQWRkIGFjY2Vzc2liaWxpdHkgcmVjb21tZW5kYXRpb25zXG4gIGlmICgoYWNjZXNzaWJpbGl0eS5zY29yZSBhcyBudW1iZXIpIDwgMC45KSB7XG4gICAgcmVjb21tZW5kYXRpb25zLnB1c2goJ0ltcHJvdmUgYWNjZXNzaWJpbGl0eSB0byBlbnN1cmUgdGhlIHNpdGUgaXMgdXNhYmxlIGJ5IGV2ZXJ5b25lJyk7XG4gIH1cblxuICAvLyBBZGQgU0VPIHJlY29tbWVuZGF0aW9uc1xuICBpZiAoKHNlby5zY29yZSBhcyBudW1iZXIpIDwgMC45KSB7XG4gICAgcmVjb21tZW5kYXRpb25zLnB1c2goJ0VuaGFuY2UgU0VPIHByYWN0aWNlcyB0byBpbXByb3ZlIHNlYXJjaCBlbmdpbmUgdmlzaWJpbGl0eScpO1xuICB9XG5cbiAgLy8gQWRkIGJlc3QgcHJhY3RpY2VzIHJlY29tbWVuZGF0aW9uc1xuICBpZiAoKGJlc3RQcmFjdGljZXMuc2NvcmUgYXMgbnVtYmVyKSA8IDAuOSkge1xuICAgIHJlY29tbWVuZGF0aW9ucy5wdXNoKCdGb2xsb3cgd2ViIGJlc3QgcHJhY3RpY2VzIGZvciBzZWN1cml0eSBhbmQgcXVhbGl0eScpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB0aXRsZTogJ1BlcmZvcm1hbmNlIENvbnNpZGVyYXRpb25zJyxcbiAgICBkZXNjcmlwdGlvbjogJ0NvbnNpZGVyIHRoZXNlIHBlcmZvcm1hbmNlIG1ldHJpY3Mgd2hlbiByZWJ1aWxkaW5nIHRoZSB3ZWJzaXRlOicsXG4gICAgc2NvcmVzOiB7XG4gICAgICBwZXJmb3JtYW5jZTogKHBlcmZvcm1hbmNlLnNjb3JlIGFzIG51bWJlcikgfHwgMCxcbiAgICAgIGFjY2Vzc2liaWxpdHk6IChhY2Nlc3NpYmlsaXR5LnNjb3JlIGFzIG51bWJlcikgfHwgMCxcbiAgICAgIHNlbzogKHNlby5zY29yZSBhcyBudW1iZXIpIHx8IDAsXG4gICAgICBiZXN0UHJhY3RpY2VzOiAoYmVzdFByYWN0aWNlcy5zY29yZSBhcyBudW1iZXIpIHx8IDBcbiAgICB9LFxuICAgIG1ldHJpY3M6IHtcbiAgICAgIGZpcnN0Q29udGVudGZ1bFBhaW50OiAocGVyZm9ybWFuY2UubWV0cmljcyBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik/LmZpcnN0Q29udGVudGZ1bFBhaW50LFxuICAgICAgbGFyZ2VzdENvbnRlbnRmdWxQYWludDogKHBlcmZvcm1hbmNlLm1ldHJpY3MgYXMgUmVjb3JkPHN0cmluZywgdW5rbm93bj4pPy5sYXJnZXN0Q29udGVudGZ1bFBhaW50LFxuICAgICAgdG90YWxCbG9ja2luZ1RpbWU6IChwZXJmb3JtYW5jZS5tZXRyaWNzIGFzIFJlY29yZDxzdHJpbmcsIHVua25vd24+KT8udG90YWxCbG9ja2luZ1RpbWUsXG4gICAgICBjdW11bGF0aXZlTGF5b3V0U2hpZnQ6IChwZXJmb3JtYW5jZS5tZXRyaWNzIGFzIFJlY29yZDxzdHJpbmcsIHVua25vd24+KT8uY3VtdWxhdGl2ZUxheW91dFNoaWZ0XG4gICAgfSxcbiAgICByZWNvbW1lbmRhdGlvbnNcbiAgfTtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZSBzdGVwLWJ5LXN0ZXAgcmVjb25zdHJ1Y3Rpb24gaW5zdHJ1Y3Rpb25zXG4gKiBAcGFyYW0gc2l0ZU1hcERhdGEgLSBQcm9jZXNzZWQgc2l0ZSBtYXAgZGF0YVxuICogQHBhcmFtIHN0cnVjdHVyZWREYXRhIC0gRXh0cmFjdGVkIHN0cnVjdHVyZWQgZGF0YSBhYm91dCB0aGUgd2Vic2l0ZVxuICogQHJldHVybnMgUmVjb25zdHJ1Y3Rpb24gaW5zdHJ1Y3Rpb25zXG4gKi9cbmZ1bmN0aW9uIGdlbmVyYXRlUmVjb25zdHJ1Y3Rpb25JbnN0cnVjdGlvbnMoX3NpdGVNYXBEYXRhOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPiwgc3RydWN0dXJlZERhdGE6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KSB7XG4gIGNvbnN0IHRlY2hub2xvZ2llcyA9IChzdHJ1Y3R1cmVkRGF0YT8udGVjaG5vbG9naWVzIGFzIHN0cmluZ1tdKSB8fCBbXTtcbiAgY29uc3QgaGFzRnJvbnRlbmRGcmFtZXdvcmsgPSB0ZWNobm9sb2dpZXMuc29tZSgodGVjaDogc3RyaW5nKSA9PlxuICAgIC9yZWFjdHx2dWV8YW5ndWxhcnxzdmVsdGV8bmV4dHxudXh0L2kudGVzdCh0ZWNoKVxuICApO1xuXG4gIGNvbnN0IHN0ZXBzID0gW1xuICAgIHtcbiAgICAgIHRpdGxlOiAnMS4gUHJvamVjdCBTZXR1cCcsXG4gICAgICBkZXNjcmlwdGlvbjogJ1NldCB1cCB0aGUgZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnQgYW5kIHByb2plY3Qgc3RydWN0dXJlJyxcbiAgICAgIHRhc2tzOiBbXG4gICAgICAgICdDcmVhdGUgYSBuZXcgcHJvamVjdCBkaXJlY3RvcnknLFxuICAgICAgICBgSW5pdGlhbGl6ZSB0aGUgcHJvamVjdCB3aXRoICR7aGFzRnJvbnRlbmRGcmFtZXdvcmsgPyAndGhlIGFwcHJvcHJpYXRlIGZyYW1ld29yaycgOiAnSFRNTCwgQ1NTLCBhbmQgSmF2YVNjcmlwdCBmaWxlcyd9YCxcbiAgICAgICAgJ1NldCB1cCB0aGUgZm9sZGVyIHN0cnVjdHVyZSBmb3IgYXNzZXRzLCBjb21wb25lbnRzLCBhbmQgcGFnZXMnLFxuICAgICAgICAnSW5zdGFsbCBuZWNlc3NhcnkgZGVwZW5kZW5jaWVzJ1xuICAgICAgXVxuICAgIH0sXG4gICAge1xuICAgICAgdGl0bGU6ICcyLiBBc3NldCBDb2xsZWN0aW9uJyxcbiAgICAgIGRlc2NyaXB0aW9uOiAnR2F0aGVyIGFuZCBvcmdhbml6ZSBhbGwgcmVxdWlyZWQgYXNzZXRzJyxcbiAgICAgIHRhc2tzOiBbXG4gICAgICAgICdEb3dubG9hZCBvciByZWNyZWF0ZSBhbGwgQ1NTIGZpbGVzJyxcbiAgICAgICAgJ0Rvd25sb2FkIG9yIHJlY3JlYXRlIGFsbCBKYXZhU2NyaXB0IGZpbGVzJyxcbiAgICAgICAgJ0NvbGxlY3QgYWxsIGltYWdlcywgZm9udHMsIGFuZCBvdGhlciBtZWRpYSBhc3NldHMnLFxuICAgICAgICAnT3JnYW5pemUgYXNzZXRzIGluIHRoZSBhcHByb3ByaWF0ZSBkaXJlY3RvcmllcydcbiAgICAgIF1cbiAgICB9LFxuICAgIHtcbiAgICAgIHRpdGxlOiAnMy4gQ29tcG9uZW50IERldmVsb3BtZW50JyxcbiAgICAgIGRlc2NyaXB0aW9uOiAnQnVpbGQgcmV1c2FibGUgY29tcG9uZW50cyBpZGVudGlmaWVkIGluIHRoZSBhbmFseXNpcycsXG4gICAgICB0YXNrczogW1xuICAgICAgICAnQ3JlYXRlIHRoZSBoZWFkZXIgY29tcG9uZW50JyxcbiAgICAgICAgJ0NyZWF0ZSB0aGUgbmF2aWdhdGlvbiBjb21wb25lbnQnLFxuICAgICAgICAnQ3JlYXRlIHRoZSBmb290ZXIgY29tcG9uZW50JyxcbiAgICAgICAgJ0RldmVsb3AgYW55IHNpZGViYXIgY29tcG9uZW50cycsXG4gICAgICAgICdCdWlsZCBjYXJkIGFuZCBmb3JtIGNvbXBvbmVudHMnLFxuICAgICAgICAnSW1wbGVtZW50IGFueSBjdXN0b20gY29tcG9uZW50cyBzcGVjaWZpYyB0byB0aGUgc2l0ZSdcbiAgICAgIF1cbiAgICB9LFxuICAgIHtcbiAgICAgIHRpdGxlOiAnNC4gUGFnZSBDb25zdHJ1Y3Rpb24nLFxuICAgICAgZGVzY3JpcHRpb246ICdCdWlsZCBpbmRpdmlkdWFsIHBhZ2VzIHVzaW5nIHRoZSBjb21wb25lbnRzJyxcbiAgICAgIHRhc2tzOiBbXG4gICAgICAgICdDcmVhdGUgdGhlIGhvbWVwYWdlIHdpdGggYXBwcm9wcmlhdGUgbGF5b3V0IGFuZCBjb21wb25lbnRzJyxcbiAgICAgICAgJ0RldmVsb3Agc2Vjb25kYXJ5IHBhZ2VzIGZvbGxvd2luZyB0aGUgc2l0ZSBoaWVyYXJjaHknLFxuICAgICAgICAnSW1wbGVtZW50IHJlc3BvbnNpdmUgZGVzaWduIGZvciBhbGwgcGFnZXMnLFxuICAgICAgICAnRW5zdXJlIGNvbnNpc3RlbnQgc3R5bGluZyBhY3Jvc3MgdGhlIHNpdGUnXG4gICAgICBdXG4gICAgfSxcbiAgICB7XG4gICAgICB0aXRsZTogJzUuIEZ1bmN0aW9uYWxpdHkgSW1wbGVtZW50YXRpb24nLFxuICAgICAgZGVzY3JpcHRpb246ICdBZGQgaW50ZXJhY3RpdmUgZmVhdHVyZXMgYW5kIGZ1bmN0aW9uYWxpdHknLFxuICAgICAgdGFza3M6IFtcbiAgICAgICAgJ0ltcGxlbWVudCBuYXZpZ2F0aW9uIGFuZCByb3V0aW5nJyxcbiAgICAgICAgJ0FkZCBmb3JtIHZhbGlkYXRpb24gYW5kIHN1Ym1pc3Npb24gaGFuZGxpbmcnLFxuICAgICAgICAnSW1wbGVtZW50IGFueSBpbnRlcmFjdGl2ZSBlbGVtZW50cyAoc2xpZGVycywgYWNjb3JkaW9ucywgZXRjLiknLFxuICAgICAgICAnQWRkIGFueSByZXF1aXJlZCBBUEkgaW50ZWdyYXRpb25zIG9yIGRhdGEgZmV0Y2hpbmcnXG4gICAgICBdXG4gICAgfSxcbiAgICB7XG4gICAgICB0aXRsZTogJzYuIFRlc3RpbmcgYW5kIE9wdGltaXphdGlvbicsXG4gICAgICBkZXNjcmlwdGlvbjogJ1Rlc3QgdGhlIHNpdGUgYW5kIG9wdGltaXplIHBlcmZvcm1hbmNlJyxcbiAgICAgIHRhc2tzOiBbXG4gICAgICAgICdUZXN0IHRoZSBzaXRlIGFjcm9zcyBkaWZmZXJlbnQgYnJvd3NlcnMgYW5kIGRldmljZXMnLFxuICAgICAgICAnT3B0aW1pemUgaW1hZ2VzIGFuZCBhc3NldHMgZm9yIHBlcmZvcm1hbmNlJyxcbiAgICAgICAgJ0ltcGxlbWVudCBwZXJmb3JtYW5jZSBiZXN0IHByYWN0aWNlcycsXG4gICAgICAgICdFbnN1cmUgYWNjZXNzaWJpbGl0eSBjb21wbGlhbmNlJyxcbiAgICAgICAgJ1ZhbGlkYXRlIEhUTUwgYW5kIENTUydcbiAgICAgIF1cbiAgICB9LFxuICAgIHtcbiAgICAgIHRpdGxlOiAnNy4gRGVwbG95bWVudCcsXG4gICAgICBkZXNjcmlwdGlvbjogJ1ByZXBhcmUgdGhlIHNpdGUgZm9yIGRlcGxveW1lbnQnLFxuICAgICAgdGFza3M6IFtcbiAgICAgICAgJ0J1bmRsZSBhbmQgbWluaWZ5IGFzc2V0cycsXG4gICAgICAgICdDb25maWd1cmUgYXBwcm9wcmlhdGUgY2FjaGluZyBzdHJhdGVnaWVzJyxcbiAgICAgICAgJ1NldCB1cCBhbnkgcmVxdWlyZWQgc2VydmVyIGNvbmZpZ3VyYXRpb25zJyxcbiAgICAgICAgJ0RlcGxveSB0aGUgc2l0ZSB0byB0aGUgaG9zdGluZyBlbnZpcm9ubWVudCdcbiAgICAgIF1cbiAgICB9XG4gIF07XG5cbiAgcmV0dXJuIHtcbiAgICB0aXRsZTogJ1JlY29uc3RydWN0aW9uIEluc3RydWN0aW9ucycsXG4gICAgZGVzY3JpcHRpb246ICdGb2xsb3cgdGhlc2Ugc3RlcHMgdG8gcmVidWlsZCB0aGUgd2Vic2l0ZSB3aXRoIG1heGltdW0gZmlkZWxpdHk6JyxcbiAgICBzdGVwc1xuICB9O1xufVxuXG4vKipcbiAqIEdlbmVyYXRlIENsYXVkZSBTb25uZXQtc3BlY2lmaWMgcmVjb25zdHJ1Y3Rpb24gaW5zdHJ1Y3Rpb25zXG4gKiBAcGFyYW0gc2l0ZU1hcERhdGEgLSBQcm9jZXNzZWQgc2l0ZSBtYXAgZGF0YVxuICogQHBhcmFtIHN0cnVjdHVyZWREYXRhIC0gRXh0cmFjdGVkIHN0cnVjdHVyZWQgZGF0YSBhYm91dCB0aGUgd2Vic2l0ZVxuICogQHBhcmFtIGNvbXBvbmVudHMgLSBJZGVudGlmaWVkIGNvbXBvbmVudHNcbiAqIEBwYXJhbSBhc3NldHMgLSBBc3NldCByZWZlcmVuY2VzXG4gKiBAcmV0dXJucyBDbGF1ZGUgU29ubmV0LW9wdGltaXplZCBpbnN0cnVjdGlvbnNcbiAqL1xuZnVuY3Rpb24gZ2VuZXJhdGVDbGF1ZGVTb25uZXRJbnN0cnVjdGlvbnMoXG4gIHNpdGVNYXBEYXRhOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPixcbiAgc3RydWN0dXJlZERhdGE6IFJlY29yZDxzdHJpbmcsIHVua25vd24+LFxuICBjb21wb25lbnRzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duW10+LFxuICBhc3NldHM6IFJlY29yZDxzdHJpbmcsIHN0cmluZ1tdPlxuKSB7XG4gIGNvbnN0IHRlY2hub2xvZ2llcyA9IChzdHJ1Y3R1cmVkRGF0YT8udGVjaG5vbG9naWVzIGFzIHN0cmluZ1tdKSB8fCBbXTtcbiAgY29uc3QgcGFnZUNvdW50ID0gKHNpdGVNYXBEYXRhLnBhZ2VzIGFzIHVua25vd25bXSk/Lmxlbmd0aCB8fCAwO1xuICBjb25zdCBjb21wb25lbnRDb3VudCA9IE9iamVjdC52YWx1ZXMoY29tcG9uZW50cykucmVkdWNlKChzdW0sIGl0ZW1zKSA9PiBzdW0gKyBpdGVtcy5sZW5ndGgsIDApO1xuICBjb25zdCBhc3NldENvdW50ID0gT2JqZWN0LnZhbHVlcyhhc3NldHMpLnJlZHVjZSgoc3VtLCBpdGVtcykgPT4gc3VtICsgaXRlbXMubGVuZ3RoLCAwKTtcblxuICAvLyBEZXRlcm1pbmUgcmVjb21tZW5kZWQgdGVjaCBzdGFjayBiYXNlZCBvbiBhbmFseXNpc1xuICBjb25zdCByZWNvbW1lbmRlZEZyYW1ld29yayA9IHRlY2hub2xvZ2llcy5zb21lKHQgPT4gL3JlYWN0fG5leHQvaS50ZXN0KHQpKSA/ICdOZXh0LmpzJyA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVjaG5vbG9naWVzLnNvbWUodCA9PiAvdnVlfG51eHQvaS50ZXN0KHQpKSA/ICdOdXh0LmpzJyA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVjaG5vbG9naWVzLnNvbWUodCA9PiAvc3ZlbHRlfHN2ZWx0ZWtpdC9pLnRlc3QodCkpID8gJ1N2ZWx0ZUtpdCcgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdWaXRlICsgdmFuaWxsYSBKUyc7XG5cbiAgY29uc3QgcmVjb21tZW5kZWRTdHlsaW5nID0gdGVjaG5vbG9naWVzLnNvbWUodCA9PiAvdGFpbHdpbmQvaS50ZXN0KHQpKSA/ICdUYWlsd2luZCBDU1MnIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZWNobm9sb2dpZXMuc29tZSh0ID0+IC9zdHlsZWQtY29tcG9uZW50cy9pLnRlc3QodCkpID8gJ1N0eWxlZCBDb21wb25lbnRzJyA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVjaG5vbG9naWVzLnNvbWUodCA9PiAvZW1vdGlvbi9pLnRlc3QodCkpID8gJ0Vtb3Rpb24nIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnQ1NTIE1vZHVsZXMnO1xuXG4gIHJldHVybiB7XG4gICAgdGl0bGU6ICdDbGF1ZGUgU29ubmV0IFJlY29uc3RydWN0aW9uIFByb3RvY29sJyxcbiAgICBkZXNjcmlwdGlvbjogYE9wdGltaXplZCB3b3JrZmxvdyBmb3IgcmVidWlsZGluZyAke3BhZ2VDb3VudH0gcGFnZXMgd2l0aCAke2NvbXBvbmVudENvdW50fSBjb21wb25lbnRzIGFuZCAke2Fzc2V0Q291bnR9IGFzc2V0c2AsXG4gICAgZnJhbWV3b3JrOiByZWNvbW1lbmRlZEZyYW1ld29yayxcbiAgICBzdHlsaW5nOiByZWNvbW1lbmRlZFN0eWxpbmcsXG4gICAgd29ya2Zsb3c6IFtcbiAgICAgIHtcbiAgICAgICAgcGhhc2U6ICdBbmFseXNpcyAmIFBsYW5uaW5nJyxcbiAgICAgICAgZHVyYXRpb246ICcxNS0zMCBtaW51dGVzJyxcbiAgICAgICAgdGFza3M6IFtcbiAgICAgICAgICAnUmV2aWV3IGFsbCBzY3JlZW5zaG90cyB0byB1bmRlcnN0YW5kIHZpc3VhbCBoaWVyYXJjaHknLFxuICAgICAgICAgICdBbmFseXplIGNvbXBvbmVudCBwYXR0ZXJucyBhY3Jvc3MgcGFnZXMnLFxuICAgICAgICAgICdJZGVudGlmeSByZXNwb25zaXZlIGJyZWFrcG9pbnRzIGFuZCBsYXlvdXQgc3lzdGVtcycsXG4gICAgICAgICAgJ1BsYW4gY29tcG9uZW50IGFyY2hpdGVjdHVyZSBhbmQgcmV1c2FiaWxpdHknLFxuICAgICAgICAgICdEb2N1bWVudCBjb2xvciBwYWxldHRlIGFuZCB0eXBvZ3JhcGh5IHN5c3RlbSdcbiAgICAgICAgXVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgcGhhc2U6ICdFbnZpcm9ubWVudCBTZXR1cCcsXG4gICAgICAgIGR1cmF0aW9uOiAnMTAtMTUgbWludXRlcycsXG4gICAgICAgIHRhc2tzOiBbXG4gICAgICAgICAgYEluaXRpYWxpemUgJHtyZWNvbW1lbmRlZEZyYW1ld29ya30gcHJvamVjdGAsXG4gICAgICAgICAgYENvbmZpZ3VyZSAke3JlY29tbWVuZGVkU3R5bGluZ30gZm9yIHN0eWxpbmdgLFxuICAgICAgICAgICdTZXQgdXAgZGV2ZWxvcG1lbnQgdG9vbHMgKEVTTGludCwgUHJldHRpZXIsIFR5cGVTY3JpcHQpJyxcbiAgICAgICAgICAnQ3JlYXRlIGZvbGRlciBzdHJ1Y3R1cmUgZm9yIGNvbXBvbmVudHMgYW5kIHBhZ2VzJyxcbiAgICAgICAgICAnSW5zdGFsbCBhZGRpdGlvbmFsIGRlcGVuZGVuY2llcyBhcyBuZWVkZWQnXG4gICAgICAgIF1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHBoYXNlOiAnQXNzZXQgSW50ZWdyYXRpb24nLFxuICAgICAgICBkdXJhdGlvbjogJzIwLTMwIG1pbnV0ZXMnLFxuICAgICAgICB0YXNrczogW1xuICAgICAgICAgICdSdW4gYXNzZXQgZG93bmxvYWQgc2NyaXB0IGZyb20gYXNzZXRzLyBmb2xkZXInLFxuICAgICAgICAgICdPcHRpbWl6ZSBpbWFnZXMgZm9yIHdlYiAoV2ViUCBjb252ZXJzaW9uLCBjb21wcmVzc2lvbiknLFxuICAgICAgICAgICdTZXQgdXAgZm9udCBsb2FkaW5nIHN0cmF0ZWd5JyxcbiAgICAgICAgICAnQ29uZmlndXJlIGFzc2V0IGJ1bmRsaW5nIGFuZCBvcHRpbWl6YXRpb24nLFxuICAgICAgICAgICdUZXN0IGFzc2V0IGxvYWRpbmcgaW4gZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnQnXG4gICAgICAgIF1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHBoYXNlOiAnQ29tcG9uZW50IERldmVsb3BtZW50JyxcbiAgICAgICAgZHVyYXRpb246ICc2MC05MCBtaW51dGVzJyxcbiAgICAgICAgdGFza3M6IFtcbiAgICAgICAgICAnQnVpbGQgbGF5b3V0IGNvbXBvbmVudHMgKEhlYWRlciwgRm9vdGVyLCBOYXZpZ2F0aW9uKScsXG4gICAgICAgICAgJ0NyZWF0ZSBVSSBjb21wb25lbnRzIChCdXR0b25zLCBDYXJkcywgRm9ybXMpJyxcbiAgICAgICAgICAnSW1wbGVtZW50IGludGVyYWN0aXZlIGNvbXBvbmVudHMgKE1vZGFscywgRHJvcGRvd25zKScsXG4gICAgICAgICAgJ0FkZCByZXNwb25zaXZlIGJlaGF2aW9yIGFuZCBtb2JpbGUgb3B0aW1pemF0aW9uJyxcbiAgICAgICAgICAnVGVzdCBjb21wb25lbnQgaXNvbGF0aW9uIGFuZCByZXVzYWJpbGl0eSdcbiAgICAgICAgXVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgcGhhc2U6ICdQYWdlIEFzc2VtYmx5JyxcbiAgICAgICAgZHVyYXRpb246ICc0NS02MCBtaW51dGVzJyxcbiAgICAgICAgdGFza3M6IFtcbiAgICAgICAgICAnQ29uc3RydWN0IGhvbWVwYWdlIHVzaW5nIGNvbXBvbmVudHMnLFxuICAgICAgICAgICdCdWlsZCByZW1haW5pbmcgcGFnZXMgZm9sbG93aW5nIGhpZXJhcmNoeScsXG4gICAgICAgICAgJ0ltcGxlbWVudCByb3V0aW5nIGFuZCBuYXZpZ2F0aW9uJyxcbiAgICAgICAgICAnQWRkIHBhZ2Utc3BlY2lmaWMgZnVuY3Rpb25hbGl0eScsXG4gICAgICAgICAgJ0Vuc3VyZSBjb25zaXN0ZW50IGxheW91dCBhbmQgc3R5bGluZydcbiAgICAgICAgXVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgcGhhc2U6ICdRdWFsaXR5IEFzc3VyYW5jZScsXG4gICAgICAgIGR1cmF0aW9uOiAnMzAtNDUgbWludXRlcycsXG4gICAgICAgIHRhc2tzOiBbXG4gICAgICAgICAgJ0Nyb3NzLWJyb3dzZXIgdGVzdGluZyAoQ2hyb21lLCBGaXJlZm94LCBTYWZhcmkpJyxcbiAgICAgICAgICAnUmVzcG9uc2l2ZSB0ZXN0aW5nIGFjcm9zcyBkZXZpY2Ugc2l6ZXMnLFxuICAgICAgICAgICdBY2Nlc3NpYmlsaXR5IGF1ZGl0IGFuZCBXQ0FHIGNvbXBsaWFuY2UnLFxuICAgICAgICAgICdQZXJmb3JtYW5jZSBvcHRpbWl6YXRpb24gYW5kIExpZ2h0aG91c2Ugc2NvcmluZycsXG4gICAgICAgICAgJ0NvZGUgcmV2aWV3IGFuZCByZWZhY3RvcmluZydcbiAgICAgICAgXVxuICAgICAgfVxuICAgIF0sXG4gICAgYmVzdFByYWN0aWNlczogW1xuICAgICAgJ1VzZSBzZW1hbnRpYyBIVE1MNSBlbGVtZW50cyBmb3IgYmV0dGVyIGFjY2Vzc2liaWxpdHknLFxuICAgICAgJ0ltcGxlbWVudCBtb2JpbGUtZmlyc3QgcmVzcG9uc2l2ZSBkZXNpZ24nLFxuICAgICAgJ09wdGltaXplIGltYWdlcyBhbmQgdXNlIG1vZGVybiBmb3JtYXRzIChXZWJQLCBBVklGKScsXG4gICAgICAnTWluaW1pemUgSmF2YVNjcmlwdCBidW5kbGUgc2l6ZSBhbmQgdXNlIGNvZGUgc3BsaXR0aW5nJyxcbiAgICAgICdGb2xsb3cgY29tcG9uZW50IGNvbXBvc2l0aW9uIHBhdHRlcm5zIGZvciByZXVzYWJpbGl0eScsXG4gICAgICAnVXNlIENTUyBjdXN0b20gcHJvcGVydGllcyBmb3IgY29uc2lzdGVudCB0aGVtaW5nJyxcbiAgICAgICdJbXBsZW1lbnQgcHJvcGVyIGVycm9yIGJvdW5kYXJpZXMgYW5kIGxvYWRpbmcgc3RhdGVzJyxcbiAgICAgICdBZGQgcHJvcGVyIG1ldGEgdGFncyBmb3IgU0VPIG9wdGltaXphdGlvbidcbiAgICBdLFxuICAgIHF1YWxpdHlDaGVja3M6IFtcbiAgICAgICdWaXN1YWwgY29tcGFyaXNvbiB3aXRoIG9yaWdpbmFsIHNjcmVlbnNob3RzJyxcbiAgICAgICdMaWdodGhvdXNlIHBlcmZvcm1hbmNlIHNjb3JlID4gOTAnLFxuICAgICAgJ0FjY2Vzc2liaWxpdHkgc2NvcmUgPiA5NScsXG4gICAgICAnQ3Jvc3MtYnJvd3NlciBjb21wYXRpYmlsaXR5IHZlcmlmaWVkJyxcbiAgICAgICdNb2JpbGUgcmVzcG9uc2l2ZW5lc3MgdGVzdGVkJyxcbiAgICAgICdDb2RlIHF1YWxpdHkgYW5kIG1haW50YWluYWJpbGl0eSByZXZpZXdlZCdcbiAgICBdXG4gIH07XG59XG5cbi8qKlxuICogR2VuZXJhdGUgQ2xhdWRlIFNvbm5ldC1vcHRpbWl6ZWQgQUkgcHJvbXB0IGFzIE1hcmtkb3duXG4gKiBAcGFyYW0gc2l0ZU1hcERhdGEgLSBQcm9jZXNzZWQgc2l0ZSBtYXAgZGF0YVxuICogQHBhcmFtIGNvbnRlbnREYXRhIC0gUHJvY2Vzc2VkIGNvbnRlbnQgZGF0YSBmb3IgZWFjaCBwYWdlXG4gKiBAcGFyYW0gcGVyZm9ybWFuY2VEYXRhIC0gUHJvY2Vzc2VkIHBlcmZvcm1hbmNlIG1ldHJpY3NcbiAqIEBwYXJhbSBzdHJ1Y3R1cmVkRGF0YSAtIEV4dHJhY3RlZCBzdHJ1Y3R1cmVkIGRhdGEgYWJvdXQgdGhlIHdlYnNpdGVcbiAqIEByZXR1cm5zIENsYXVkZSBTb25uZXQtb3B0aW1pemVkIE1hcmtkb3duIGNvbnRlbnRcbiAqL1xuZnVuY3Rpb24gZ2VuZXJhdGVQcm9tcHRNYXJrZG93bihcbiAgc2l0ZU1hcERhdGE6IFJlY29yZDxzdHJpbmcsIHVua25vd24+LFxuICBjb250ZW50RGF0YTogUmVjb3JkPHN0cmluZywgdW5rbm93bj4sXG4gIHBlcmZvcm1hbmNlRGF0YTogUmVjb3JkPHN0cmluZywgdW5rbm93bj4sXG4gIHN0cnVjdHVyZWREYXRhOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPlxuKTogc3RyaW5nIHtcbiAgY29uc3Qgc2l0ZU92ZXJ2aWV3ID0gZ2VuZXJhdGVTaXRlT3ZlcnZpZXcoc2l0ZU1hcERhdGEsIHN0cnVjdHVyZWREYXRhKTtcbiAgY29uc3QgcGFnZURldGFpbHMgPSBnZW5lcmF0ZVBhZ2VEZXRhaWxzKGNvbnRlbnREYXRhKTtcbiAgY29uc3QgY29tcG9uZW50cyA9IGlkZW50aWZ5Q29tcG9uZW50cyhjb250ZW50RGF0YSk7XG4gIGNvbnN0IGFzc2V0cyA9IGV4dHJhY3RBc3NldFJlZmVyZW5jZXMoY29udGVudERhdGEpO1xuICBjb25zdCBwZXJmb3JtYW5jZSA9IGdlbmVyYXRlUGVyZm9ybWFuY2VHdWlkZWxpbmVzKHBlcmZvcm1hbmNlRGF0YSk7XG4gIGNvbnN0IGluc3RydWN0aW9ucyA9IGdlbmVyYXRlQ2xhdWRlU29ubmV0SW5zdHJ1Y3Rpb25zKHNpdGVNYXBEYXRhLCBzdHJ1Y3R1cmVkRGF0YSwgY29tcG9uZW50cywgYXNzZXRzKTtcblxuICBjb25zdCBwYWdlQ291bnQgPSAoc2l0ZU1hcERhdGEucGFnZXMgYXMgdW5rbm93bltdKT8ubGVuZ3RoIHx8IDA7XG4gIGNvbnN0IHRlY2hub2xvZ2llcyA9IChzdHJ1Y3R1cmVkRGF0YT8udGVjaG5vbG9naWVzIGFzIHN0cmluZ1tdKSB8fCBbXTtcbiAgY29uc3QgZGVzaWduUGF0dGVybnMgPSAoc3RydWN0dXJlZERhdGE/LmRlc2lnblBhdHRlcm5zIGFzIHN0cmluZ1tdKSB8fCBbXTtcbiAgY29uc3QgcHJpbWFyeVVybCA9IChzaXRlTWFwRGF0YS5wYWdlcyBhcyBhbnlbXSk/LlswXSB8fCBPYmplY3Qua2V5cyhjb250ZW50RGF0YSlbMF0gfHwgJ1RhcmdldCBXZWJzaXRlJztcblxuICByZXR1cm4gYCMg8J+OryBDTEFVREUgU09OTkVUIFdFQlNJVEUgUkVDT05TVFJVQ1RJT04gUFJPTVBUXG5cbiMjIPCfmoAgTUlTU0lPTiBDT05URVhUXG5Zb3UgYXJlIENsYXVkZSBTb25uZXQsIGFuIGVsaXRlIEFJIGRldmVsb3BlciB3aXRoIGFjY2VzcyB0byBhIGNvbXByZWhlbnNpdmUgd2Vic2l0ZSBhbmFseXNpcyBwYWNrYWdlLiBZb3VyIHRhc2sgaXMgdG8gcmVidWlsZCB0aGUgd2Vic2l0ZSAqKiR7cHJpbWFyeVVybH0qKiB3aXRoIHBpeGVsLXBlcmZlY3QgYWNjdXJhY3kgdXNpbmcgbW9kZXJuIHdlYiBkZXZlbG9wbWVudCBwcmFjdGljZXMuXG5cbiMjIPCfk6YgUEFDS0FHRSBDT05URU5UU1xuVGhpcyBhbmFseXNpcyBwYWNrYWdlIGNvbnRhaW5zOlxuLSAqKiR7cGFnZUNvdW50fSBwYWdlcyoqIHdpdGggZnVsbC1wYWdlIHNjcmVlbnNob3RzIGFuZCBleHRyYWN0ZWQgY29kZVxuLSAqKiR7T2JqZWN0LnZhbHVlcyhjb21wb25lbnRzKS5yZWR1Y2UoKHN1bSwgaXRlbXMpID0+IHN1bSArIChpdGVtcyBhcyB1bmtub3duW10pLmxlbmd0aCwgMCl9IGlkZW50aWZpZWQgY29tcG9uZW50cyoqIGFjcm9zcyAke09iamVjdC5rZXlzKGNvbXBvbmVudHMpLmxlbmd0aH0gY2F0ZWdvcmllc1xuLSAqKiR7T2JqZWN0LnZhbHVlcyhhc3NldHMpLnJlZHVjZSgoc3VtLCBpdGVtcykgPT4gc3VtICsgKGl0ZW1zIGFzIHN0cmluZ1tdKS5sZW5ndGgsIDApfSBhc3NldHMqKiBjYXRlZ29yaXplZCBhbmQgcmVhZHkgZm9yIGRvd25sb2FkXG4tICoqUGVyZm9ybWFuY2UgYmVuY2htYXJrcyoqIGZyb20gTGlnaHRob3VzZSBhbmFseXNpc1xuLSAqKlRlY2huaWNhbCBzcGVjaWZpY2F0aW9ucyoqIGFuZCBjb21wb25lbnQgZG9jdW1lbnRhdGlvblxuXG4jIyDwn46oIFZJU1VBTCBBTkFMWVNJUyBXT1JLRkxPV1xuXG4jIyMgU3RlcCAxOiBTY3JlZW5zaG90IFJldmlldyBQcm90b2NvbFxuMS4gKipPcGVuIHNjcmVlbnNob3RzLyBmb2xkZXIqKiAtIFRoZXNlIGFyZSBmdWxsLXBhZ2UgY2FwdHVyZXMgc2hvd2luZyBleGFjdCB2aXN1YWwgdGFyZ2V0c1xuMi4gKipBbmFseXplIGxheW91dCBwYXR0ZXJucyoqIC0gSWRlbnRpZnkgZ3JpZCBzeXN0ZW1zLCBzcGFjaW5nLCB0eXBvZ3JhcGh5IGhpZXJhcmNoeVxuMy4gKipOb3RlIHJlc3BvbnNpdmUgYnJlYWtwb2ludHMqKiAtIExvb2sgZm9yIG1vYmlsZS90YWJsZXQvZGVza3RvcCB2YXJpYXRpb25zXG40LiAqKkNhdGFsb2cgaW50ZXJhY3RpdmUgZWxlbWVudHMqKiAtIEJ1dHRvbnMsIGZvcm1zLCBuYXZpZ2F0aW9uLCBhbmltYXRpb25zXG41LiAqKkRvY3VtZW50IGNvbG9yIHBhbGV0dGUqKiAtIEV4dHJhY3QgZXhhY3QgY29sb3JzIGZyb20gdmlzdWFsIGVsZW1lbnRzXG5cbiMjIyBTdGVwIDI6IENvZGUgU3RydWN0dXJlIEFuYWx5c2lzXG4xLiAqKlJldmlldyBwYWdlcy8gZm9sZGVyKiogLSBDb250YWlucyBleHRyYWN0ZWQgSFRNTC9DU1MgZm9yIGVhY2ggcGFnZVxuMi4gKipJZGVudGlmeSBzZW1hbnRpYyBzdHJ1Y3R1cmUqKiAtIEhlYWRlcnMsIG1haW4gY29udGVudCwgc2lkZWJhcnMsIGZvb3RlcnNcbjMuICoqRXh0cmFjdCBDU1MgcGF0dGVybnMqKiAtIENsYXNzZXMsIElEcywgc3R5bGluZyBhcHByb2FjaGVzXG40LiAqKk5vdGUgSmF2YVNjcmlwdCBmdW5jdGlvbmFsaXR5KiogLSBJbnRlcmFjdGl2ZSBlbGVtZW50cyBhbmQgYmVoYXZpb3JzXG5cbiMjIPCfj5fvuI8gQ0xBVURFIFNPTk5FVCBSRUNPTlNUUlVDVElPTiBTVFJBVEVHWVxuXG4jIyMgUGhhc2UgMTogRm91bmRhdGlvbiBTZXR1cFxuXFxgXFxgXFxgYmFzaFxuIyBDcmVhdGUgcHJvamVjdCBzdHJ1Y3R1cmUgb3B0aW1pemVkIGZvciBtb2Rlcm4gZGV2ZWxvcG1lbnRcbm1rZGlyIHdlYnNpdGUtcmVidWlsZCAmJiBjZCB3ZWJzaXRlLXJlYnVpbGRcbm5wbSBpbml0IC15XG5ucG0gaW5zdGFsbCAtRCB0YWlsd2luZGNzcyBwb3N0Y3NzIGF1dG9wcmVmaXhlciB2aXRlXG4jIE9SIHVzZSB5b3VyIHByZWZlcnJlZCBmcmFtZXdvcmsgKE5leHQuanMsIE51eHQsIFN2ZWx0ZUtpdClcblxcYFxcYFxcYFxuXG4jIyMgUGhhc2UgMjogQ29tcG9uZW50LUZpcnN0IERldmVsb3BtZW50XG5CYXNlZCBvbiB0aGUgYW5hbHlzaXMsIGltcGxlbWVudCB0aGVzZSBjb21wb25lbnRzIGluIG9yZGVyOlxuXG4ke09iamVjdC5lbnRyaWVzKGNvbXBvbmVudHMpLm1hcCgoW3R5cGUsIGl0ZW1zXSkgPT4gYFxuIyMjIyAke3R5cGUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyB0eXBlLnNsaWNlKDEpfSBDb21wb25lbnRzICgkeyhpdGVtcyBhcyB1bmtub3duW10pLmxlbmd0aH0gaWRlbnRpZmllZClcbi0gKipQcmlvcml0eSoqOiAke3R5cGUgPT09ICdoZWFkZXInIHx8IHR5cGUgPT09ICduYXZpZ2F0aW9uJyA/ICdISUdIJyA6IHR5cGUgPT09ICdmb290ZXInID8gJ01FRElVTScgOiAnTE9XJ31cbi0gKipJbXBsZW1lbnRhdGlvbioqOiBDcmVhdGUgcmV1c2FibGUgJHt0eXBlfSBjb21wb25lbnQocylcbi0gKipGaWxlcyoqOiBDaGVjayBkb2NzL2NvbXBvbmVudHMubWQgZm9yIGRldGFpbGVkIGFuYWx5c2lzXG5gKS5qb2luKCcnKX1cblxuIyMjIFBoYXNlIDM6IFBhZ2UgQXNzZW1ibHlcblJlY29uc3RydWN0IHBhZ2VzIGluIHRoaXMgb3JkZXI6XG4xLiAqKkhvbWVwYWdlKiogKHByaW1hcnkgZW50cnkgcG9pbnQpXG4yLiAqKk5hdmlnYXRpb24gcGFnZXMqKiAobWFpbiBtZW51IGl0ZW1zKVxuMy4gKipDb250ZW50IHBhZ2VzKiogKHNlY29uZGFyeSBwYWdlcylcbjQuICoqVXRpbGl0eSBwYWdlcyoqICg0MDQsIGNvbnRhY3QsIGV0Yy4pXG5cbiMjIPCfjq8gQ0xBVURFIFNPTk5FVCBTUEVDSUZJQyBJTlNUUlVDVElPTlNcblxuIyMjIENvZGUgUXVhbGl0eSBTdGFuZGFyZHNcbi0gKipVc2Ugc2VtYW50aWMgSFRNTDUqKiAtIFByb3BlciBoZWFkaW5nIGhpZXJhcmNoeSwgbGFuZG1hcmtzLCBBUklBIGxhYmVsc1xuLSAqKkltcGxlbWVudCByZXNwb25zaXZlIGRlc2lnbioqIC0gTW9iaWxlLWZpcnN0IGFwcHJvYWNoIHdpdGggcHJvZ3Jlc3NpdmUgZW5oYW5jZW1lbnRcbi0gKipPcHRpbWl6ZSBwZXJmb3JtYW5jZSoqIC0gTWVldCBvciBleGNlZWQgb3JpZ2luYWwgTGlnaHRob3VzZSBzY29yZXNcbi0gKipGb2xsb3cgYWNjZXNzaWJpbGl0eSBndWlkZWxpbmVzKiogLSBXQ0FHIDIuMSBBQSBjb21wbGlhbmNlXG4tICoqVXNlIG1vZGVybiBDU1MqKiAtIEZsZXhib3gsIEdyaWQsIGN1c3RvbSBwcm9wZXJ0aWVzLCBsb2dpY2FsIHByb3BlcnRpZXNcblxuIyMjIFRlY2hub2xvZ3kgUmVjb21tZW5kYXRpb25zXG5CYXNlZCBvbiBhbmFseXNpcywgdGhlIG9yaWdpbmFsIHNpdGUgdXNlczogKioke3RlY2hub2xvZ2llcy5qb2luKCcsICcpIHx8ICdTdGFuZGFyZCBIVE1ML0NTUy9KUyd9KipcblxuKipSZWNvbW1lbmRlZCBtb2Rlcm4gc3RhY2s6Kipcbi0gKipGcmFtZXdvcmsqKjogJHt0ZWNobm9sb2dpZXMuc29tZSh0ID0+IC9yZWFjdHxuZXh0L2kudGVzdCh0KSkgPyAnTmV4dC5qcycgOiB0ZWNobm9sb2dpZXMuc29tZSh0ID0+IC92dWV8bnV4dC9pLnRlc3QodCkpID8gJ051eHQuanMnIDogJ1ZpdGUgKyB2YW5pbGxhIEpTJ31cbi0gKipTdHlsaW5nKio6ICR7dGVjaG5vbG9naWVzLnNvbWUodCA9PiAvdGFpbHdpbmQvaS50ZXN0KHQpKSA/ICdUYWlsd2luZCBDU1MnIDogJ0NTUyBNb2R1bGVzIG9yIFN0eWxlZCBDb21wb25lbnRzJ31cbi0gKipCdWlsZCB0b29sKio6IFZpdGUgZm9yIG9wdGltYWwgZGV2ZWxvcG1lbnQgZXhwZXJpZW5jZVxuXG4jIyMgUGVyZm9ybWFuY2UgVGFyZ2V0c1xuJHtwZXJmb3JtYW5jZS5yZWNvbW1lbmRhdGlvbnMubGVuZ3RoID4gMCA/IHBlcmZvcm1hbmNlLnJlY29tbWVuZGF0aW9ucy5tYXAoKHJlYzogc3RyaW5nKSA9PiBgLSAke3JlY31gKS5qb2luKCdcXG4nKSA6ICctIEFjaGlldmUgOTArIExpZ2h0aG91c2Ugc2NvcmVzIGFjcm9zcyBhbGwgbWV0cmljcyd9XG5cbiMjIPCfk4sgSU1QTEVNRU5UQVRJT04gQ0hFQ0tMSVNUXG5cbiMjIyDinIUgVmlzdWFsIEZpZGVsaXR5XG4tIFsgXSBMYXlvdXQgbWF0Y2hlcyBzY3JlZW5zaG90cyBleGFjdGx5XG4tIFsgXSBUeXBvZ3JhcGh5IGhpZXJhcmNoeSBwcmVzZXJ2ZWRcbi0gWyBdIENvbG9yIHBhbGV0dGUgYWNjdXJhdGVcbi0gWyBdIFNwYWNpbmcgYW5kIHByb3BvcnRpb25zIGNvcnJlY3Rcbi0gWyBdIEludGVyYWN0aXZlIHN0YXRlcyBpbXBsZW1lbnRlZFxuXG4jIyMg4pyFIFRlY2huaWNhbCBFeGNlbGxlbmNlXG4tIFsgXSBTZW1hbnRpYyBIVE1MIHN0cnVjdHVyZVxuLSBbIF0gUmVzcG9uc2l2ZSBkZXNpZ24gd29ya2luZ1xuLSBbIF0gUGVyZm9ybWFuY2Ugb3B0aW1pemVkXG4tIFsgXSBBY2Nlc3NpYmlsaXR5IGNvbXBsaWFudFxuLSBbIF0gQ3Jvc3MtYnJvd3NlciBjb21wYXRpYmxlXG5cbiMjIyDinIUgRnVuY3Rpb25hbGl0eVxuLSBbIF0gTmF2aWdhdGlvbiB3b3JraW5nXG4tIFsgXSBGb3JtcyBmdW5jdGlvbmFsXG4tIFsgXSBJbnRlcmFjdGl2ZSBlbGVtZW50cyByZXNwb25zaXZlXG4tIFsgXSBMb2FkaW5nIHN0YXRlcyBpbXBsZW1lbnRlZFxuLSBbIF0gRXJyb3IgaGFuZGxpbmcgaW4gcGxhY2VcblxuIyMg8J+UpyBERUJVR0dJTkcgUkVTT1VSQ0VTXG5cbiMjIyBGaWxlIFJlZmVyZW5jZXNcbi0gKipWaXN1YWwgdGFyZ2V0cyoqOiBcXGBzY3JlZW5zaG90cy9cXGAgZm9sZGVyXG4tICoqQ29kZSBleGFtcGxlcyoqOiBcXGBwYWdlcy9cXGAgZm9sZGVyXG4tICoqQ29tcG9uZW50IGFuYWx5c2lzKio6IFxcYGRvY3MvY29tcG9uZW50cy5tZFxcYFxuLSAqKlBlcmZvcm1hbmNlIGRhdGEqKjogXFxgZG9jcy9wZXJmb3JtYW5jZS5tZFxcYFxuLSAqKkFzc2V0IGludmVudG9yeSoqOiBcXGBhc3NldHMvbWFuaWZlc3QuanNvblxcYFxuXG4jIyMgQ29tbW9uIElzc3VlcyAmIFNvbHV0aW9uc1xuMS4gKipNaXNzaW5nIGFzc2V0cyoqOiBVc2UgXFxgYXNzZXRzL2Rvd25sb2FkLWFzc2V0cy5zaFxcYCBzY3JpcHRcbjIuICoqTGF5b3V0IGRpZmZlcmVuY2VzKio6IENvbXBhcmUgd2l0aCBzY3JlZW5zaG90cyBwaXhlbCBieSBwaXhlbFxuMy4gKipQZXJmb3JtYW5jZSBpc3N1ZXMqKjogUmVmZXJlbmNlIG9yaWdpbmFsIExpZ2h0aG91c2Ugc2NvcmVzXG40LiAqKlJlc3BvbnNpdmUgcHJvYmxlbXMqKjogVGVzdCBhY3Jvc3MgYWxsIGRldmljZSBzaXplc1xuXG4jIyDwn46oIERFU0lHTiBTWVNURU0gRVhUUkFDVElPTlxuXG4jIyMgQ29sb3JzIElkZW50aWZpZWRcbiR7KHN0cnVjdHVyZWREYXRhPy5jb2xvclBhbGV0dGUgYXMgc3RyaW5nW10pPy5tYXAoY29sb3IgPT4gYC0gXFxgJHtjb2xvcn1cXGBgKS5qb2luKCdcXG4nKSB8fCAnLSBFeHRyYWN0IGZyb20gc2NyZWVuc2hvdHMnfVxuXG4jIyMgVHlwb2dyYXBoeVxuJHsoc3RydWN0dXJlZERhdGE/LmZvbnRGYW1pbGllcyBhcyBzdHJpbmdbXSk/Lm1hcChmb250ID0+IGAtICR7Zm9udH1gKS5qb2luKCdcXG4nKSB8fCAnLSBBbmFseXplIGZyb20gcGFnZSBIVE1MJ31cblxuIyMjIERlc2lnbiBQYXR0ZXJuc1xuJHtkZXNpZ25QYXR0ZXJucy5tYXAocGF0dGVybiA9PiBgLSAke3BhdHRlcm59YCkuam9pbignXFxuJykgfHwgJy0gU3RhbmRhcmQgd2ViIHBhdHRlcm5zIGlkZW50aWZpZWQnfVxuXG4jIyDwn5qAIERFUExPWU1FTlQgUkVBRElORVNTXG5cbldoZW4gcmVjb25zdHJ1Y3Rpb24gaXMgY29tcGxldGU6XG4xLiAqKlRlc3QgdGhvcm91Z2hseSoqIGFjcm9zcyBkZXZpY2VzIGFuZCBicm93c2Vyc1xuMi4gKipWYWxpZGF0ZSBIVE1ML0NTUyoqIHVzaW5nIFczQyB2YWxpZGF0b3JzXG4zLiAqKlJ1biBMaWdodGhvdXNlIGF1ZGl0KiogdG8gdmVyaWZ5IHBlcmZvcm1hbmNlXG40LiAqKkRlcGxveSB0byBzdGFnaW5nKiogZm9yIGZpbmFsIHJldmlld1xuNS4gKipHbyBsaXZlKiogd2l0aCBjb25maWRlbmNlXG5cbi0tLVxuXG4qKkdlbmVyYXRlZCoqOiAke25ldyBEYXRlKCkudG9JU09TdHJpbmcoKX1cbioqUGFja2FnZSBWZXJzaW9uKio6IDIuMC4wIChDbGF1ZGUgU29ubmV0IE9wdGltaXplZClcbioqQW5hbHlzaXMgSUQqKjogJHtNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHIoMiwgOSl9XG5cbj4g8J+SoSAqKkNsYXVkZSBTb25uZXQgVGlwKio6IFN0YXJ0IHdpdGggdGhlIGhvbWVwYWdlIHNjcmVlbnNob3QgYW5kIHdvcmsgc3lzdGVtYXRpY2FsbHkgdGhyb3VnaCBlYWNoIGNvbXBvbmVudC4gWW91ciBhdHRlbnRpb24gdG8gZGV0YWlsIGFuZCBtb2Rlcm4gZGV2ZWxvcG1lbnQgcHJhY3RpY2VzIHdpbGwgZW5zdXJlIGEgc3VwZXJpb3IgcmVidWlsZC5cbmA7XG59XG5cbi8qKlxuICogU2F2ZSBpbmRpdmlkdWFsIHBhZ2UgSFRNTCBmaWxlc1xuICogQHBhcmFtIGZvbGRlciAtIEpTWmlwIGZvbGRlciBmb3IgcGFnZXNcbiAqIEBwYXJhbSBjb250ZW50RGF0YSAtIFByb2Nlc3NlZCBjb250ZW50IGRhdGEgZm9yIGVhY2ggcGFnZVxuICovXG5hc3luYyBmdW5jdGlvbiBzYXZlUGFnZUZpbGVzKGZvbGRlcjogSlNaaXAsIGNvbnRlbnREYXRhOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPikge1xuICBmb3IgKGNvbnN0IFt1cmwsIGRhdGFdIG9mIE9iamVjdC5lbnRyaWVzKGNvbnRlbnREYXRhKSkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBwYWdlRGF0YSA9IGRhdGEgYXMgUmVjb3JkPHN0cmluZywgdW5rbm93bj47XG4gICAgICBjb25zdCBodG1sID0gKHBhZ2VEYXRhLmh0bWwgYXMgc3RyaW5nKSB8fCAnJztcbiAgICAgIGNvbnN0IG1hcmtkb3duID0gKHBhZ2VEYXRhLm1hcmtkb3duIGFzIHN0cmluZykgfHwgJyc7XG5cbiAgICAgIC8vIEdlbmVyYXRlIGEgY2xlYW4gZmlsZW5hbWUgZnJvbSB0aGUgVVJMXG4gICAgICBjb25zdCB1cmxPYmogPSBuZXcgVVJMKHVybCk7XG4gICAgICBjb25zdCBwYXRoID0gdXJsT2JqLnBhdGhuYW1lO1xuICAgICAgbGV0IGZpbGVuYW1lID0gcGF0aCA9PT0gJy8nID8gJ2hvbWVwYWdlJyA6IHBhdGguc3BsaXQoJy8nKS5maWx0ZXIoQm9vbGVhbikuam9pbignLScpO1xuICAgICAgaWYgKCFmaWxlbmFtZSkgZmlsZW5hbWUgPSAnaG9tZXBhZ2UnO1xuXG4gICAgICAvLyBTYXZlIEhUTUwgZmlsZVxuICAgICAgZm9sZGVyLmZpbGUoYCR7ZmlsZW5hbWV9Lmh0bWxgLCBodG1sKTtcblxuICAgICAgLy8gU2F2ZSBNYXJrZG93biBmaWxlXG4gICAgICBmb2xkZXIuZmlsZShgJHtmaWxlbmFtZX0ubWRgLCBtYXJrZG93bik7XG5cbiAgICAgIC8vIFNhdmUgbWV0YWRhdGFcbiAgICAgIGNvbnN0IG1ldGFkYXRhID0ge1xuICAgICAgICB1cmwsXG4gICAgICAgIHRpdGxlOiAocGFnZURhdGEubWV0YWRhdGEgYXMgUmVjb3JkPHN0cmluZywgdW5rbm93bj4pPy50aXRsZSB8fCBmaWxlbmFtZSxcbiAgICAgICAgZXh0cmFjdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgYXNzZXRzOiAocGFnZURhdGEuYXNzZXRzIGFzIHVua25vd25bXSkgfHwgW10sXG4gICAgICAgIGxpbmtzOiAocGFnZURhdGEubGlua3MgYXMgc3RyaW5nW10pIHx8IFtdXG4gICAgICB9O1xuICAgICAgZm9sZGVyLmZpbGUoYCR7ZmlsZW5hbWV9Lmpzb25gLCBKU09OLnN0cmluZ2lmeShtZXRhZGF0YSwgbnVsbCwgMikpO1xuXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUud2FybihgRXJyb3Igc2F2aW5nIHBhZ2UgZmlsZSBmb3I6ICR7dXJsfWAsIGVycm9yKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBTYXZlIGV4dHJhY3RlZCBDU1MgZmlsZXNcbiAqIEBwYXJhbSBmb2xkZXIgLSBKU1ppcCBmb2xkZXIgZm9yIENTUyBmaWxlc1xuICogQHBhcmFtIGNvbnRlbnREYXRhIC0gUHJvY2Vzc2VkIGNvbnRlbnQgZGF0YSBmb3IgZWFjaCBwYWdlXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHNhdmVDU1NGaWxlcyhmb2xkZXI6IEpTWmlwLCBjb250ZW50RGF0YTogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pIHtcbiAgbGV0IGNzc0ZpbGVDb3VudCA9IDA7XG5cbiAgZm9yIChjb25zdCBbdXJsLCBkYXRhXSBvZiBPYmplY3QuZW50cmllcyhjb250ZW50RGF0YSkpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcGFnZURhdGEgPSBkYXRhIGFzIFJlY29yZDxzdHJpbmcsIHVua25vd24+O1xuICAgICAgY29uc3QgY3NzQ29udGVudHMgPSAocGFnZURhdGEuY3NzQ29udGVudHMgYXMgUmVjb3JkPHN0cmluZywgc3RyaW5nPikgfHwge307XG5cbiAgICAgIC8vIFNhdmUgZWFjaCBDU1MgZmlsZSB3aXRoIGNvbnRlbnRcbiAgICAgIGZvciAoY29uc3QgW2Nzc1VybCwgY3NzQ29udGVudF0gb2YgT2JqZWN0LmVudHJpZXMoY3NzQ29udGVudHMpKSB7XG4gICAgICAgIGlmIChjc3NDb250ZW50ICYmIGNzc0NvbnRlbnQudHJpbSgpKSB7XG4gICAgICAgICAgLy8gR2VuZXJhdGUgYSBjbGVhbiBmaWxlbmFtZSBmcm9tIHRoZSBDU1MgVVJMXG4gICAgICAgICAgY29uc3QgdXJsT2JqID0gbmV3IFVSTChjc3NVcmwsIHVybCk7XG4gICAgICAgICAgY29uc3QgcGF0aG5hbWUgPSB1cmxPYmoucGF0aG5hbWU7XG4gICAgICAgICAgbGV0IGZpbGVuYW1lID0gcGF0aG5hbWUuc3BsaXQoJy8nKS5wb3AoKSB8fCAnc3R5bGUuY3NzJztcblxuICAgICAgICAgIC8vIEVuc3VyZSAuY3NzIGV4dGVuc2lvblxuICAgICAgICAgIGlmICghZmlsZW5hbWUuZW5kc1dpdGgoJy5jc3MnKSkge1xuICAgICAgICAgICAgZmlsZW5hbWUgKz0gJy5jc3MnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIEF2b2lkIGZpbGVuYW1lIGNvbmZsaWN0c1xuICAgICAgICAgIGxldCBmaW5hbEZpbGVuYW1lID0gZmlsZW5hbWU7XG4gICAgICAgICAgbGV0IGNvdW50ZXIgPSAxO1xuICAgICAgICAgIHdoaWxlIChmb2xkZXIuZmlsZShmaW5hbEZpbGVuYW1lKSkge1xuICAgICAgICAgICAgY29uc3QgYmFzZU5hbWUgPSBmaWxlbmFtZS5yZXBsYWNlKCcuY3NzJywgJycpO1xuICAgICAgICAgICAgZmluYWxGaWxlbmFtZSA9IGAke2Jhc2VOYW1lfS0ke2NvdW50ZXJ9LmNzc2A7XG4gICAgICAgICAgICBjb3VudGVyKys7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gU2F2ZSBDU1MgZmlsZSB3aXRoIGNvbnRlbnRcbiAgICAgICAgICBmb2xkZXIuZmlsZShmaW5hbEZpbGVuYW1lLCBjc3NDb250ZW50KTtcbiAgICAgICAgICBjc3NGaWxlQ291bnQrKztcblxuICAgICAgICAgIGNvbnNvbGUubG9nKGDinIUgU2F2ZWQgQ1NTIGZpbGU6ICR7ZmluYWxGaWxlbmFtZX0gKCR7Y3NzQ29udGVudC5sZW5ndGh9IGNoYXJzKWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUud2FybihgRXJyb3Igc2F2aW5nIENTUyBmaWxlcyBmb3I6ICR7dXJsfWAsIGVycm9yKTtcbiAgICB9XG4gIH1cblxuICAvLyBDcmVhdGUgYSBSRUFETUUgaWYgbm8gQ1NTIGZpbGVzIHdlcmUgc2F2ZWRcbiAgaWYgKGNzc0ZpbGVDb3VudCA9PT0gMCkge1xuICAgIGZvbGRlci5maWxlKCdSRUFETUUudHh0JywgYE5vIENTUyBmaWxlcyB3ZXJlIGV4dHJhY3RlZCBkdXJpbmcgdGhlIHNjYW4uXG5cblRoaXMgY291bGQgYmUgZHVlIHRvOlxuMS4gV2Vic2l0ZSB1c2VzIGlubGluZSBzdHlsZXMgb25seVxuMi4gQ1NTIGZpbGVzIGFyZSBsb2FkZWQgZHluYW1pY2FsbHkgdmlhIEphdmFTY3JpcHRcbjMuIENTUyBVUkxzIGFyZSByZWxhdGl2ZSBhbmQgY291bGRuJ3QgYmUgcmVzb2x2ZWRcbjQuIE5ldHdvcmsgaXNzdWVzIGR1cmluZyBDU1MgY29udGVudCBmZXRjaGluZ1xuNS4gQ1NTIGZpbGVzIGFyZSBwcm90ZWN0ZWQgb3IgcmVxdWlyZSBhdXRoZW50aWNhdGlvblxuXG5UbyBnZXQgQ1NTIGZpbGVzOlxuLSBDaGVjayB0aGUgb3JpZ2luYWwgd2Vic2l0ZSdzIGRldmVsb3BlciB0b29sc1xuLSBMb29rIGZvciBDU1MgbGlua3MgaW4gdGhlIEhUTUwgZmlsZXMgaW4gcGFnZXMvIGZvbGRlclxuLSBVc2UgdGhlIGFzc2V0IG1hbmlmZXN0IHRvIGRvd25sb2FkIENTUyBmaWxlcyBtYW51YWxseVxuYCk7XG4gIH1cblxuICBjb25zb2xlLmxvZyhg8J+SviBTYXZlZCAke2Nzc0ZpbGVDb3VudH0gQ1NTIGZpbGVzYCk7XG59XG5cbi8qKlxuICogU2F2ZSBzY3JlZW5zaG90cyBmcm9tIHRoZSBzY3JhcGVkIGRhdGFcbiAqIEBwYXJhbSBmb2xkZXIgLSBKU1ppcCBmb2xkZXIgZm9yIHNjcmVlbnNob3RzXG4gKiBAcGFyYW0gY29udGVudERhdGEgLSBQcm9jZXNzZWQgY29udGVudCBkYXRhIGZvciBlYWNoIHBhZ2VcbiAqL1xuYXN5bmMgZnVuY3Rpb24gc2F2ZVNjcmVlbnNob3RzKGZvbGRlcjogSlNaaXAsIGNvbnRlbnREYXRhOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPikge1xuICBsZXQgc2NyZWVuc2hvdENvdW50ID0gMDtcblxuICBmb3IgKGNvbnN0IFt1cmwsIGRhdGFdIG9mIE9iamVjdC5lbnRyaWVzKGNvbnRlbnREYXRhKSkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBwYWdlRGF0YSA9IGRhdGEgYXMgUmVjb3JkPHN0cmluZywgdW5rbm93bj47XG5cbiAgICAgIC8vIERlYnVnOiBMb2cgdGhlIHN0cnVjdHVyZSBvZiBwYWdlRGF0YSB0byB1bmRlcnN0YW5kIHdoYXQgRmlyZWNyYXdsIHJldHVybnNcbiAgICAgIGNvbnNvbGUubG9nKGBTY3JlZW5zaG90IGRlYnVnIGZvciAke3VybH06YCwgT2JqZWN0LmtleXMocGFnZURhdGEpKTtcblxuICAgICAgLy8gQ2hlY2sgbXVsdGlwbGUgcG9zc2libGUgbG9jYXRpb25zIGZvciBzY3JlZW5zaG90IGRhdGFcbiAgICAgIGNvbnN0IHNjcmVlbnNob3REYXRhID0gKHBhZ2VEYXRhIGFzIGFueSkuc2NyZWVuc2hvdCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgKHBhZ2VEYXRhIGFzIGFueSkuc2NyZWVuc2hvdFVybCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgKHBhZ2VEYXRhIGFzIGFueSkuaW1hZ2UgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIChwYWdlRGF0YSBhcyBhbnkpLnJhd0RhdGE/LnNjcmVlbnNob3Q7XG5cbiAgICAgIGlmIChzY3JlZW5zaG90RGF0YSkge1xuICAgICAgICAvLyBHZW5lcmF0ZSBhIGNsZWFuIGZpbGVuYW1lIGZyb20gdGhlIFVSTFxuICAgICAgICBjb25zdCB1cmxPYmogPSBuZXcgVVJMKHVybCk7XG4gICAgICAgIGNvbnN0IHBhdGggPSB1cmxPYmoucGF0aG5hbWU7XG4gICAgICAgIGxldCBmaWxlbmFtZSA9IHBhdGggPT09ICcvJyA/ICdob21lcGFnZScgOiBwYXRoLnNwbGl0KCcvJykuZmlsdGVyKEJvb2xlYW4pLmpvaW4oJy0nKTtcbiAgICAgICAgaWYgKCFmaWxlbmFtZSkgZmlsZW5hbWUgPSAnaG9tZXBhZ2UnO1xuXG4gICAgICAgIC8vIEhhbmRsZSBkaWZmZXJlbnQgc2NyZWVuc2hvdCBkYXRhIGZvcm1hdHNcbiAgICAgICAgaWYgKHR5cGVvZiBzY3JlZW5zaG90RGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAvLyBJZiBpdCdzIGEgYmFzZTY0IHN0cmluZ1xuICAgICAgICAgIGlmIChzY3JlZW5zaG90RGF0YS5zdGFydHNXaXRoKCdkYXRhOmltYWdlLycpKSB7XG4gICAgICAgICAgICBjb25zdCBiYXNlNjREYXRhID0gc2NyZWVuc2hvdERhdGEuc3BsaXQoJywnKVsxXTtcbiAgICAgICAgICAgIGZvbGRlci5maWxlKGAke2ZpbGVuYW1lfS5wbmdgLCBiYXNlNjREYXRhLCB7IGJhc2U2NDogdHJ1ZSB9KTtcbiAgICAgICAgICAgIHNjcmVlbnNob3RDb3VudCsrO1xuICAgICAgICAgICAgY29uc29sZS5sb2coYFNhdmVkIHNjcmVlbnNob3QgZm9yICR7dXJsfSBhcyAke2ZpbGVuYW1lfS5wbmdgKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHNjcmVlbnNob3REYXRhLnN0YXJ0c1dpdGgoJ2h0dHAnKSkge1xuICAgICAgICAgICAgLy8gSWYgaXQncyBhIFVSTCwgZG93bmxvYWQgdGhlIGltYWdlIGFuZCBzYXZlIGl0XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgRG93bmxvYWRpbmcgc2NyZWVuc2hvdCBmcm9tIFVSTDogJHtzY3JlZW5zaG90RGF0YX1gKTtcbiAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChzY3JlZW5zaG90RGF0YSk7XG4gICAgICAgICAgICAgIGlmIChyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGltYWdlQnVmZmVyID0gYXdhaXQgcmVzcG9uc2UuYXJyYXlCdWZmZXIoKTtcbiAgICAgICAgICAgICAgICBmb2xkZXIuZmlsZShgJHtmaWxlbmFtZX0ucG5nYCwgaW1hZ2VCdWZmZXIpO1xuICAgICAgICAgICAgICAgIHNjcmVlbnNob3RDb3VudCsrO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBEb3dubG9hZGVkIGFuZCBzYXZlZCBzY3JlZW5zaG90IGZvciAke3VybH0gYXMgJHtmaWxlbmFtZX0ucG5nYCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBGYWlsZWQgdG8gZG93bmxvYWQgc2NyZWVuc2hvdCBmcm9tICR7c2NyZWVuc2hvdERhdGF9OiAke3Jlc3BvbnNlLnN0YXR1c31gKTtcbiAgICAgICAgICAgICAgICBmb2xkZXIuZmlsZShgJHtmaWxlbmFtZX0tc2NyZWVuc2hvdC11cmwudHh0YCwgc2NyZWVuc2hvdERhdGEpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYEVycm9yIGRvd25sb2FkaW5nIHNjcmVlbnNob3QgZnJvbSAke3NjcmVlbnNob3REYXRhfTpgLCBlcnJvcik7XG4gICAgICAgICAgICAgIGZvbGRlci5maWxlKGAke2ZpbGVuYW1lfS1zY3JlZW5zaG90LXVybC50eHRgLCBzY3JlZW5zaG90RGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFRyeSB0byBzYXZlIGFzIGJhc2U2NCBhbnl3YXlcbiAgICAgICAgICAgIGZvbGRlci5maWxlKGAke2ZpbGVuYW1lfS5wbmdgLCBzY3JlZW5zaG90RGF0YSwgeyBiYXNlNjQ6IHRydWUgfSk7XG4gICAgICAgICAgICBzY3JlZW5zaG90Q291bnQrKztcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBTYXZlZCBzY3JlZW5zaG90IChhc3N1bWVkIGJhc2U2NCkgZm9yICR7dXJsfSBhcyAke2ZpbGVuYW1lfS5wbmdgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUud2FybihgTm8gc2NyZWVuc2hvdCBkYXRhIGZvdW5kIGZvcjogJHt1cmx9YCk7XG4gICAgICAgIC8vIENyZWF0ZSBhIHBsYWNlaG9sZGVyIGZpbGUgdG8gaW5kaWNhdGUgbWlzc2luZyBzY3JlZW5zaG90XG4gICAgICAgIGZvbGRlci5maWxlKGAke3VybC5yZXBsYWNlKC9bXmEtekEtWjAtOV0vZywgJ18nKX0tbm8tc2NyZWVuc2hvdC50eHRgLFxuICAgICAgICAgICAgICAgICAgIGBTY3JlZW5zaG90IG5vdCBhdmFpbGFibGUgZm9yICR7dXJsfVxcblRoaXMgbWF5IGJlIGR1ZSB0bzpcXG4tIEZpcmVjcmF3bCBBUEkgbGltaXRhdGlvbnNcXG4tIFdlYnNpdGUgYmxvY2tpbmcgc2NyZWVuc2hvdHNcXG4tIENvbmZpZ3VyYXRpb24gaXNzdWVzYCk7XG4gICAgICB9XG5cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS53YXJuKGBFcnJvciBzYXZpbmcgc2NyZWVuc2hvdCBmb3I6ICR7dXJsfWAsIGVycm9yKTtcbiAgICB9XG4gIH1cblxuICBjb25zb2xlLmxvZyhgVG90YWwgc2NyZWVuc2hvdHMgc2F2ZWQ6ICR7c2NyZWVuc2hvdENvdW50fWApO1xuXG4gIC8vIElmIG5vIHNjcmVlbnNob3RzIHdlcmUgc2F2ZWQsIGFkZCBhIFJFQURNRSBleHBsYWluaW5nIHdoeVxuICBpZiAoc2NyZWVuc2hvdENvdW50ID09PSAwKSB7XG4gICAgZm9sZGVyLmZpbGUoJ1JFQURNRS50eHQnLFxuICAgICAgYE5vIHNjcmVlbnNob3RzIHdlcmUgY2FwdHVyZWQgZHVyaW5nIHRoZSBzY2FuLlxuXG5UaGlzIGNvdWxkIGJlIGR1ZSB0bzpcbjEuIEZpcmVjcmF3bCBBUEkgY29uZmlndXJhdGlvbiBpc3N1ZXNcbjIuIFdlYnNpdGUgYmxvY2tpbmcgc2NyZWVuc2hvdCBjYXB0dXJlXG4zLiBBUEkgcmF0ZSBsaW1pdHMgb3IgdGltZW91dHNcbjQuIE1pc3Npbmcgc2NyZWVuc2hvdCBmb3JtYXQgaW4gQVBJIHJlcXVlc3RcblxuVG8gZW5hYmxlIHNjcmVlbnNob3RzOlxuLSBWZXJpZnkgRklSRUNSQVdMX0FQSV9LRVkgaXMgc2V0IGNvcnJlY3RseVxuLSBDaGVjayBGaXJlY3Jhd2wgYWNjb3VudCBsaW1pdHNcbi0gRW5zdXJlIHRhcmdldCB3ZWJzaXRlIGFsbG93cyBzY3JlZW5zaG90IGNhcHR1cmVgKTtcbiAgfVxufVxuXG4vKipcbiAqIFNhdmUgZG93bmxvYWRlZCBhc3NldHNcbiAqIEBwYXJhbSBmb2xkZXIgLSBKU1ppcCBmb2xkZXIgZm9yIGFzc2V0c1xuICogQHBhcmFtIGNvbnRlbnREYXRhIC0gUHJvY2Vzc2VkIGNvbnRlbnQgZGF0YSBmb3IgZWFjaCBwYWdlXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHNhdmVBc3NldHMoZm9sZGVyOiBKU1ppcCwgY29udGVudERhdGE6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KSB7XG4gIGNvbnN0IGFsbEFzc2V0cyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuXG4gIC8vIENvbGxlY3QgYWxsIHVuaXF1ZSBhc3NldHMgZnJvbSBhbGwgcGFnZXNcbiAgT2JqZWN0LnZhbHVlcyhjb250ZW50RGF0YSkuZm9yRWFjaChkYXRhID0+IHtcbiAgICBjb25zdCBwYWdlRGF0YSA9IGRhdGEgYXMgUmVjb3JkPHN0cmluZywgdW5rbm93bj47XG4gICAgY29uc3QgYXNzZXRzID0gKHBhZ2VEYXRhLmFzc2V0cyBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPltdKSB8fCBbXTtcblxuICAgIGFzc2V0cy5mb3JFYWNoKGFzc2V0ID0+IHtcbiAgICAgIGNvbnN0IGFzc2V0VXJsID0gYXNzZXQudXJsIGFzIHN0cmluZztcbiAgICAgIGlmIChhc3NldFVybCkge1xuICAgICAgICBhbGxBc3NldHMuYWRkKGFzc2V0VXJsKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG5cbiAgLy8gQ3JlYXRlIGFzc2V0IG1hbmlmZXN0XG4gIGNvbnN0IGFzc2V0TWFuaWZlc3QgPSB7XG4gICAgdG90YWxBc3NldHM6IGFsbEFzc2V0cy5zaXplLFxuICAgIGFzc2V0VHlwZXM6IHt9IGFzIFJlY29yZDxzdHJpbmcsIHN0cmluZ1tdPixcbiAgICBkb3dubG9hZEluc3RydWN0aW9uczogJ0Fzc2V0cyBsaXN0ZWQgYmVsb3cgc2hvdWxkIGJlIGRvd25sb2FkZWQgZnJvbSB0aGVpciBvcmlnaW5hbCBVUkxzJyxcbiAgICBnZW5lcmF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gIH07XG5cbiAgLy8gQ2F0ZWdvcml6ZSBhc3NldHMgYnkgdHlwZVxuICBhbGxBc3NldHMuZm9yRWFjaChhc3NldFVybCA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIEhhbmRsZSByZWxhdGl2ZSBVUkxzIGJ5IGNyZWF0aW5nIGEgcHJvcGVyIFVSTFxuICAgICAgbGV0IHVybDogVVJMO1xuICAgICAgaWYgKGFzc2V0VXJsLnN0YXJ0c1dpdGgoJ2h0dHA6Ly8nKSB8fCBhc3NldFVybC5zdGFydHNXaXRoKCdodHRwczovLycpKSB7XG4gICAgICAgIHVybCA9IG5ldyBVUkwoYXNzZXRVcmwpO1xuICAgICAgfSBlbHNlIGlmIChhc3NldFVybC5zdGFydHNXaXRoKCcvLycpKSB7XG4gICAgICAgIHVybCA9IG5ldyBVUkwoJ2h0dHBzOicgKyBhc3NldFVybCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGb3IgcmVsYXRpdmUgVVJMcywgdXNlIHRoZSBmaXJzdCBwYWdlIFVSTCBhcyBiYXNlXG4gICAgICAgIGNvbnN0IGJhc2VVcmwgPSBPYmplY3Qua2V5cyhjb250ZW50RGF0YSlbMF0gfHwgJ2h0dHBzOi8vZXhhbXBsZS5jb20nO1xuICAgICAgICB1cmwgPSBuZXcgVVJMKGFzc2V0VXJsLCBiYXNlVXJsKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHBhdGhuYW1lID0gdXJsLnBhdGhuYW1lLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgIGxldCBjYXRlZ29yeSA9ICdvdGhlcic7XG4gICAgICBpZiAocGF0aG5hbWUubWF0Y2goL1xcLihqcGd8anBlZ3xwbmd8Z2lmfHN2Z3x3ZWJwKSQvKSkge1xuICAgICAgICBjYXRlZ29yeSA9ICdpbWFnZXMnO1xuICAgICAgfSBlbHNlIGlmIChwYXRobmFtZS5tYXRjaCgvXFwuKGNzcykkLykpIHtcbiAgICAgICAgY2F0ZWdvcnkgPSAnY3NzJztcbiAgICAgIH0gZWxzZSBpZiAocGF0aG5hbWUubWF0Y2goL1xcLihqcykkLykpIHtcbiAgICAgICAgY2F0ZWdvcnkgPSAnamF2YXNjcmlwdCc7XG4gICAgICB9IGVsc2UgaWYgKHBhdGhuYW1lLm1hdGNoKC9cXC4od29mZnx3b2ZmMnx0dGZ8b3RmfGVvdCkkLykpIHtcbiAgICAgICAgY2F0ZWdvcnkgPSAnZm9udHMnO1xuICAgICAgfSBlbHNlIGlmIChwYXRobmFtZS5tYXRjaCgvXFwuKG1wNHx3ZWJtfG9nZ3xhdmkpJC8pKSB7XG4gICAgICAgIGNhdGVnb3J5ID0gJ3ZpZGVvcyc7XG4gICAgICB9XG5cbiAgICAgIGlmICghYXNzZXRNYW5pZmVzdC5hc3NldFR5cGVzW2NhdGVnb3J5XSkge1xuICAgICAgICBhc3NldE1hbmlmZXN0LmFzc2V0VHlwZXNbY2F0ZWdvcnldID0gW107XG4gICAgICB9XG4gICAgICBhc3NldE1hbmlmZXN0LmFzc2V0VHlwZXNbY2F0ZWdvcnldLnB1c2goYXNzZXRVcmwpO1xuXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUud2FybihgRXJyb3IgY2F0ZWdvcml6aW5nIGFzc2V0OiAke2Fzc2V0VXJsfWAsIGVycm9yKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIFNhdmUgYXNzZXQgbWFuaWZlc3RcbiAgZm9sZGVyLmZpbGUoJ21hbmlmZXN0Lmpzb24nLCBKU09OLnN0cmluZ2lmeShhc3NldE1hbmlmZXN0LCBudWxsLCAyKSk7XG5cbiAgLy8gQ3JlYXRlIGRvd25sb2FkIHNjcmlwdFxuICBjb25zdCBkb3dubG9hZFNjcmlwdCA9IGAjIS9iaW4vYmFzaFxuIyBBc3NldCBEb3dubG9hZCBTY3JpcHRcbiMgUnVuIHRoaXMgc2NyaXB0IHRvIGRvd25sb2FkIGFsbCBhc3NldHMgZnJvbSB0aGUgb3JpZ2luYWwgd2Vic2l0ZVxuXG5ta2RpciAtcCBpbWFnZXMgY3NzIGphdmFzY3JpcHQgZm9udHMgdmlkZW9zIG90aGVyXG5cbiR7T2JqZWN0LmVudHJpZXMoYXNzZXRNYW5pZmVzdC5hc3NldFR5cGVzKS5tYXAoKFtjYXRlZ29yeSwgdXJsc10pID0+XG4gIHVybHMubWFwKCh1cmw6IHN0cmluZykgPT4ge1xuICAgIGNvbnN0IGZpbGVuYW1lID0gdXJsLnNwbGl0KCcvJykucG9wKCkgfHwgJ3Vua25vd24nO1xuICAgIHJldHVybiBgY3VybCAtbyBcIiR7Y2F0ZWdvcnl9LyR7ZmlsZW5hbWV9XCIgXCIke3VybH1cImA7XG4gIH0pLmpvaW4oJ1xcbicpXG4pLmpvaW4oJ1xcbicpfVxuXG5lY2hvIFwiQXNzZXQgZG93bmxvYWQgY29tcGxldGUhXCJcbmA7XG5cbiAgZm9sZGVyLmZpbGUoJ2Rvd25sb2FkLWFzc2V0cy5zaCcsIGRvd25sb2FkU2NyaXB0KTtcblxuICAvLyBDcmVhdGUgV2luZG93cyBiYXRjaCBmaWxlIHZlcnNpb25cbiAgY29uc3Qgd2luZG93c1NjcmlwdCA9IGRvd25sb2FkU2NyaXB0LnJlcGxhY2UoJyMhL2Jpbi9iYXNoJywgJ0BlY2hvIG9mZicpO1xuICBmb2xkZXIuZmlsZSgnZG93bmxvYWQtYXNzZXRzLmJhdCcsIHdpbmRvd3NTY3JpcHQpO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlIHRlY2huaWNhbCBkb2N1bWVudGF0aW9uIGZpbGVzXG4gKiBAcGFyYW0gZm9sZGVyIC0gSlNaaXAgZm9sZGVyIGZvciBkb2N1bWVudGF0aW9uXG4gKiBAcGFyYW0gc2l0ZU1hcERhdGEgLSBQcm9jZXNzZWQgc2l0ZSBtYXAgZGF0YVxuICogQHBhcmFtIGNvbnRlbnREYXRhIC0gUHJvY2Vzc2VkIGNvbnRlbnQgZGF0YSBmb3IgZWFjaCBwYWdlXG4gKiBAcGFyYW0gcGVyZm9ybWFuY2VEYXRhIC0gUHJvY2Vzc2VkIHBlcmZvcm1hbmNlIG1ldHJpY3NcbiAqIEBwYXJhbSBzdHJ1Y3R1cmVkRGF0YSAtIEV4dHJhY3RlZCBzdHJ1Y3R1cmVkIGRhdGEgYWJvdXQgdGhlIHdlYnNpdGVcbiAqL1xuYXN5bmMgZnVuY3Rpb24gZ2VuZXJhdGVUZWNobmljYWxEb2NzKFxuICBmb2xkZXI6IEpTWmlwLFxuICBzaXRlTWFwRGF0YTogUmVjb3JkPHN0cmluZywgdW5rbm93bj4sXG4gIGNvbnRlbnREYXRhOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPixcbiAgcGVyZm9ybWFuY2VEYXRhOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPixcbiAgc3RydWN0dXJlZERhdGE6IFJlY29yZDxzdHJpbmcsIHVua25vd24+XG4pIHtcbiAgLy8gR2VuZXJhdGUgY29tcG9uZW50IGFuYWx5c2lzXG4gIGNvbnN0IGNvbXBvbmVudHMgPSBpZGVudGlmeUNvbXBvbmVudHMoY29udGVudERhdGEpO1xuICBjb25zdCBjb21wb25lbnRzTWQgPSBgIyBDb21wb25lbnQgQW5hbHlzaXNcblxuVGhpcyBkb2N1bWVudCBwcm92aWRlcyBhIGRldGFpbGVkIGFuYWx5c2lzIG9mIHRoZSBjb21wb25lbnRzIGlkZW50aWZpZWQgYWNyb3NzIHRoZSB3ZWJzaXRlLlxuXG4ke09iamVjdC5lbnRyaWVzKGNvbXBvbmVudHMpLm1hcCgoW3R5cGUsIGl0ZW1zXSkgPT4gYFxuIyMgJHt0eXBlLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgdHlwZS5zbGljZSgxKX0gQ29tcG9uZW50c1xuXG5Gb3VuZCAkeyhpdGVtcyBhcyB1bmtub3duW10pLmxlbmd0aH0gdW5pcXVlICR7dHlwZX0gY29tcG9uZW50czpcblxuJHsoaXRlbXMgYXMgYW55W10pLm1hcCgoaXRlbSwgaW5kZXgpID0+IGBcbiMjIyAke3R5cGUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyB0eXBlLnNsaWNlKDEpfSAke2luZGV4ICsgMX1cbi0gKipTb3VyY2UqKjogJHtpdGVtLnNvdXJjZX1cbi0gKipDb250ZW50IFByZXZpZXcqKjogJHtjbGVhbkNvbXBvbmVudENvbnRlbnQoaXRlbS5jb250ZW50IGFzIHN0cmluZyl9XG5cbmApLmpvaW4oJycpfVxuYCkuam9pbignJyl9XG5gO1xuXG4gIGZvbGRlci5maWxlKCdjb21wb25lbnRzLm1kJywgY29tcG9uZW50c01kKTtcblxuICAvLyBHZW5lcmF0ZSBwZXJmb3JtYW5jZSBhbmFseXNpc1xuICBjb25zdCBwZXJmb3JtYW5jZSA9IGdlbmVyYXRlUGVyZm9ybWFuY2VHdWlkZWxpbmVzKHBlcmZvcm1hbmNlRGF0YSk7XG4gIGNvbnN0IHBlcmZvcm1hbmNlTWQgPSBgIyBQZXJmb3JtYW5jZSBBbmFseXNpc1xuXG4ke3BlcmZvcm1hbmNlLmRlc2NyaXB0aW9ufVxuXG4jIyBTY29yZXNcbiR7T2JqZWN0LmVudHJpZXMocGVyZm9ybWFuY2Uuc2NvcmVzIHx8IHt9KS5tYXAoKFttZXRyaWMsIHNjb3JlXSkgPT5cbiAgYC0gKioke21ldHJpYy5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIG1ldHJpYy5zbGljZSgxKX0qKjogJHtNYXRoLnJvdW5kKChzY29yZSBhcyBudW1iZXIpICogMTAwKX0lYFxuKS5qb2luKCdcXG4nKX1cblxuIyMgS2V5IE1ldHJpY3NcbiR7T2JqZWN0LmVudHJpZXMocGVyZm9ybWFuY2UubWV0cmljcyB8fCB7fSkubWFwKChbbWV0cmljLCBkYXRhXSkgPT5cbiAgYC0gKioke21ldHJpY30qKjogJHtKU09OLnN0cmluZ2lmeShkYXRhKX1gXG4pLmpvaW4oJ1xcbicpfVxuXG4jIyBSZWNvbW1lbmRhdGlvbnNcbiR7cGVyZm9ybWFuY2UucmVjb21tZW5kYXRpb25zLm1hcCgocmVjOiBzdHJpbmcpID0+IGAtICR7cmVjfWApLmpvaW4oJ1xcbicpfVxuYDtcblxuICBmb2xkZXIuZmlsZSgncGVyZm9ybWFuY2UubWQnLCBwZXJmb3JtYW5jZU1kKTtcblxuICAvLyBHZW5lcmF0ZSB0ZWNobmljYWwgc3BlY2lmaWNhdGlvbnNcbiAgY29uc3QgdGVjaFNwZWNzTWQgPSBgIyBUZWNobmljYWwgU3BlY2lmaWNhdGlvbnNcblxuIyMgU2l0ZSBTdHJ1Y3R1cmVcbi0gKipUb3RhbCBQYWdlcyoqOiAkeyhzaXRlTWFwRGF0YS5wYWdlcyBhcyB1bmtub3duW10pPy5sZW5ndGggfHwgMH1cbi0gKipUZWNobm9sb2dpZXMqKjogJHsoc3RydWN0dXJlZERhdGE/LnRlY2hub2xvZ2llcyBhcyBzdHJpbmdbXSk/LmpvaW4oJywgJykgfHwgJ1N0YW5kYXJkIEhUTUwvQ1NTL0pTJ31cbi0gKipEZXNpZ24gUGF0dGVybnMqKjogJHsoc3RydWN0dXJlZERhdGE/LmRlc2lnblBhdHRlcm5zIGFzIHN0cmluZ1tdKT8uam9pbignLCAnKSB8fCAnU3RhbmRhcmQgd2ViIHBhdHRlcm5zJ31cblxuIyMgUGFnZSBIaWVyYXJjaHlcbiR7SlNPTi5zdHJpbmdpZnkoZ2VuZXJhdGVQYWdlSGllcmFyY2h5KHNpdGVNYXBEYXRhKSwgbnVsbCwgMil9XG5cbiMjIEFzc2V0IFN1bW1hcnlcbiR7T2JqZWN0LmVudHJpZXMoZXh0cmFjdEFzc2V0UmVmZXJlbmNlcyhjb250ZW50RGF0YSkpLm1hcCgoW3R5cGUsIGl0ZW1zXSkgPT5cbiAgYC0gKioke3R5cGUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyB0eXBlLnNsaWNlKDEpfSoqOiAkeyhpdGVtcyBhcyBzdHJpbmdbXSkubGVuZ3RofSBmaWxlc2Bcbikuam9pbignXFxuJyl9XG5cbiMjIENvbG9yIFBhbGV0dGVcbiR7KHN0cnVjdHVyZWREYXRhPy5jb2xvclBhbGV0dGUgYXMgc3RyaW5nW10pPy5tYXAoY29sb3IgPT4gYC0gJHtjb2xvcn1gKS5qb2luKCdcXG4nKSB8fCAnTm90IHNwZWNpZmllZCd9XG5cbiMjIEZvbnQgRmFtaWxpZXNcbiR7KHN0cnVjdHVyZWREYXRhPy5mb250RmFtaWxpZXMgYXMgc3RyaW5nW10pPy5tYXAoZm9udCA9PiBgLSAke2ZvbnR9YCkuam9pbignXFxuJykgfHwgJ05vdCBzcGVjaWZpZWQnfVxuXG4jIyBLZXkgRmVhdHVyZXNcbiR7KHN0cnVjdHVyZWREYXRhPy5rZXlGZWF0dXJlcyBhcyBzdHJpbmdbXSk/Lm1hcChmZWF0dXJlID0+IGAtICR7ZmVhdHVyZX1gKS5qb2luKCdcXG4nKSB8fCAnTm90IHNwZWNpZmllZCd9XG5gO1xuXG4gIGZvbGRlci5maWxlKCd0ZWNobmljYWwtc3BlY3MubWQnLCB0ZWNoU3BlY3NNZCk7XG59XG5cbi8qKlxuICogR2VuZXJhdGUgcGFja2FnZSBtYW5pZmVzdFxuICogQHBhcmFtIHNpdGVNYXBEYXRhIC0gUHJvY2Vzc2VkIHNpdGUgbWFwIGRhdGFcbiAqIEBwYXJhbSBjb250ZW50RGF0YSAtIFByb2Nlc3NlZCBjb250ZW50IGRhdGEgZm9yIGVhY2ggcGFnZVxuICogQHBhcmFtIHBlcmZvcm1hbmNlRGF0YSAtIFByb2Nlc3NlZCBwZXJmb3JtYW5jZSBtZXRyaWNzXG4gKiBAcGFyYW0gc3RydWN0dXJlZERhdGEgLSBFeHRyYWN0ZWQgc3RydWN0dXJlZCBkYXRhIGFib3V0IHRoZSB3ZWJzaXRlXG4gKiBAcGFyYW0gYW5hbHlzaXNJZCAtIFVuaXF1ZSBJRCBmb3IgdGhpcyBhbmFseXNpc1xuICogQHJldHVybnMgUGFja2FnZSBtYW5pZmVzdCBvYmplY3RcbiAqL1xuZnVuY3Rpb24gZ2VuZXJhdGVQYWNrYWdlTWFuaWZlc3QoXG4gIHNpdGVNYXBEYXRhOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPixcbiAgY29udGVudERhdGE6IFJlY29yZDxzdHJpbmcsIHVua25vd24+LFxuICBwZXJmb3JtYW5jZURhdGE6IFJlY29yZDxzdHJpbmcsIHVua25vd24+LFxuICBzdHJ1Y3R1cmVkRGF0YTogUmVjb3JkPHN0cmluZywgdW5rbm93bj4sXG4gIGFuYWx5c2lzSWQ6IHN0cmluZ1xuKSB7XG4gIHJldHVybiB7XG4gICAgbmFtZTogJ3dlYnNpdGUtcmVidWlsZC1wYWNrYWdlJyxcbiAgICB2ZXJzaW9uOiAnMS4wLjAnLFxuICAgIGRlc2NyaXB0aW9uOiAnQ29tcHJlaGVuc2l2ZSB3ZWJzaXRlIHJlYnVpbGQgcGFja2FnZSBnZW5lcmF0ZWQgYnkgV1JQRycsXG4gICAgYW5hbHlzaXNJZCxcbiAgICBnZW5lcmF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgIHNvdXJjZToge1xuICAgICAgcGFnZXM6IChzaXRlTWFwRGF0YS5wYWdlcyBhcyBzdHJpbmdbXSkgfHwgW10sXG4gICAgICB0b3RhbFBhZ2VzOiAoc2l0ZU1hcERhdGEucGFnZXMgYXMgdW5rbm93bltdKT8ubGVuZ3RoIHx8IDBcbiAgICB9LFxuICAgIHRlY2hub2xvZ2llczogKHN0cnVjdHVyZWREYXRhPy50ZWNobm9sb2dpZXMgYXMgc3RyaW5nW10pIHx8IFtdLFxuICAgIGRlc2lnblBhdHRlcm5zOiAoc3RydWN0dXJlZERhdGE/LmRlc2lnblBhdHRlcm5zIGFzIHN0cmluZ1tdKSB8fCBbXSxcbiAgICBjb2xvclBhbGV0dGU6IChzdHJ1Y3R1cmVkRGF0YT8uY29sb3JQYWxldHRlIGFzIHN0cmluZ1tdKSB8fCBbXSxcbiAgICBmb250RmFtaWxpZXM6IChzdHJ1Y3R1cmVkRGF0YT8uZm9udEZhbWlsaWVzIGFzIHN0cmluZ1tdKSB8fCBbXSxcbiAgICBrZXlGZWF0dXJlczogKHN0cnVjdHVyZWREYXRhPy5rZXlGZWF0dXJlcyBhcyBzdHJpbmdbXSkgfHwgW10sXG4gICAgcGVyZm9ybWFuY2U6IHtcbiAgICAgIHNjb3JlczogKHBlcmZvcm1hbmNlRGF0YSBhcyBhbnkpPy5wZXJmb3JtYW5jZT8uc2NvcmUgPyB7XG4gICAgICAgIHBlcmZvcm1hbmNlOiAocGVyZm9ybWFuY2VEYXRhIGFzIGFueSkucGVyZm9ybWFuY2Uuc2NvcmUsXG4gICAgICAgIGFjY2Vzc2liaWxpdHk6IChwZXJmb3JtYW5jZURhdGEgYXMgYW55KS5hY2Nlc3NpYmlsaXR5Py5zY29yZSxcbiAgICAgICAgc2VvOiAocGVyZm9ybWFuY2VEYXRhIGFzIGFueSkuc2VvPy5zY29yZSxcbiAgICAgICAgYmVzdFByYWN0aWNlczogKHBlcmZvcm1hbmNlRGF0YSBhcyBhbnkpLmJlc3RQcmFjdGljZXM/LnNjb3JlXG4gICAgICB9IDogbnVsbFxuICAgIH0sXG4gICAgYXNzZXRzOiBleHRyYWN0QXNzZXRSZWZlcmVuY2VzKGNvbnRlbnREYXRhKSxcbiAgICBjb21wb25lbnRzOiBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICBPYmplY3QuZW50cmllcyhpZGVudGlmeUNvbXBvbmVudHMoY29udGVudERhdGEpKS5tYXAoKFt0eXBlLCBpdGVtc10pID0+IFtcbiAgICAgICAgdHlwZSxcbiAgICAgICAgKGl0ZW1zIGFzIHVua25vd25bXSkubGVuZ3RoXG4gICAgICBdKVxuICAgICksXG4gICAgZmlsZXM6IHtcbiAgICAgICdSRUFETUUubWQnOiAnTWFpbiBBSSBwcm9tcHQgYW5kIGluc3RydWN0aW9ucycsXG4gICAgICAncGFja2FnZS5qc29uJzogJ1BhY2thZ2UgbWFuaWZlc3QgYW5kIG1ldGFkYXRhJyxcbiAgICAgICdwYWdlcy8nOiAnSW5kaXZpZHVhbCBwYWdlIEhUTUwgYW5kIE1hcmtkb3duIGZpbGVzJyxcbiAgICAgICdzY3JlZW5zaG90cy8nOiAnRnVsbC1wYWdlIHNjcmVlbnNob3RzIG9mIGFsbCBwYWdlcycsXG4gICAgICAnYXNzZXRzLyc6ICdBc3NldCBtYW5pZmVzdCBhbmQgZG93bmxvYWQgc2NyaXB0cycsXG4gICAgICAnZG9jcy8nOiAnVGVjaG5pY2FsIGRvY3VtZW50YXRpb24gYW5kIGFuYWx5c2lzJ1xuICAgIH0sXG4gICAgdXNhZ2U6IHtcbiAgICAgIHF1aWNrU3RhcnQ6IFtcbiAgICAgICAgJ1JldmlldyBzY3JlZW5zaG90cy8gZm9sZGVyIGZvciB2aXN1YWwgZGVzaWduJyxcbiAgICAgICAgJ0V4YW1pbmUgcGFnZXMvIGZvbGRlciBmb3IgSFRNTCBzdHJ1Y3R1cmUnLFxuICAgICAgICAnQ2hlY2sgYXNzZXRzLyBmb2xkZXIgZm9yIHJlc291cmNlcycsXG4gICAgICAgICdGb2xsb3cgUkVBRE1FLm1kIHJlY29uc3RydWN0aW9uIGluc3RydWN0aW9ucydcbiAgICAgIF0sXG4gICAgICBhaUluc3RydWN0aW9uczogJ1VzZSB0aGlzIHBhY2thZ2Ugd2l0aCBDbGF1ZGUgU29ubmV0IG9yIHNpbWlsYXIgQUkgZm9yIHdlYnNpdGUgcmVjb25zdHJ1Y3Rpb24nXG4gICAgfVxuICB9O1xufSJdLCJuYW1lcyI6WyJKU1ppcCIsImdlbmVyYXRlV2Vic2l0ZVJlYnVpbGRQYWNrYWdlIiwic2l0ZU1hcERhdGEiLCJjb250ZW50RGF0YSIsInBlcmZvcm1hbmNlRGF0YSIsInN0cnVjdHVyZWREYXRhIiwiYW5hbHlzaXNJZCIsInppcCIsInRpbWVzdGFtcCIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsInJlcGxhY2UiLCJwYWNrYWdlTmFtZSIsInByb21wdE1hcmtkb3duIiwiZ2VuZXJhdGVQcm9tcHRNYXJrZG93biIsImZpbGUiLCJwYWdlc0ZvbGRlciIsImZvbGRlciIsInNhdmVQYWdlRmlsZXMiLCJzY3JlZW5zaG90c0ZvbGRlciIsInNhdmVTY3JlZW5zaG90cyIsImFzc2V0c0ZvbGRlciIsInNhdmVBc3NldHMiLCJjc3NGb2xkZXIiLCJzYXZlQ1NTRmlsZXMiLCJkb2NzRm9sZGVyIiwiZ2VuZXJhdGVUZWNobmljYWxEb2NzIiwibWFuaWZlc3QiLCJnZW5lcmF0ZVBhY2thZ2VNYW5pZmVzdCIsIkpTT04iLCJzdHJpbmdpZnkiLCJnZW5lcmF0ZVNvbm5ldFByb21wdCIsInByb21wdCIsIm1ldGFkYXRhIiwiZ2VuZXJhdGVkQXQiLCJ2ZXJzaW9uIiwiZ2VuZXJhdGVkRm9yIiwicHJvbXB0VHlwZSIsInNpdGVPdmVydmlldyIsImdlbmVyYXRlU2l0ZU92ZXJ2aWV3IiwicGFnZURldGFpbHMiLCJnZW5lcmF0ZVBhZ2VEZXRhaWxzIiwiY29tcG9uZW50cyIsImlkZW50aWZ5Q29tcG9uZW50cyIsImFzc2V0cyIsImV4dHJhY3RBc3NldFJlZmVyZW5jZXMiLCJwZXJmb3JtYW5jZUNvbnNpZGVyYXRpb25zIiwiZ2VuZXJhdGVQZXJmb3JtYW5jZUd1aWRlbGluZXMiLCJyZWNvbnN0cnVjdGlvbkluc3RydWN0aW9ucyIsImdlbmVyYXRlUmVjb25zdHJ1Y3Rpb25JbnN0cnVjdGlvbnMiLCJwYWdlQ291bnQiLCJwYWdlcyIsImxlbmd0aCIsInRlY2hub2xvZ2llcyIsImRlc2lnblBhdHRlcm5zIiwiY29sb3JQYWxldHRlIiwiZm9udEZhbWlsaWVzIiwidGl0bGUiLCJkZXNjcmlwdGlvbiIsInN0cnVjdHVyZSIsInBhZ2VIaWVyYXJjaHkiLCJnZW5lcmF0ZVBhZ2VIaWVyYXJjaHkiLCJrZXlGZWF0dXJlcyIsImhpZXJhcmNoeSIsImZvckVhY2giLCJ1cmwiLCJ1cmxPYmoiLCJVUkwiLCJwYXRoIiwicGF0aG5hbWUiLCJzZWdtZW50cyIsInNwbGl0IiwiZmlsdGVyIiwiQm9vbGVhbiIsImRlcHRoIiwicHVzaCIsImVycm9yIiwiY29uc29sZSIsIndhcm4iLCJPYmplY3QiLCJlbnRyaWVzIiwiZGF0YSIsInBhZ2VOYW1lIiwicG9wIiwicGFnZURhdGEiLCJodG1sU3RydWN0dXJlIiwiZ2VuZXJhdGVIdG1sU3RydWN0dXJlU3VtbWFyeSIsImh0bWwiLCJjc3NDbGFzc2VzIiwiZXh0cmFjdENzc0NsYXNzZXMiLCJsaW5rcyIsImhlYWRNYXRjaCIsIm1hdGNoIiwiYm9keU1hdGNoIiwiaGVhZENvbnRlbnQiLCJib2R5Q29udGVudCIsImhlYWRlck1hdGNoIiwibWFpbk1hdGNoIiwiZm9vdGVyTWF0Y2giLCJlbGVtZW50Q291bnRzIiwiZWxlbWVudFJlZ2V4IiwiZXhlYyIsInRhZyIsInRvTG93ZXJDYXNlIiwiZG9jdHlwZSIsImhlYWRFbGVtZW50cyIsIm1ldGFUYWdzIiwic3R5bGVTaGVldHMiLCJzY3JpcHRzIiwiYm9keVN0cnVjdHVyZSIsImhhc0hlYWRlciIsImhhc01haW4iLCJoYXNGb290ZXIiLCJuYXZNZW51cyIsInNlY3Rpb25zIiwiYXJ0aWNsZXMiLCJhc2lkZXMiLCJjbGVhbkNvbXBvbmVudENvbnRlbnQiLCJjb250ZW50IiwiY2xlYW5lZCIsInRyaW0iLCJ0YWdNYXRjaCIsInRhZ05hbWUiLCJhdHRyaWJ1dGVzIiwiY2xhc3NNYXRjaCIsImlkTWF0Y2giLCJzdW1tYXJ5IiwiY29udGVudE1hdGNoIiwiY2xhc3NlcyIsIlNldCIsImNsYXNzUmVnZXgiLCJjbHMiLCJhZGQiLCJBcnJheSIsImZyb20iLCJuYXZpZ2F0aW9uIiwiZm9vdGVyIiwiaGVhZGVyIiwic2lkZWJhciIsImNhcmRzIiwiZm9ybXMiLCJjdXN0b20iLCJuYXZNYXRjaGVzIiwibmF2IiwiaW5kZXgiLCJzb3VyY2UiLCJmb290ZXJNYXRjaGVzIiwiaGVhZGVyTWF0Y2hlcyIsInNpZGViYXJNYXRjaGVzIiwiZm9ybU1hdGNoZXMiLCJmb3JtIiwiY2FyZENsYXNzUmVnZXgiLCJkaXZNYXRjaGVzIiwiZGl2IiwidGVzdCIsImRlZHVwbGljYXRlZCIsInR5cGUiLCJpdGVtcyIsInVuaXF1ZUl0ZW1zIiwiTWFwIiwiaXRlbSIsInNpbXBsaWZpZWRDb250ZW50IiwiaGFzIiwic2V0IiwidmFsdWVzIiwiY3NzIiwiamF2YXNjcmlwdCIsImltYWdlcyIsImZvbnRzIiwidmlkZW9zIiwib3RoZXIiLCJfdXJsIiwicGFnZUFzc2V0cyIsImFzc2V0IiwiYXNzZXRVcmwiLCJhc3NldFR5cGUiLCJyZXN1bHQiLCJ1cmxzIiwicmVjb21tZW5kYXRpb25zIiwicGVyZm9ybWFuY2UiLCJhY2Nlc3NpYmlsaXR5Iiwic2VvIiwiYmVzdFByYWN0aWNlcyIsInBlcmZTY29yZSIsInNjb3JlIiwibWV0cmljcyIsImZjcCIsImZpcnN0Q29udGVudGZ1bFBhaW50IiwidmFsdWUiLCJsY3AiLCJsYXJnZXN0Q29udGVudGZ1bFBhaW50IiwidGJ0IiwidG90YWxCbG9ja2luZ1RpbWUiLCJjdW11bGF0aXZlTGF5b3V0U2hpZnQiLCJzY29yZXMiLCJfc2l0ZU1hcERhdGEiLCJoYXNGcm9udGVuZEZyYW1ld29yayIsInNvbWUiLCJ0ZWNoIiwic3RlcHMiLCJ0YXNrcyIsImdlbmVyYXRlQ2xhdWRlU29ubmV0SW5zdHJ1Y3Rpb25zIiwiY29tcG9uZW50Q291bnQiLCJyZWR1Y2UiLCJzdW0iLCJhc3NldENvdW50IiwicmVjb21tZW5kZWRGcmFtZXdvcmsiLCJ0IiwicmVjb21tZW5kZWRTdHlsaW5nIiwiZnJhbWV3b3JrIiwic3R5bGluZyIsIndvcmtmbG93IiwicGhhc2UiLCJkdXJhdGlvbiIsInF1YWxpdHlDaGVja3MiLCJpbnN0cnVjdGlvbnMiLCJwcmltYXJ5VXJsIiwia2V5cyIsIm1hcCIsImNoYXJBdCIsInRvVXBwZXJDYXNlIiwic2xpY2UiLCJqb2luIiwicmVjIiwiY29sb3IiLCJmb250IiwicGF0dGVybiIsIk1hdGgiLCJyYW5kb20iLCJ0b1N0cmluZyIsInN1YnN0ciIsIm1hcmtkb3duIiwiZmlsZW5hbWUiLCJleHRyYWN0ZWRBdCIsImNzc0ZpbGVDb3VudCIsImNzc0NvbnRlbnRzIiwiY3NzVXJsIiwiY3NzQ29udGVudCIsImVuZHNXaXRoIiwiZmluYWxGaWxlbmFtZSIsImNvdW50ZXIiLCJiYXNlTmFtZSIsImxvZyIsInNjcmVlbnNob3RDb3VudCIsInNjcmVlbnNob3REYXRhIiwic2NyZWVuc2hvdCIsInNjcmVlbnNob3RVcmwiLCJpbWFnZSIsInJhd0RhdGEiLCJzdGFydHNXaXRoIiwiYmFzZTY0RGF0YSIsImJhc2U2NCIsInJlc3BvbnNlIiwiZmV0Y2giLCJvayIsImltYWdlQnVmZmVyIiwiYXJyYXlCdWZmZXIiLCJzdGF0dXMiLCJhbGxBc3NldHMiLCJhc3NldE1hbmlmZXN0IiwidG90YWxBc3NldHMiLCJzaXplIiwiYXNzZXRUeXBlcyIsImRvd25sb2FkSW5zdHJ1Y3Rpb25zIiwiYmFzZVVybCIsImNhdGVnb3J5IiwiZG93bmxvYWRTY3JpcHQiLCJ3aW5kb3dzU2NyaXB0IiwiY29tcG9uZW50c01kIiwicGVyZm9ybWFuY2VNZCIsIm1ldHJpYyIsInJvdW5kIiwidGVjaFNwZWNzTWQiLCJmZWF0dXJlIiwibmFtZSIsInRvdGFsUGFnZXMiLCJmcm9tRW50cmllcyIsImZpbGVzIiwidXNhZ2UiLCJxdWlja1N0YXJ0IiwiYWlJbnN0cnVjdGlvbnMiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./lib/generate-docs.ts\n");

/***/ }),

/***/ "(rsc)/./lib/mcp-utils.ts":
/*!**************************!*\
  !*** ./lib/mcp-utils.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   conductDeepResearch: () => (/* binding */ conductDeepResearch),\n/* harmony export */   extractStructuredData: () => (/* binding */ extractStructuredData),\n/* harmony export */   mapWebsite: () => (/* binding */ mapWebsite),\n/* harmony export */   scrapeWebpage: () => (/* binding */ scrapeWebpage)\n/* harmony export */ });\n/* harmony import */ var _mendable_firecrawl_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @mendable/firecrawl-js */ \"(rsc)/./node_modules/@mendable/firecrawl-js/dist/index.js\");\n/* harmony import */ var child_process__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! child_process */ \"child_process\");\n/* harmony import */ var child_process__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(child_process__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! util */ \"util\");\n/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(util__WEBPACK_IMPORTED_MODULE_2__);\n/**\n * Firecrawl API utilities for website scraping and mapping\n * Uses the official Firecrawl API for comprehensive web data extraction\n * Enhanced with retry logic, exponential backoff, and Puppeteer fallback\n */ \n\n\nconst execAsync = (0,util__WEBPACK_IMPORTED_MODULE_2__.promisify)(child_process__WEBPACK_IMPORTED_MODULE_1__.exec);\n// Retry configuration\nconst RETRY_CONFIG = {\n    maxAttempts: 3,\n    baseDelay: 2000,\n    maxDelay: 8000 // 8 seconds\n};\n// Initialize Firecrawl client\nconst getFirecrawlClient = ()=>{\n    const apiKey = process.env.FIRECRAWL_API_KEY;\n    if (!apiKey || apiKey === 'your_firecrawl_api_key_here') {\n        return null; // Return null if no API key, we'll use fallback\n    }\n    return new _mendable_firecrawl_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]({\n        apiKey\n    });\n};\n/**\n * Sleep utility for retry delays\n */ const sleep = (ms)=>new Promise((resolve)=>setTimeout(resolve, ms));\n/**\n * Retry wrapper with exponential backoff\n */ async function retryWithBackoff(operation, context, maxAttempts = RETRY_CONFIG.maxAttempts) {\n    let lastError;\n    for(let attempt = 1; attempt <= maxAttempts; attempt++){\n        try {\n            console.log(`${context} - Attempt ${attempt}/${maxAttempts}`);\n            return await operation();\n        } catch (error) {\n            lastError = error;\n            console.error(`${context} - Attempt ${attempt} failed:`, error instanceof Error ? error.message : String(error));\n            if (attempt === maxAttempts) {\n                console.error(`${context} - All ${maxAttempts} attempts failed`);\n                break;\n            }\n            // Calculate delay with exponential backoff\n            const delay = Math.min(RETRY_CONFIG.baseDelay * Math.pow(2, attempt - 1), RETRY_CONFIG.maxDelay);\n            console.log(`${context} - Waiting ${delay}ms before retry...`);\n            await sleep(delay);\n        }\n    }\n    throw new Error(`${context} failed after ${maxAttempts} attempts. Last error: ${lastError.message}`);\n}\n// Fallback implementation using simple HTTP requests\n// Note: Puppeteer is commented out for server-side compatibility\n// import puppeteer from 'puppeteer';\n// Fallback function for mapping websites with simple HTTP\nasync function mapWebsiteWithFallback(url, _options) {\n    try {\n        // For MVP, return a simple list with just the main URL\n        // In production, this would use a proper web scraping service\n        console.log('Using simple fallback for website mapping');\n        return [\n            url\n        ];\n    } catch (error) {\n        console.error('Error in fallback mapping:', error);\n        return [\n            url\n        ];\n    }\n}\n/**\n * Puppeteer fallback for screenshot capture with multiple viewport sizes\n */ async function captureScreenshotWithPuppeteer(url) {\n    try {\n        console.log(`🔄 Attempting Puppeteer screenshot fallback for: ${url}`);\n        // Import Puppeteer dynamically to avoid server-side issues\n        const puppeteer = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! puppeteer */ \"puppeteer\"));\n        const browser = await puppeteer.default.launch({\n            headless: true,\n            args: [\n                '--no-sandbox',\n                '--disable-setuid-sandbox',\n                '--disable-dev-shm-usage',\n                '--disable-accelerated-2d-canvas',\n                '--no-first-run',\n                '--no-zygote',\n                '--disable-gpu'\n            ]\n        });\n        try {\n            const page = await browser.newPage();\n            // Set desktop viewport for full-page screenshot\n            await page.setViewport({\n                width: 1920,\n                height: 1080\n            });\n            // Navigate to the page with extended timeout\n            await page.goto(url, {\n                waitUntil: 'networkidle2',\n                timeout: 60000 // Increased from 45s to 60s for slower sites\n            });\n            // Wait for page to fully load and any lazy-loaded content\n            await new Promise((resolve)=>setTimeout(resolve, 8000)); // Increased from 5s to 8s\n            // Capture full-page screenshot\n            const screenshot = await page.screenshot({\n                fullPage: true,\n                encoding: 'base64',\n                type: 'png'\n            });\n            await browser.close();\n            const screenshotData = `data:image/png;base64,${screenshot}`;\n            console.log('✅ Puppeteer screenshot captured successfully');\n            return screenshotData;\n        } catch (pageError) {\n            await browser.close();\n            throw pageError;\n        }\n    } catch (error) {\n        console.error('❌ Puppeteer screenshot failed:', error);\n        return null;\n    }\n}\n// Fallback function for scraping with simple HTTP and optional Puppeteer\nasync function scrapeWebpageWithFallback(url, options) {\n    try {\n        console.log(`Using fallback scraping for: ${url}`);\n        // Try to get basic HTML content\n        const response = await fetch(url, {\n            headers: {\n                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'\n            },\n            timeout: 30000\n        });\n        if (!response.ok) {\n            throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n        }\n        const html = await response.text();\n        // Extract title\n        const titleMatch = html.match(/<title[^>]*>([^<]+)<\\/title>/i);\n        const title = titleMatch ? titleMatch[1].trim() : 'Untitled';\n        // Basic markdown conversion (very simple)\n        const markdown = `# ${title}\\n\\nContent scraped from ${url}\\n\\n[Original URL](${url})`;\n        // Try to capture screenshot with Puppeteer if requested\n        let screenshot = null;\n        if (options?.formats?.includes('screenshot') || options?.formats?.includes('screenshot@fullPage')) {\n            screenshot = await captureScreenshotWithPuppeteer(url);\n        }\n        return {\n            data: {\n                html,\n                markdown,\n                title,\n                links: [\n                    url\n                ],\n                screenshot\n            },\n            success: true\n        };\n    } catch (error) {\n        console.error('Error in fallback scraping:', error);\n        return {\n            data: {\n                html: '<html><body><h1>Error</h1><p>Could not scrape content.</p></body></html>',\n                markdown: '# Error\\n\\nCould not scrape content.',\n                title: 'Error',\n                links: [],\n                screenshot: null\n            },\n            success: false,\n            error: error instanceof Error ? error.message : String(error)\n        };\n    }\n}\n/**\n * Map a website to discover all indexed URLs on the site\n * @param url - Starting URL for URL discovery\n * @param options - Optional configuration for site mapping\n * @returns Array of URLs found on the site\n */ async function mapWebsite(url, options) {\n    const app = getFirecrawlClient();\n    if (app) {\n        // Use Firecrawl with retry logic\n        try {\n            return await retryWithBackoff(async ()=>{\n                const mapResult = await app.mapUrl(url, {\n                    includeSubdomains: options?.includeSubdomains || false,\n                    limit: options?.limit || 100,\n                    search: options?.search\n                });\n                if (!mapResult.success) {\n                    throw new Error(`Firecrawl mapping failed: ${mapResult.error}`);\n                }\n                return mapResult.links || [];\n            }, `Firecrawl mapping for ${url}`);\n        } catch (error) {\n            console.error('Firecrawl mapping failed after retries, falling back to simple mapping:', error);\n            return await mapWebsiteWithFallback(url, options);\n        }\n    } else {\n        // Fallback to simple implementation\n        console.log('Firecrawl not available, using simple fallback for mapping');\n        return await mapWebsiteWithFallback(url, options);\n    }\n}\n/**\n * Scrape content from a single URL with advanced options\n * @param url - The URL to scrape\n * @param options - Optional configuration for scraping\n * @returns Scraped content in requested formats\n */ async function scrapeWebpage(url, options) {\n    const app = getFirecrawlClient();\n    if (app) {\n        // Use Firecrawl with retry logic\n        try {\n            return await retryWithBackoff(async ()=>{\n                const scrapeOptions = {\n                    onlyMainContent: options?.onlyMainContent || false,\n                    waitFor: options?.waitFor || 3000,\n                    mobile: options?.mobile || false,\n                    actions: options?.actions || []\n                };\n                // Set formats - in Firecrawl v1, screenshot is a format, not a separate parameter\n                // Use full-page screenshots by default for complete website capture\n                // Note: cssContents format not supported in current Firecrawl API\n                const formats = options?.formats || [\n                    'markdown',\n                    'html',\n                    'rawHtml',\n                    'screenshot@fullPage',\n                    'links'\n                ];\n                scrapeOptions.formats = formats;\n                const scrapeResult = await app.scrapeUrl(url, scrapeOptions);\n                if (!scrapeResult.success) {\n                    throw new Error(`Firecrawl scraping failed: ${scrapeResult.error}`);\n                }\n                // Debug: Log what Firecrawl actually returns\n                console.log(`Firecrawl result for ${url}:`, {\n                    success: scrapeResult.success,\n                    dataKeys: Object.keys(scrapeResult.data || {}),\n                    hasScreenshot: !!scrapeResult.data?.screenshot,\n                    screenshotType: typeof scrapeResult.data?.screenshot,\n                    dataStructure: scrapeResult.data ? Object.keys(scrapeResult.data) : 'no data',\n                    screenshotData: scrapeResult.data?.screenshot ? 'present' : 'missing'\n                });\n                // If screenshot was requested but not captured by Firecrawl, try Puppeteer fallback\n                const screenshotRequested = options?.formats?.includes('screenshot') || options?.formats?.includes('screenshot@fullPage');\n                if (screenshotRequested && !scrapeResult.data?.screenshot) {\n                    console.log('🔄 Firecrawl failed to capture full-page screenshot, trying Puppeteer fallback...');\n                    const puppeteerScreenshot = await captureScreenshotWithPuppeteer(url);\n                    if (puppeteerScreenshot) {\n                        scrapeResult.data.screenshot = puppeteerScreenshot;\n                        console.log('✅ Puppeteer fallback full-page screenshot successful');\n                    } else {\n                        console.log('❌ Both Firecrawl and Puppeteer full-page screenshot capture failed');\n                    }\n                }\n                return scrapeResult;\n            }, `Firecrawl scraping for ${url}`);\n        } catch (error) {\n            console.error('Firecrawl scraping failed after retries, falling back to simple scraping:', error);\n            return await scrapeWebpageWithFallback(url, options);\n        }\n    } else {\n        // Fallback to simple implementation\n        console.log('Firecrawl not available, using simple fallback for scraping');\n        return await scrapeWebpageWithFallback(url, options);\n    }\n}\n/**\n * Extract structured information from web pages using LLM capabilities\n * @param urls - Array of URLs to extract information from\n * @param options - Optional configuration for extraction\n * @returns Extracted structured data\n */ async function extractStructuredData(urls, options) {\n    try {\n        const app = getFirecrawlClient();\n        // For now, we'll extract from the first URL only\n        // In a full implementation, we'd process all URLs\n        const url = urls[0];\n        if (!url) {\n            throw new Error('No URLs provided for extraction');\n        }\n        if (app) {\n            // Use Firecrawl if available\n            const extractOptions = {\n                prompt: options?.prompt || 'Extract all relevant information from this webpage',\n                schema: options?.schema || {\n                    type: 'object',\n                    properties: {\n                        title: {\n                            type: 'string'\n                        },\n                        description: {\n                            type: 'string'\n                        },\n                        content: {\n                            type: 'string'\n                        },\n                        technologies: {\n                            type: 'array',\n                            items: {\n                                type: 'string'\n                            }\n                        }\n                    }\n                }\n            };\n            const extractResult = await app.extract([\n                url\n            ], extractOptions);\n            if (!extractResult.success) {\n                throw new Error(`Firecrawl extraction failed: ${extractResult.error}`);\n            }\n            return extractResult;\n        } else {\n            // Fallback implementation - return basic structured data\n            console.log('Firecrawl not available, using basic fallback for extraction');\n            return {\n                technologies: [\n                    'HTML',\n                    'CSS',\n                    'JavaScript'\n                ],\n                designPatterns: [\n                    'Responsive Design'\n                ],\n                keyFeatures: [\n                    'Web Content'\n                ],\n                colorPalette: [\n                    '#000000',\n                    '#ffffff'\n                ],\n                fontFamilies: [\n                    'Arial',\n                    'sans-serif'\n                ]\n            };\n        }\n    } catch (error) {\n        console.error('Error extracting structured data:', error);\n        throw new Error(`Failed to extract structured data: ${error instanceof Error ? error.message : String(error)}`);\n    }\n}\n/**\n * Conduct deep web research on a query using intelligent crawling, search, and LLM analysis\n * @param query - The research question or topic to explore\n * @param options - Optional configuration for research\n * @returns Final analysis and research process details\n */ async function conductDeepResearch(query, options) {\n    try {\n        // For MVP, we'll implement a simple version\n        // In production, this would use Firecrawl's research capabilities\n        console.log(`Conducting research for query: ${query}`);\n        return {\n            query,\n            results: [],\n            summary: `Research completed for: ${query}`,\n            metadata: {\n                maxDepth: options?.maxDepth || 3,\n                timeLimit: options?.timeLimit || 120,\n                maxUrls: options?.maxUrls || 50\n            }\n        };\n    } catch (error) {\n        console.error('Error conducting deep research:', error);\n        throw new Error(`Failed to conduct deep research: ${error instanceof Error ? error.message : String(error)}`);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O29CQUFDO29CQUFTO2lCQUFhO1lBQ3ZDO1FBQ0Y7SUFDRixFQUFFLE9BQU8zRixPQUFPO1FBQ2RGLFFBQVFFLEtBQUssQ0FBQyxxQ0FBcUNBO1FBQ25ELE1BQU0sSUFBSUMsTUFBTSxDQUFDLG1DQUFtQyxFQUFFRCxpQkFBaUJDLFFBQVFELE1BQU1FLE9BQU8sR0FBR0MsT0FBT0gsUUFBUTtJQUNoSDtBQUNGO0FBRUE7Ozs7O0NBS0MsR0FDTSxlQUFlNEYsb0JBQW9CQyxLQUFhLEVBQUUzRCxPQUl4RDtJQUNDLElBQUk7UUFDRiw0Q0FBNEM7UUFDNUMsa0VBQWtFO1FBQ2xFcEMsUUFBUUMsR0FBRyxDQUFDLENBQUMsK0JBQStCLEVBQUU4RixPQUFPO1FBRXJELE9BQU87WUFDTEE7WUFDQUMsU0FBUyxFQUFFO1lBQ1hDLFNBQVMsQ0FBQyx3QkFBd0IsRUFBRUYsT0FBTztZQUMzQ0csVUFBVTtnQkFDUkMsVUFBVS9ELFNBQVMrRCxZQUFZO2dCQUMvQkMsV0FBV2hFLFNBQVNnRSxhQUFhO2dCQUNqQ0MsU0FBU2pFLFNBQVNpRSxXQUFXO1lBQy9CO1FBQ0Y7SUFDRixFQUFFLE9BQU9uRyxPQUFPO1FBQ2RGLFFBQVFFLEtBQUssQ0FBQyxtQ0FBbUNBO1FBQ2pELE1BQU0sSUFBSUMsTUFBTSxDQUFDLGlDQUFpQyxFQUFFRCxpQkFBaUJDLFFBQVFELE1BQU1FLE9BQU8sR0FBR0MsT0FBT0gsUUFBUTtJQUM5RztBQUNGIiwic291cmNlcyI6WyIvVXNlcnMvZGVhbm5ld3Rvbi9Eb2N1bWVudHMveHJheS9saWIvbWNwLXV0aWxzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogRmlyZWNyYXdsIEFQSSB1dGlsaXRpZXMgZm9yIHdlYnNpdGUgc2NyYXBpbmcgYW5kIG1hcHBpbmdcbiAqIFVzZXMgdGhlIG9mZmljaWFsIEZpcmVjcmF3bCBBUEkgZm9yIGNvbXByZWhlbnNpdmUgd2ViIGRhdGEgZXh0cmFjdGlvblxuICogRW5oYW5jZWQgd2l0aCByZXRyeSBsb2dpYywgZXhwb25lbnRpYWwgYmFja29mZiwgYW5kIFB1cHBldGVlciBmYWxsYmFja1xuICovXG5cbmltcG9ydCBGaXJlY3Jhd2xBcHAgZnJvbSAnQG1lbmRhYmxlL2ZpcmVjcmF3bC1qcyc7XG5pbXBvcnQgeyBleGVjIH0gZnJvbSAnY2hpbGRfcHJvY2Vzcyc7XG5pbXBvcnQgeyBwcm9taXNpZnkgfSBmcm9tICd1dGlsJztcblxuY29uc3QgZXhlY0FzeW5jID0gcHJvbWlzaWZ5KGV4ZWMpO1xuXG4vLyBSZXRyeSBjb25maWd1cmF0aW9uXG5jb25zdCBSRVRSWV9DT05GSUcgPSB7XG4gIG1heEF0dGVtcHRzOiAzLFxuICBiYXNlRGVsYXk6IDIwMDAsIC8vIDIgc2Vjb25kc1xuICBtYXhEZWxheTogODAwMCAgIC8vIDggc2Vjb25kc1xufTtcblxuLy8gSW5pdGlhbGl6ZSBGaXJlY3Jhd2wgY2xpZW50XG5jb25zdCBnZXRGaXJlY3Jhd2xDbGllbnQgPSAoKSA9PiB7XG4gIGNvbnN0IGFwaUtleSA9IHByb2Nlc3MuZW52LkZJUkVDUkFXTF9BUElfS0VZO1xuICBpZiAoIWFwaUtleSB8fCBhcGlLZXkgPT09ICd5b3VyX2ZpcmVjcmF3bF9hcGlfa2V5X2hlcmUnKSB7XG4gICAgcmV0dXJuIG51bGw7IC8vIFJldHVybiBudWxsIGlmIG5vIEFQSSBrZXksIHdlJ2xsIHVzZSBmYWxsYmFja1xuICB9XG4gIHJldHVybiBuZXcgRmlyZWNyYXdsQXBwKHsgYXBpS2V5IH0pO1xufTtcblxuLyoqXG4gKiBTbGVlcCB1dGlsaXR5IGZvciByZXRyeSBkZWxheXNcbiAqL1xuY29uc3Qgc2xlZXAgPSAobXM6IG51bWJlcikgPT4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIG1zKSk7XG5cbi8qKlxuICogUmV0cnkgd3JhcHBlciB3aXRoIGV4cG9uZW50aWFsIGJhY2tvZmZcbiAqL1xuYXN5bmMgZnVuY3Rpb24gcmV0cnlXaXRoQmFja29mZjxUPihcbiAgb3BlcmF0aW9uOiAoKSA9PiBQcm9taXNlPFQ+LFxuICBjb250ZXh0OiBzdHJpbmcsXG4gIG1heEF0dGVtcHRzID0gUkVUUllfQ09ORklHLm1heEF0dGVtcHRzXG4pOiBQcm9taXNlPFQ+IHtcbiAgbGV0IGxhc3RFcnJvcjogRXJyb3I7XG5cbiAgZm9yIChsZXQgYXR0ZW1wdCA9IDE7IGF0dGVtcHQgPD0gbWF4QXR0ZW1wdHM7IGF0dGVtcHQrKykge1xuICAgIHRyeSB7XG4gICAgICBjb25zb2xlLmxvZyhgJHtjb250ZXh0fSAtIEF0dGVtcHQgJHthdHRlbXB0fS8ke21heEF0dGVtcHRzfWApO1xuICAgICAgcmV0dXJuIGF3YWl0IG9wZXJhdGlvbigpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsYXN0RXJyb3IgPSBlcnJvciBhcyBFcnJvcjtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYCR7Y29udGV4dH0gLSBBdHRlbXB0ICR7YXR0ZW1wdH0gZmFpbGVkOmAsIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKSk7XG5cbiAgICAgIGlmIChhdHRlbXB0ID09PSBtYXhBdHRlbXB0cykge1xuICAgICAgICBjb25zb2xlLmVycm9yKGAke2NvbnRleHR9IC0gQWxsICR7bWF4QXR0ZW1wdHN9IGF0dGVtcHRzIGZhaWxlZGApO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgLy8gQ2FsY3VsYXRlIGRlbGF5IHdpdGggZXhwb25lbnRpYWwgYmFja29mZlxuICAgICAgY29uc3QgZGVsYXkgPSBNYXRoLm1pbihcbiAgICAgICAgUkVUUllfQ09ORklHLmJhc2VEZWxheSAqIE1hdGgucG93KDIsIGF0dGVtcHQgLSAxKSxcbiAgICAgICAgUkVUUllfQ09ORklHLm1heERlbGF5XG4gICAgICApO1xuXG4gICAgICBjb25zb2xlLmxvZyhgJHtjb250ZXh0fSAtIFdhaXRpbmcgJHtkZWxheX1tcyBiZWZvcmUgcmV0cnkuLi5gKTtcbiAgICAgIGF3YWl0IHNsZWVwKGRlbGF5KTtcbiAgICB9XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoYCR7Y29udGV4dH0gZmFpbGVkIGFmdGVyICR7bWF4QXR0ZW1wdHN9IGF0dGVtcHRzLiBMYXN0IGVycm9yOiAke2xhc3RFcnJvci5tZXNzYWdlfWApO1xufVxuXG4vLyBGYWxsYmFjayBpbXBsZW1lbnRhdGlvbiB1c2luZyBzaW1wbGUgSFRUUCByZXF1ZXN0c1xuLy8gTm90ZTogUHVwcGV0ZWVyIGlzIGNvbW1lbnRlZCBvdXQgZm9yIHNlcnZlci1zaWRlIGNvbXBhdGliaWxpdHlcbi8vIGltcG9ydCBwdXBwZXRlZXIgZnJvbSAncHVwcGV0ZWVyJztcblxuLy8gRmFsbGJhY2sgZnVuY3Rpb24gZm9yIG1hcHBpbmcgd2Vic2l0ZXMgd2l0aCBzaW1wbGUgSFRUUFxuYXN5bmMgZnVuY3Rpb24gbWFwV2Vic2l0ZVdpdGhGYWxsYmFjayh1cmw6IHN0cmluZywgX29wdGlvbnM/OiB7XG4gIGluY2x1ZGVTdWJkb21haW5zPzogYm9vbGVhbjtcbiAgbGltaXQ/OiBudW1iZXI7XG4gIHNlYXJjaD86IHN0cmluZztcbn0pIHtcbiAgdHJ5IHtcbiAgICAvLyBGb3IgTVZQLCByZXR1cm4gYSBzaW1wbGUgbGlzdCB3aXRoIGp1c3QgdGhlIG1haW4gVVJMXG4gICAgLy8gSW4gcHJvZHVjdGlvbiwgdGhpcyB3b3VsZCB1c2UgYSBwcm9wZXIgd2ViIHNjcmFwaW5nIHNlcnZpY2VcbiAgICBjb25zb2xlLmxvZygnVXNpbmcgc2ltcGxlIGZhbGxiYWNrIGZvciB3ZWJzaXRlIG1hcHBpbmcnKTtcbiAgICByZXR1cm4gW3VybF07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gZmFsbGJhY2sgbWFwcGluZzonLCBlcnJvcik7XG4gICAgcmV0dXJuIFt1cmxdO1xuICB9XG59XG5cbi8qKlxuICogUHVwcGV0ZWVyIGZhbGxiYWNrIGZvciBzY3JlZW5zaG90IGNhcHR1cmUgd2l0aCBtdWx0aXBsZSB2aWV3cG9ydCBzaXplc1xuICovXG5hc3luYyBmdW5jdGlvbiBjYXB0dXJlU2NyZWVuc2hvdFdpdGhQdXBwZXRlZXIodXJsOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZyB8IG51bGw+IHtcbiAgdHJ5IHtcbiAgICBjb25zb2xlLmxvZyhg8J+UhCBBdHRlbXB0aW5nIFB1cHBldGVlciBzY3JlZW5zaG90IGZhbGxiYWNrIGZvcjogJHt1cmx9YCk7XG5cbiAgICAvLyBJbXBvcnQgUHVwcGV0ZWVyIGR5bmFtaWNhbGx5IHRvIGF2b2lkIHNlcnZlci1zaWRlIGlzc3Vlc1xuICAgIGNvbnN0IHB1cHBldGVlciA9IGF3YWl0IGltcG9ydCgncHVwcGV0ZWVyJyk7XG5cbiAgICBjb25zdCBicm93c2VyID0gYXdhaXQgcHVwcGV0ZWVyLmRlZmF1bHQubGF1bmNoKHtcbiAgICAgIGhlYWRsZXNzOiB0cnVlLFxuICAgICAgYXJnczogW1xuICAgICAgICAnLS1uby1zYW5kYm94JyxcbiAgICAgICAgJy0tZGlzYWJsZS1zZXR1aWQtc2FuZGJveCcsXG4gICAgICAgICctLWRpc2FibGUtZGV2LXNobS11c2FnZScsXG4gICAgICAgICctLWRpc2FibGUtYWNjZWxlcmF0ZWQtMmQtY2FudmFzJyxcbiAgICAgICAgJy0tbm8tZmlyc3QtcnVuJyxcbiAgICAgICAgJy0tbm8tenlnb3RlJyxcbiAgICAgICAgJy0tZGlzYWJsZS1ncHUnXG4gICAgICBdXG4gICAgfSk7XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgcGFnZSA9IGF3YWl0IGJyb3dzZXIubmV3UGFnZSgpO1xuXG4gICAgICAvLyBTZXQgZGVza3RvcCB2aWV3cG9ydCBmb3IgZnVsbC1wYWdlIHNjcmVlbnNob3RcbiAgICAgIGF3YWl0IHBhZ2Uuc2V0Vmlld3BvcnQoeyB3aWR0aDogMTkyMCwgaGVpZ2h0OiAxMDgwIH0pO1xuXG4gICAgICAvLyBOYXZpZ2F0ZSB0byB0aGUgcGFnZSB3aXRoIGV4dGVuZGVkIHRpbWVvdXRcbiAgICAgIGF3YWl0IHBhZ2UuZ290byh1cmwsIHtcbiAgICAgICAgd2FpdFVudGlsOiAnbmV0d29ya2lkbGUyJyxcbiAgICAgICAgdGltZW91dDogNjAwMDAgLy8gSW5jcmVhc2VkIGZyb20gNDVzIHRvIDYwcyBmb3Igc2xvd2VyIHNpdGVzXG4gICAgICB9KTtcblxuICAgICAgLy8gV2FpdCBmb3IgcGFnZSB0byBmdWxseSBsb2FkIGFuZCBhbnkgbGF6eS1sb2FkZWQgY29udGVudFxuICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDgwMDApKTsgLy8gSW5jcmVhc2VkIGZyb20gNXMgdG8gOHNcblxuICAgICAgLy8gQ2FwdHVyZSBmdWxsLXBhZ2Ugc2NyZWVuc2hvdFxuICAgICAgY29uc3Qgc2NyZWVuc2hvdCA9IGF3YWl0IHBhZ2Uuc2NyZWVuc2hvdCh7XG4gICAgICAgIGZ1bGxQYWdlOiB0cnVlLFxuICAgICAgICBlbmNvZGluZzogJ2Jhc2U2NCcsXG4gICAgICAgIHR5cGU6ICdwbmcnXG4gICAgICB9KTtcblxuICAgICAgYXdhaXQgYnJvd3Nlci5jbG9zZSgpO1xuXG4gICAgICBjb25zdCBzY3JlZW5zaG90RGF0YSA9IGBkYXRhOmltYWdlL3BuZztiYXNlNjQsJHtzY3JlZW5zaG90fWA7XG4gICAgICBjb25zb2xlLmxvZygn4pyFIFB1cHBldGVlciBzY3JlZW5zaG90IGNhcHR1cmVkIHN1Y2Nlc3NmdWxseScpO1xuICAgICAgcmV0dXJuIHNjcmVlbnNob3REYXRhO1xuXG4gICAgfSBjYXRjaCAocGFnZUVycm9yKSB7XG4gICAgICBhd2FpdCBicm93c2VyLmNsb3NlKCk7XG4gICAgICB0aHJvdyBwYWdlRXJyb3I7XG4gICAgfVxuXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcign4p2MIFB1cHBldGVlciBzY3JlZW5zaG90IGZhaWxlZDonLCBlcnJvcik7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLy8gRmFsbGJhY2sgZnVuY3Rpb24gZm9yIHNjcmFwaW5nIHdpdGggc2ltcGxlIEhUVFAgYW5kIG9wdGlvbmFsIFB1cHBldGVlclxuYXN5bmMgZnVuY3Rpb24gc2NyYXBlV2VicGFnZVdpdGhGYWxsYmFjayh1cmw6IHN0cmluZywgb3B0aW9ucz86IHtcbiAgZm9ybWF0cz86IHN0cmluZ1tdO1xuICBvbmx5TWFpbkNvbnRlbnQ/OiBib29sZWFuO1xuICB3YWl0Rm9yPzogbnVtYmVyO1xuICBtb2JpbGU/OiBib29sZWFuO1xuICBhY3Rpb25zPzogUmVjb3JkPHN0cmluZywgdW5rbm93bj5bXTtcbn0pIHtcbiAgdHJ5IHtcbiAgICBjb25zb2xlLmxvZyhgVXNpbmcgZmFsbGJhY2sgc2NyYXBpbmcgZm9yOiAke3VybH1gKTtcblxuICAgIC8vIFRyeSB0byBnZXQgYmFzaWMgSFRNTCBjb250ZW50XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgJ1VzZXItQWdlbnQnOiAnTW96aWxsYS81LjAgKFdpbmRvd3MgTlQgMTAuMDsgV2luNjQ7IHg2NCkgQXBwbGVXZWJLaXQvNTM3LjM2IChLSFRNTCwgbGlrZSBHZWNrbykgQ2hyb21lLzkxLjAuNDQ3Mi4xMjQgU2FmYXJpLzUzNy4zNidcbiAgICAgIH0sXG4gICAgICB0aW1lb3V0OiAzMDAwMFxuICAgIH0pO1xuXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBIVFRQICR7cmVzcG9uc2Uuc3RhdHVzfTogJHtyZXNwb25zZS5zdGF0dXNUZXh0fWApO1xuICAgIH1cblxuICAgIGNvbnN0IGh0bWwgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG5cbiAgICAvLyBFeHRyYWN0IHRpdGxlXG4gICAgY29uc3QgdGl0bGVNYXRjaCA9IGh0bWwubWF0Y2goLzx0aXRsZVtePl0qPihbXjxdKyk8XFwvdGl0bGU+L2kpO1xuICAgIGNvbnN0IHRpdGxlID0gdGl0bGVNYXRjaCA/IHRpdGxlTWF0Y2hbMV0udHJpbSgpIDogJ1VudGl0bGVkJztcblxuICAgIC8vIEJhc2ljIG1hcmtkb3duIGNvbnZlcnNpb24gKHZlcnkgc2ltcGxlKVxuICAgIGNvbnN0IG1hcmtkb3duID0gYCMgJHt0aXRsZX1cXG5cXG5Db250ZW50IHNjcmFwZWQgZnJvbSAke3VybH1cXG5cXG5bT3JpZ2luYWwgVVJMXSgke3VybH0pYDtcblxuICAgIC8vIFRyeSB0byBjYXB0dXJlIHNjcmVlbnNob3Qgd2l0aCBQdXBwZXRlZXIgaWYgcmVxdWVzdGVkXG4gICAgbGV0IHNjcmVlbnNob3QgPSBudWxsO1xuICAgIGlmIChvcHRpb25zPy5mb3JtYXRzPy5pbmNsdWRlcygnc2NyZWVuc2hvdCcpIHx8IG9wdGlvbnM/LmZvcm1hdHM/LmluY2x1ZGVzKCdzY3JlZW5zaG90QGZ1bGxQYWdlJykpIHtcbiAgICAgIHNjcmVlbnNob3QgPSBhd2FpdCBjYXB0dXJlU2NyZWVuc2hvdFdpdGhQdXBwZXRlZXIodXJsKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgZGF0YToge1xuICAgICAgICBodG1sLFxuICAgICAgICBtYXJrZG93bixcbiAgICAgICAgdGl0bGUsXG4gICAgICAgIGxpbmtzOiBbdXJsXSxcbiAgICAgICAgc2NyZWVuc2hvdFxuICAgICAgfSxcbiAgICAgIHN1Y2Nlc3M6IHRydWVcbiAgICB9O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIGZhbGxiYWNrIHNjcmFwaW5nOicsIGVycm9yKTtcbiAgICByZXR1cm4ge1xuICAgICAgZGF0YToge1xuICAgICAgICBodG1sOiAnPGh0bWw+PGJvZHk+PGgxPkVycm9yPC9oMT48cD5Db3VsZCBub3Qgc2NyYXBlIGNvbnRlbnQuPC9wPjwvYm9keT48L2h0bWw+JyxcbiAgICAgICAgbWFya2Rvd246ICcjIEVycm9yXFxuXFxuQ291bGQgbm90IHNjcmFwZSBjb250ZW50LicsXG4gICAgICAgIHRpdGxlOiAnRXJyb3InLFxuICAgICAgICBsaW5rczogW10sXG4gICAgICAgIHNjcmVlbnNob3Q6IG51bGxcbiAgICAgIH0sXG4gICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgIGVycm9yOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcilcbiAgICB9O1xuICB9XG59XG5cbi8qKlxuICogTWFwIGEgd2Vic2l0ZSB0byBkaXNjb3ZlciBhbGwgaW5kZXhlZCBVUkxzIG9uIHRoZSBzaXRlXG4gKiBAcGFyYW0gdXJsIC0gU3RhcnRpbmcgVVJMIGZvciBVUkwgZGlzY292ZXJ5XG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbmFsIGNvbmZpZ3VyYXRpb24gZm9yIHNpdGUgbWFwcGluZ1xuICogQHJldHVybnMgQXJyYXkgb2YgVVJMcyBmb3VuZCBvbiB0aGUgc2l0ZVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gbWFwV2Vic2l0ZSh1cmw6IHN0cmluZywgb3B0aW9ucz86IHtcbiAgaW5jbHVkZVN1YmRvbWFpbnM/OiBib29sZWFuO1xuICBsaW1pdD86IG51bWJlcjtcbiAgc2VhcmNoPzogc3RyaW5nO1xufSkge1xuICBjb25zdCBhcHAgPSBnZXRGaXJlY3Jhd2xDbGllbnQoKTtcblxuICBpZiAoYXBwKSB7XG4gICAgLy8gVXNlIEZpcmVjcmF3bCB3aXRoIHJldHJ5IGxvZ2ljXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCByZXRyeVdpdGhCYWNrb2ZmKGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgbWFwUmVzdWx0ID0gYXdhaXQgYXBwLm1hcFVybCh1cmwsIHtcbiAgICAgICAgICBpbmNsdWRlU3ViZG9tYWluczogb3B0aW9ucz8uaW5jbHVkZVN1YmRvbWFpbnMgfHwgZmFsc2UsXG4gICAgICAgICAgbGltaXQ6IG9wdGlvbnM/LmxpbWl0IHx8IDEwMCxcbiAgICAgICAgICBzZWFyY2g6IG9wdGlvbnM/LnNlYXJjaFxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoIW1hcFJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGaXJlY3Jhd2wgbWFwcGluZyBmYWlsZWQ6ICR7bWFwUmVzdWx0LmVycm9yfWApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1hcFJlc3VsdC5saW5rcyB8fCBbXTtcbiAgICAgIH0sIGBGaXJlY3Jhd2wgbWFwcGluZyBmb3IgJHt1cmx9YCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZpcmVjcmF3bCBtYXBwaW5nIGZhaWxlZCBhZnRlciByZXRyaWVzLCBmYWxsaW5nIGJhY2sgdG8gc2ltcGxlIG1hcHBpbmc6JywgZXJyb3IpO1xuICAgICAgcmV0dXJuIGF3YWl0IG1hcFdlYnNpdGVXaXRoRmFsbGJhY2sodXJsLCBvcHRpb25zKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2sgdG8gc2ltcGxlIGltcGxlbWVudGF0aW9uXG4gICAgY29uc29sZS5sb2coJ0ZpcmVjcmF3bCBub3QgYXZhaWxhYmxlLCB1c2luZyBzaW1wbGUgZmFsbGJhY2sgZm9yIG1hcHBpbmcnKTtcbiAgICByZXR1cm4gYXdhaXQgbWFwV2Vic2l0ZVdpdGhGYWxsYmFjayh1cmwsIG9wdGlvbnMpO1xuICB9XG59XG5cbi8qKlxuICogU2NyYXBlIGNvbnRlbnQgZnJvbSBhIHNpbmdsZSBVUkwgd2l0aCBhZHZhbmNlZCBvcHRpb25zXG4gKiBAcGFyYW0gdXJsIC0gVGhlIFVSTCB0byBzY3JhcGVcbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9uYWwgY29uZmlndXJhdGlvbiBmb3Igc2NyYXBpbmdcbiAqIEByZXR1cm5zIFNjcmFwZWQgY29udGVudCBpbiByZXF1ZXN0ZWQgZm9ybWF0c1xuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2NyYXBlV2VicGFnZSh1cmw6IHN0cmluZywgb3B0aW9ucz86IHtcbiAgZm9ybWF0cz86IHN0cmluZ1tdO1xuICBvbmx5TWFpbkNvbnRlbnQ/OiBib29sZWFuO1xuICB3YWl0Rm9yPzogbnVtYmVyO1xuICBtb2JpbGU/OiBib29sZWFuO1xuICBhY3Rpb25zPzogUmVjb3JkPHN0cmluZywgdW5rbm93bj5bXTtcbn0pIHtcbiAgY29uc3QgYXBwID0gZ2V0RmlyZWNyYXdsQ2xpZW50KCk7XG5cbiAgaWYgKGFwcCkge1xuICAgIC8vIFVzZSBGaXJlY3Jhd2wgd2l0aCByZXRyeSBsb2dpY1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgcmV0cnlXaXRoQmFja29mZihhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHNjcmFwZU9wdGlvbnM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+ID0ge1xuICAgICAgICAgIG9ubHlNYWluQ29udGVudDogb3B0aW9ucz8ub25seU1haW5Db250ZW50IHx8IGZhbHNlLFxuICAgICAgICAgIHdhaXRGb3I6IG9wdGlvbnM/LndhaXRGb3IgfHwgMzAwMCwgLy8gRXh0cmEgd2FpdCB0aW1lIGZvciBmdWxsIHBhZ2UgbG9hZCBhbmQgc2NyZWVuc2hvdHNcbiAgICAgICAgICBtb2JpbGU6IG9wdGlvbnM/Lm1vYmlsZSB8fCBmYWxzZSxcbiAgICAgICAgICBhY3Rpb25zOiBvcHRpb25zPy5hY3Rpb25zIHx8IFtdXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gU2V0IGZvcm1hdHMgLSBpbiBGaXJlY3Jhd2wgdjEsIHNjcmVlbnNob3QgaXMgYSBmb3JtYXQsIG5vdCBhIHNlcGFyYXRlIHBhcmFtZXRlclxuICAgICAgICAvLyBVc2UgZnVsbC1wYWdlIHNjcmVlbnNob3RzIGJ5IGRlZmF1bHQgZm9yIGNvbXBsZXRlIHdlYnNpdGUgY2FwdHVyZVxuICAgICAgICAvLyBOb3RlOiBjc3NDb250ZW50cyBmb3JtYXQgbm90IHN1cHBvcnRlZCBpbiBjdXJyZW50IEZpcmVjcmF3bCBBUElcbiAgICAgICAgY29uc3QgZm9ybWF0cyA9IG9wdGlvbnM/LmZvcm1hdHMgfHwgWydtYXJrZG93bicsICdodG1sJywgJ3Jhd0h0bWwnLCAnc2NyZWVuc2hvdEBmdWxsUGFnZScsICdsaW5rcyddO1xuICAgICAgICBzY3JhcGVPcHRpb25zLmZvcm1hdHMgPSBmb3JtYXRzO1xuXG4gICAgICAgIGNvbnN0IHNjcmFwZVJlc3VsdCA9IGF3YWl0IGFwcC5zY3JhcGVVcmwodXJsLCBzY3JhcGVPcHRpb25zKTtcblxuICAgICAgICBpZiAoIXNjcmFwZVJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGaXJlY3Jhd2wgc2NyYXBpbmcgZmFpbGVkOiAke3NjcmFwZVJlc3VsdC5lcnJvcn1gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERlYnVnOiBMb2cgd2hhdCBGaXJlY3Jhd2wgYWN0dWFsbHkgcmV0dXJuc1xuICAgICAgICBjb25zb2xlLmxvZyhgRmlyZWNyYXdsIHJlc3VsdCBmb3IgJHt1cmx9OmAsIHtcbiAgICAgICAgICBzdWNjZXNzOiBzY3JhcGVSZXN1bHQuc3VjY2VzcyxcbiAgICAgICAgICBkYXRhS2V5czogT2JqZWN0LmtleXMoc2NyYXBlUmVzdWx0LmRhdGEgfHwge30pLFxuICAgICAgICAgIGhhc1NjcmVlbnNob3Q6ICEhKHNjcmFwZVJlc3VsdC5kYXRhIGFzIGFueSk/LnNjcmVlbnNob3QsXG4gICAgICAgICAgc2NyZWVuc2hvdFR5cGU6IHR5cGVvZiAoc2NyYXBlUmVzdWx0LmRhdGEgYXMgYW55KT8uc2NyZWVuc2hvdCxcbiAgICAgICAgICBkYXRhU3RydWN0dXJlOiBzY3JhcGVSZXN1bHQuZGF0YSA/IE9iamVjdC5rZXlzKHNjcmFwZVJlc3VsdC5kYXRhKSA6ICdubyBkYXRhJyxcbiAgICAgICAgICBzY3JlZW5zaG90RGF0YTogKHNjcmFwZVJlc3VsdC5kYXRhIGFzIGFueSk/LnNjcmVlbnNob3QgPyAncHJlc2VudCcgOiAnbWlzc2luZydcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gSWYgc2NyZWVuc2hvdCB3YXMgcmVxdWVzdGVkIGJ1dCBub3QgY2FwdHVyZWQgYnkgRmlyZWNyYXdsLCB0cnkgUHVwcGV0ZWVyIGZhbGxiYWNrXG4gICAgICAgIGNvbnN0IHNjcmVlbnNob3RSZXF1ZXN0ZWQgPSBvcHRpb25zPy5mb3JtYXRzPy5pbmNsdWRlcygnc2NyZWVuc2hvdCcpIHx8IG9wdGlvbnM/LmZvcm1hdHM/LmluY2x1ZGVzKCdzY3JlZW5zaG90QGZ1bGxQYWdlJyk7XG4gICAgICAgIGlmIChzY3JlZW5zaG90UmVxdWVzdGVkICYmICEoc2NyYXBlUmVzdWx0LmRhdGEgYXMgYW55KT8uc2NyZWVuc2hvdCkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCfwn5SEIEZpcmVjcmF3bCBmYWlsZWQgdG8gY2FwdHVyZSBmdWxsLXBhZ2Ugc2NyZWVuc2hvdCwgdHJ5aW5nIFB1cHBldGVlciBmYWxsYmFjay4uLicpO1xuICAgICAgICAgIGNvbnN0IHB1cHBldGVlclNjcmVlbnNob3QgPSBhd2FpdCBjYXB0dXJlU2NyZWVuc2hvdFdpdGhQdXBwZXRlZXIodXJsKTtcbiAgICAgICAgICBpZiAocHVwcGV0ZWVyU2NyZWVuc2hvdCkge1xuICAgICAgICAgICAgKHNjcmFwZVJlc3VsdC5kYXRhIGFzIGFueSkuc2NyZWVuc2hvdCA9IHB1cHBldGVlclNjcmVlbnNob3Q7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygn4pyFIFB1cHBldGVlciBmYWxsYmFjayBmdWxsLXBhZ2Ugc2NyZWVuc2hvdCBzdWNjZXNzZnVsJyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCfinYwgQm90aCBGaXJlY3Jhd2wgYW5kIFB1cHBldGVlciBmdWxsLXBhZ2Ugc2NyZWVuc2hvdCBjYXB0dXJlIGZhaWxlZCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzY3JhcGVSZXN1bHQ7XG4gICAgICB9LCBgRmlyZWNyYXdsIHNjcmFwaW5nIGZvciAke3VybH1gKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRmlyZWNyYXdsIHNjcmFwaW5nIGZhaWxlZCBhZnRlciByZXRyaWVzLCBmYWxsaW5nIGJhY2sgdG8gc2ltcGxlIHNjcmFwaW5nOicsIGVycm9yKTtcbiAgICAgIHJldHVybiBhd2FpdCBzY3JhcGVXZWJwYWdlV2l0aEZhbGxiYWNrKHVybCwgb3B0aW9ucyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrIHRvIHNpbXBsZSBpbXBsZW1lbnRhdGlvblxuICAgIGNvbnNvbGUubG9nKCdGaXJlY3Jhd2wgbm90IGF2YWlsYWJsZSwgdXNpbmcgc2ltcGxlIGZhbGxiYWNrIGZvciBzY3JhcGluZycpO1xuICAgIHJldHVybiBhd2FpdCBzY3JhcGVXZWJwYWdlV2l0aEZhbGxiYWNrKHVybCwgb3B0aW9ucyk7XG4gIH1cbn1cblxuLyoqXG4gKiBFeHRyYWN0IHN0cnVjdHVyZWQgaW5mb3JtYXRpb24gZnJvbSB3ZWIgcGFnZXMgdXNpbmcgTExNIGNhcGFiaWxpdGllc1xuICogQHBhcmFtIHVybHMgLSBBcnJheSBvZiBVUkxzIHRvIGV4dHJhY3QgaW5mb3JtYXRpb24gZnJvbVxuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25hbCBjb25maWd1cmF0aW9uIGZvciBleHRyYWN0aW9uXG4gKiBAcmV0dXJucyBFeHRyYWN0ZWQgc3RydWN0dXJlZCBkYXRhXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBleHRyYWN0U3RydWN0dXJlZERhdGEodXJsczogc3RyaW5nW10sIG9wdGlvbnM/OiB7XG4gIHByb21wdD86IHN0cmluZztcbiAgc3lzdGVtUHJvbXB0Pzogc3RyaW5nO1xuICBzY2hlbWE/OiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPjtcbn0pIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBhcHAgPSBnZXRGaXJlY3Jhd2xDbGllbnQoKTtcblxuICAgIC8vIEZvciBub3csIHdlJ2xsIGV4dHJhY3QgZnJvbSB0aGUgZmlyc3QgVVJMIG9ubHlcbiAgICAvLyBJbiBhIGZ1bGwgaW1wbGVtZW50YXRpb24sIHdlJ2QgcHJvY2VzcyBhbGwgVVJMc1xuICAgIGNvbnN0IHVybCA9IHVybHNbMF07XG4gICAgaWYgKCF1cmwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gVVJMcyBwcm92aWRlZCBmb3IgZXh0cmFjdGlvbicpO1xuICAgIH1cblxuICAgIGlmIChhcHApIHtcbiAgICAgIC8vIFVzZSBGaXJlY3Jhd2wgaWYgYXZhaWxhYmxlXG4gICAgICBjb25zdCBleHRyYWN0T3B0aW9ucyA9IHtcbiAgICAgICAgcHJvbXB0OiBvcHRpb25zPy5wcm9tcHQgfHwgJ0V4dHJhY3QgYWxsIHJlbGV2YW50IGluZm9ybWF0aW9uIGZyb20gdGhpcyB3ZWJwYWdlJyxcbiAgICAgICAgc2NoZW1hOiBvcHRpb25zPy5zY2hlbWEgfHwge1xuICAgICAgICAgIHR5cGU6ICdvYmplY3QnLFxuICAgICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgIHRpdGxlOiB7IHR5cGU6ICdzdHJpbmcnIH0sXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogeyB0eXBlOiAnc3RyaW5nJyB9LFxuICAgICAgICAgICAgY29udGVudDogeyB0eXBlOiAnc3RyaW5nJyB9LFxuICAgICAgICAgICAgdGVjaG5vbG9naWVzOiB7XG4gICAgICAgICAgICAgIHR5cGU6ICdhcnJheScsXG4gICAgICAgICAgICAgIGl0ZW1zOiB7IHR5cGU6ICdzdHJpbmcnIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IGV4dHJhY3RSZXN1bHQgPSBhd2FpdCBhcHAuZXh0cmFjdChbdXJsXSwgZXh0cmFjdE9wdGlvbnMpO1xuXG4gICAgICBpZiAoIWV4dHJhY3RSZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZpcmVjcmF3bCBleHRyYWN0aW9uIGZhaWxlZDogJHtleHRyYWN0UmVzdWx0LmVycm9yfWApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZXh0cmFjdFJlc3VsdDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRmFsbGJhY2sgaW1wbGVtZW50YXRpb24gLSByZXR1cm4gYmFzaWMgc3RydWN0dXJlZCBkYXRhXG4gICAgICBjb25zb2xlLmxvZygnRmlyZWNyYXdsIG5vdCBhdmFpbGFibGUsIHVzaW5nIGJhc2ljIGZhbGxiYWNrIGZvciBleHRyYWN0aW9uJyk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0ZWNobm9sb2dpZXM6IFsnSFRNTCcsICdDU1MnLCAnSmF2YVNjcmlwdCddLFxuICAgICAgICBkZXNpZ25QYXR0ZXJuczogWydSZXNwb25zaXZlIERlc2lnbiddLFxuICAgICAgICBrZXlGZWF0dXJlczogWydXZWIgQ29udGVudCddLFxuICAgICAgICBjb2xvclBhbGV0dGU6IFsnIzAwMDAwMCcsICcjZmZmZmZmJ10sXG4gICAgICAgIGZvbnRGYW1pbGllczogWydBcmlhbCcsICdzYW5zLXNlcmlmJ11cbiAgICAgIH07XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGV4dHJhY3Rpbmcgc3RydWN0dXJlZCBkYXRhOicsIGVycm9yKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBleHRyYWN0IHN0cnVjdHVyZWQgZGF0YTogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcil9YCk7XG4gIH1cbn1cblxuLyoqXG4gKiBDb25kdWN0IGRlZXAgd2ViIHJlc2VhcmNoIG9uIGEgcXVlcnkgdXNpbmcgaW50ZWxsaWdlbnQgY3Jhd2xpbmcsIHNlYXJjaCwgYW5kIExMTSBhbmFseXNpc1xuICogQHBhcmFtIHF1ZXJ5IC0gVGhlIHJlc2VhcmNoIHF1ZXN0aW9uIG9yIHRvcGljIHRvIGV4cGxvcmVcbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9uYWwgY29uZmlndXJhdGlvbiBmb3IgcmVzZWFyY2hcbiAqIEByZXR1cm5zIEZpbmFsIGFuYWx5c2lzIGFuZCByZXNlYXJjaCBwcm9jZXNzIGRldGFpbHNcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNvbmR1Y3REZWVwUmVzZWFyY2gocXVlcnk6IHN0cmluZywgb3B0aW9ucz86IHtcbiAgbWF4RGVwdGg/OiBudW1iZXI7XG4gIHRpbWVMaW1pdD86IG51bWJlcjtcbiAgbWF4VXJscz86IG51bWJlcjtcbn0pIHtcbiAgdHJ5IHtcbiAgICAvLyBGb3IgTVZQLCB3ZSdsbCBpbXBsZW1lbnQgYSBzaW1wbGUgdmVyc2lvblxuICAgIC8vIEluIHByb2R1Y3Rpb24sIHRoaXMgd291bGQgdXNlIEZpcmVjcmF3bCdzIHJlc2VhcmNoIGNhcGFiaWxpdGllc1xuICAgIGNvbnNvbGUubG9nKGBDb25kdWN0aW5nIHJlc2VhcmNoIGZvciBxdWVyeTogJHtxdWVyeX1gKTtcblxuICAgIHJldHVybiB7XG4gICAgICBxdWVyeSxcbiAgICAgIHJlc3VsdHM6IFtdLFxuICAgICAgc3VtbWFyeTogYFJlc2VhcmNoIGNvbXBsZXRlZCBmb3I6ICR7cXVlcnl9YCxcbiAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgIG1heERlcHRoOiBvcHRpb25zPy5tYXhEZXB0aCB8fCAzLFxuICAgICAgICB0aW1lTGltaXQ6IG9wdGlvbnM/LnRpbWVMaW1pdCB8fCAxMjAsXG4gICAgICAgIG1heFVybHM6IG9wdGlvbnM/Lm1heFVybHMgfHwgNTBcbiAgICAgIH1cbiAgICB9O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNvbmR1Y3RpbmcgZGVlcCByZXNlYXJjaDonLCBlcnJvcik7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gY29uZHVjdCBkZWVwIHJlc2VhcmNoOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKX1gKTtcbiAgfVxufSJdLCJuYW1lcyI6WyJGaXJlY3Jhd2xBcHAiLCJleGVjIiwicHJvbWlzaWZ5IiwiZXhlY0FzeW5jIiwiUkVUUllfQ09ORklHIiwibWF4QXR0ZW1wdHMiLCJiYXNlRGVsYXkiLCJtYXhEZWxheSIsImdldEZpcmVjcmF3bENsaWVudCIsImFwaUtleSIsInByb2Nlc3MiLCJlbnYiLCJGSVJFQ1JBV0xfQVBJX0tFWSIsInNsZWVwIiwibXMiLCJQcm9taXNlIiwicmVzb2x2ZSIsInNldFRpbWVvdXQiLCJyZXRyeVdpdGhCYWNrb2ZmIiwib3BlcmF0aW9uIiwiY29udGV4dCIsImxhc3RFcnJvciIsImF0dGVtcHQiLCJjb25zb2xlIiwibG9nIiwiZXJyb3IiLCJFcnJvciIsIm1lc3NhZ2UiLCJTdHJpbmciLCJkZWxheSIsIk1hdGgiLCJtaW4iLCJwb3ciLCJtYXBXZWJzaXRlV2l0aEZhbGxiYWNrIiwidXJsIiwiX29wdGlvbnMiLCJjYXB0dXJlU2NyZWVuc2hvdFdpdGhQdXBwZXRlZXIiLCJwdXBwZXRlZXIiLCJicm93c2VyIiwiZGVmYXVsdCIsImxhdW5jaCIsImhlYWRsZXNzIiwiYXJncyIsInBhZ2UiLCJuZXdQYWdlIiwic2V0Vmlld3BvcnQiLCJ3aWR0aCIsImhlaWdodCIsImdvdG8iLCJ3YWl0VW50aWwiLCJ0aW1lb3V0Iiwic2NyZWVuc2hvdCIsImZ1bGxQYWdlIiwiZW5jb2RpbmciLCJ0eXBlIiwiY2xvc2UiLCJzY3JlZW5zaG90RGF0YSIsInBhZ2VFcnJvciIsInNjcmFwZVdlYnBhZ2VXaXRoRmFsbGJhY2siLCJvcHRpb25zIiwicmVzcG9uc2UiLCJmZXRjaCIsImhlYWRlcnMiLCJvayIsInN0YXR1cyIsInN0YXR1c1RleHQiLCJodG1sIiwidGV4dCIsInRpdGxlTWF0Y2giLCJtYXRjaCIsInRpdGxlIiwidHJpbSIsIm1hcmtkb3duIiwiZm9ybWF0cyIsImluY2x1ZGVzIiwiZGF0YSIsImxpbmtzIiwic3VjY2VzcyIsIm1hcFdlYnNpdGUiLCJhcHAiLCJtYXBSZXN1bHQiLCJtYXBVcmwiLCJpbmNsdWRlU3ViZG9tYWlucyIsImxpbWl0Iiwic2VhcmNoIiwic2NyYXBlV2VicGFnZSIsInNjcmFwZU9wdGlvbnMiLCJvbmx5TWFpbkNvbnRlbnQiLCJ3YWl0Rm9yIiwibW9iaWxlIiwiYWN0aW9ucyIsInNjcmFwZVJlc3VsdCIsInNjcmFwZVVybCIsImRhdGFLZXlzIiwiT2JqZWN0Iiwia2V5cyIsImhhc1NjcmVlbnNob3QiLCJzY3JlZW5zaG90VHlwZSIsImRhdGFTdHJ1Y3R1cmUiLCJzY3JlZW5zaG90UmVxdWVzdGVkIiwicHVwcGV0ZWVyU2NyZWVuc2hvdCIsImV4dHJhY3RTdHJ1Y3R1cmVkRGF0YSIsInVybHMiLCJleHRyYWN0T3B0aW9ucyIsInByb21wdCIsInNjaGVtYSIsInByb3BlcnRpZXMiLCJkZXNjcmlwdGlvbiIsImNvbnRlbnQiLCJ0ZWNobm9sb2dpZXMiLCJpdGVtcyIsImV4dHJhY3RSZXN1bHQiLCJleHRyYWN0IiwiZGVzaWduUGF0dGVybnMiLCJrZXlGZWF0dXJlcyIsImNvbG9yUGFsZXR0ZSIsImZvbnRGYW1pbGllcyIsImNvbmR1Y3REZWVwUmVzZWFyY2giLCJxdWVyeSIsInJlc3VsdHMiLCJzdW1tYXJ5IiwibWV0YWRhdGEiLCJtYXhEZXB0aCIsInRpbWVMaW1pdCIsIm1heFVybHMiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./lib/mcp-utils.ts\n");

/***/ }),

/***/ "(rsc)/./lib/prisma-utils.ts":
/*!*****************************!*\
  !*** ./lib/prisma-utils.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   cleanupOldAnalysisRequests: () => (/* binding */ cleanupOldAnalysisRequests),\n/* harmony export */   createWebsiteAnalysisRequest: () => (/* binding */ createWebsiteAnalysisRequest),\n/* harmony export */   deleteWebsiteAnalysisRequest: () => (/* binding */ deleteWebsiteAnalysisRequest),\n/* harmony export */   getFailedAnalysisRequests: () => (/* binding */ getFailedAnalysisRequests),\n/* harmony export */   getResumableAnalysisRequests: () => (/* binding */ getResumableAnalysisRequests),\n/* harmony export */   getWebsiteAnalysisById: () => (/* binding */ getWebsiteAnalysisById),\n/* harmony export */   listWebsiteAnalysisRequests: () => (/* binding */ listWebsiteAnalysisRequests),\n/* harmony export */   markAnalysisAsFailed: () => (/* binding */ markAnalysisAsFailed),\n/* harmony export */   updateWebsiteAnalysisStatus: () => (/* binding */ updateWebsiteAnalysisStatus)\n/* harmony export */ });\n/* harmony import */ var _prisma_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @prisma/client */ \"@prisma/client\");\n/* harmony import */ var _prisma_client__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_prisma_client__WEBPACK_IMPORTED_MODULE_0__);\n\nconst prisma = new _prisma_client__WEBPACK_IMPORTED_MODULE_0__.PrismaClient();\n/**\n * Create a new website analysis request\n * @param url - The URL to analyze\n * @param options - Optional scraping configuration\n * @returns The created analysis record\n */ async function createWebsiteAnalysisRequest(url, options) {\n    try {\n        const analysis = await prisma.websiteAnalysis.create({\n            data: {\n                url,\n                status: 'PENDING',\n                result: options ? JSON.parse(JSON.stringify(options)) : undefined\n            }\n        });\n        return analysis;\n    } catch (error) {\n        console.error('Error creating website analysis request:', error?.toString() || 'Unknown error');\n        throw error;\n    }\n}\n/**\n * Get a website analysis by ID\n * @param id - The analysis ID\n * @returns The analysis record\n */ async function getWebsiteAnalysisById(id) {\n    try {\n        return await prisma.websiteAnalysis.findUnique({\n            where: {\n                id\n            }\n        });\n    } catch (error) {\n        console.error('Error fetching website analysis:', error?.toString() || 'Unknown error');\n        throw error;\n    }\n}\n/**\n * Update a website analysis status and optional result\n * @param id - The analysis ID\n * @param status - The new status\n * @param result - Optional result data\n * @param error - Optional error message\n * @param processingTime - Optional processing time in seconds\n * @returns The updated analysis record\n */ async function updateWebsiteAnalysisStatus(id, status, result, error, processingTime) {\n    try {\n        return await prisma.websiteAnalysis.update({\n            where: {\n                id\n            },\n            data: {\n                status,\n                result: result ? JSON.parse(JSON.stringify(result)) : undefined,\n                error,\n                processingTime\n            }\n        });\n    } catch (dbError) {\n        console.error('Error updating website analysis:', dbError?.toString() || 'Unknown error');\n        throw dbError;\n    }\n}\n/**\n * List website analysis requests with pagination\n * @param limit - Maximum number of records to return\n * @param skip - Number of records to skip\n * @returns List of analysis records\n */ async function listWebsiteAnalysisRequests(limit = 10, skip = 0) {\n    try {\n        return await prisma.websiteAnalysis.findMany({\n            take: limit,\n            skip,\n            orderBy: {\n                createdAt: 'desc'\n            }\n        });\n    } catch (error) {\n        console.error('Error listing website analyses:', error?.toString() || 'Unknown error');\n        throw error;\n    }\n}\n/**\n * Delete a website analysis request and all related data\n * @param id - The analysis ID\n * @returns The deleted analysis record\n */ async function deleteWebsiteAnalysisRequest(id) {\n    try {\n        return await prisma.websiteAnalysis.delete({\n            where: {\n                id\n            }\n        });\n    } catch (error) {\n        console.error('Error deleting website analysis:', error?.toString() || 'Unknown error');\n        throw error;\n    }\n}\n/**\n * Get failed analysis requests that can be resumed\n * @param limit - Maximum number of records to return\n * @returns List of failed analysis records\n */ async function getFailedAnalysisRequests(limit = 10) {\n    try {\n        return await prisma.websiteAnalysis.findMany({\n            where: {\n                status: 'FAILED'\n            },\n            take: limit,\n            orderBy: {\n                createdAt: 'desc'\n            }\n        });\n    } catch (error) {\n        console.error('Error fetching failed analysis requests:', error?.toString() || 'Unknown error');\n        throw error;\n    }\n}\n/**\n * Get analysis requests that can be resumed (failed or incomplete)\n * @param url - Optional URL filter\n * @returns List of resumable analysis records\n */ async function getResumableAnalysisRequests(url) {\n    try {\n        const where = {\n            status: {\n                in: [\n                    'FAILED',\n                    'MAPPING',\n                    'SCRAPING',\n                    'PROCESSING'\n                ]\n            }\n        };\n        if (url) {\n            where.url = url;\n        }\n        return await prisma.websiteAnalysis.findMany({\n            where,\n            orderBy: {\n                createdAt: 'desc'\n            }\n        });\n    } catch (error) {\n        console.error('Error fetching resumable analysis requests:', error?.toString() || 'Unknown error');\n        throw error;\n    }\n}\n/**\n * Mark analysis as failed with detailed error information\n * @param id - The analysis ID\n * @param error - Error message\n * @param processingTime - Optional processing time in seconds\n * @returns The updated analysis record\n */ async function markAnalysisAsFailed(id, error, processingTime) {\n    try {\n        return await updateWebsiteAnalysisStatus(id, 'FAILED', undefined, error, processingTime);\n    } catch (dbError) {\n        console.error('Error marking analysis as failed:', dbError?.toString() || 'Unknown error');\n        throw dbError;\n    }\n}\n/**\n * Cleanup old or completed analysis requests\n * @param daysOld - Age in days to consider for cleanup\n * @returns Count of deleted records\n */ async function cleanupOldAnalysisRequests(daysOld = 7) {\n    try {\n        const cutoffDate = new Date(Date.now() - daysOld * 24 * 60 * 60 * 1000);\n        return await prisma.websiteAnalysis.deleteMany({\n            where: {\n                createdAt: {\n                    lt: cutoffDate\n                },\n                OR: [\n                    {\n                        status: 'COMPLETED'\n                    },\n                    {\n                        status: 'FAILED'\n                    }\n                ]\n            }\n        });\n    } catch (error) {\n        console.error('Error cleaning up old analysis requests:', error?.toString() || 'Unknown error');\n        throw error;\n    }\n} // Note: The following functions will be implemented after running prisma generate\n // to update the client with the new schema. For now, we'll comment them out to avoid TypeScript errors.\n /*\n * Create a website page record\n * @param analysisId - The parent analysis ID\n * @param pageData - The page data\n * @returns The created page record\n */  /*\nexport async function createWebsitePage(analysisId: string, pageData: {\n  url: string;\n  title?: string;\n  htmlContent?: string;\n  markdownContent?: string;\n  screenshotPath?: string;\n  metadata?: any;\n}) {\n  try {\n    return await prisma.websitePage.create({\n      data: {\n        ...pageData,\n        metadata: pageData.metadata ? JSON.parse(JSON.stringify(pageData.metadata)) : undefined,\n        analysis: {\n          connect: { id: analysisId }\n        }\n      }\n    })\n  } catch (error) {\n    console.error('Error creating website page:', error)\n    throw error\n  }\n}\n*/  /*\n * Create a website asset record\n * @param analysisId - The parent analysis ID\n * @param assetData - The asset data\n * @param pageIds - Optional IDs of pages to connect this asset to\n * @returns The created asset record\n */  /*\nexport async function createWebsiteAsset(\n  analysisId: string,\n  assetData: {\n    url: string;\n    type: AssetType;\n    content?: string;\n    metadata?: any;\n  },\n  pageIds?: string[]\n) {\n  try {\n    return await prisma.websiteAsset.create({\n      data: {\n        ...assetData,\n        metadata: assetData.metadata ? JSON.parse(JSON.stringify(assetData.metadata)) : undefined,\n        analysis: {\n          connect: { id: analysisId }\n        },\n        pages: pageIds?.length ? {\n          connect: pageIds.map(id => ({ id }))\n        } : undefined\n      }\n    })\n  } catch (error) {\n    console.error('Error creating website asset:', error)\n    throw error\n  }\n}\n*/  /*\n * Create or update performance data for an analysis\n * @param analysisId - The parent analysis ID\n * @param performanceData - The performance data\n * @returns The created or updated performance record\n */  /*\nexport async function upsertPerformanceData(\n  analysisId: string,\n  performanceData: {\n    performanceScore?: number;\n    accessibilityScore?: number;\n    seoScore?: number;\n    bestPracticesScore?: number;\n    lighthouseData?: any;\n  }\n) {\n  try {\n    return await prisma.performanceData.upsert({\n      where: { analysisId },\n      update: {\n        ...performanceData,\n        lighthouseData: performanceData.lighthouseData\n          ? JSON.parse(JSON.stringify(performanceData.lighthouseData))\n          : undefined\n      },\n      create: {\n        ...performanceData,\n        lighthouseData: performanceData.lighthouseData\n          ? JSON.parse(JSON.stringify(performanceData.lighthouseData))\n          : undefined,\n        analysis: {\n          connect: { id: analysisId }\n        }\n      }\n    })\n  } catch (error) {\n    console.error('Error upserting performance data:', error)\n    throw error\n  }\n}\n*/ \n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUF3QkEsSUFFQTs7Ozs7O0NBTUMsSUFDRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE2QkEsSUFFQTs7Ozs7Q0FLQyxJQUNEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW1DQSIsInNvdXJjZXMiOlsiL1VzZXJzL2RlYW5uZXd0b24vRG9jdW1lbnRzL3hyYXkvbGliL3ByaXNtYS11dGlscy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBQcmlzbWFDbGllbnQgfSBmcm9tICdAcHJpc21hL2NsaWVudCdcblxuLy8gRGVmaW5lIGVudW0gdHlwZXMgdW50aWwgUHJpc21hIGdlbmVyYXRlcyB0aGVtXG50eXBlIEFuYWx5c2lzU3RhdHVzID0gJ1BFTkRJTkcnIHwgJ01BUFBJTkcnIHwgJ1NDUkFQSU5HJyB8ICdQUk9DRVNTSU5HJyB8ICdDT01QTEVURUQnIHwgJ0ZBSUxFRCc7XG5cbmNvbnN0IHByaXNtYSA9IG5ldyBQcmlzbWFDbGllbnQoKVxuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyB3ZWJzaXRlIGFuYWx5c2lzIHJlcXVlc3RcbiAqIEBwYXJhbSB1cmwgLSBUaGUgVVJMIHRvIGFuYWx5emVcbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9uYWwgc2NyYXBpbmcgY29uZmlndXJhdGlvblxuICogQHJldHVybnMgVGhlIGNyZWF0ZWQgYW5hbHlzaXMgcmVjb3JkXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjcmVhdGVXZWJzaXRlQW5hbHlzaXNSZXF1ZXN0KHVybDogc3RyaW5nLCBvcHRpb25zPzogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBhbmFseXNpcyA9IGF3YWl0IHByaXNtYS53ZWJzaXRlQW5hbHlzaXMuY3JlYXRlKHtcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgdXJsLFxuICAgICAgICBzdGF0dXM6ICdQRU5ESU5HJyBhcyBBbmFseXNpc1N0YXR1cyxcbiAgICAgICAgcmVzdWx0OiBvcHRpb25zID8gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShvcHRpb25zKSkgOiB1bmRlZmluZWRcbiAgICAgIH1cbiAgICB9KVxuICAgIHJldHVybiBhbmFseXNpc1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNyZWF0aW5nIHdlYnNpdGUgYW5hbHlzaXMgcmVxdWVzdDonLCBlcnJvcj8udG9TdHJpbmcoKSB8fCAnVW5rbm93biBlcnJvcicpXG4gICAgdGhyb3cgZXJyb3JcbiAgfVxufVxuXG4vKipcbiAqIEdldCBhIHdlYnNpdGUgYW5hbHlzaXMgYnkgSURcbiAqIEBwYXJhbSBpZCAtIFRoZSBhbmFseXNpcyBJRFxuICogQHJldHVybnMgVGhlIGFuYWx5c2lzIHJlY29yZFxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0V2Vic2l0ZUFuYWx5c2lzQnlJZChpZDogc3RyaW5nKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGF3YWl0IHByaXNtYS53ZWJzaXRlQW5hbHlzaXMuZmluZFVuaXF1ZSh7XG4gICAgICB3aGVyZTogeyBpZCB9XG4gICAgfSlcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyB3ZWJzaXRlIGFuYWx5c2lzOicsIGVycm9yPy50b1N0cmluZygpIHx8ICdVbmtub3duIGVycm9yJylcbiAgICB0aHJvdyBlcnJvclxuICB9XG59XG5cbi8qKlxuICogVXBkYXRlIGEgd2Vic2l0ZSBhbmFseXNpcyBzdGF0dXMgYW5kIG9wdGlvbmFsIHJlc3VsdFxuICogQHBhcmFtIGlkIC0gVGhlIGFuYWx5c2lzIElEXG4gKiBAcGFyYW0gc3RhdHVzIC0gVGhlIG5ldyBzdGF0dXNcbiAqIEBwYXJhbSByZXN1bHQgLSBPcHRpb25hbCByZXN1bHQgZGF0YVxuICogQHBhcmFtIGVycm9yIC0gT3B0aW9uYWwgZXJyb3IgbWVzc2FnZVxuICogQHBhcmFtIHByb2Nlc3NpbmdUaW1lIC0gT3B0aW9uYWwgcHJvY2Vzc2luZyB0aW1lIGluIHNlY29uZHNcbiAqIEByZXR1cm5zIFRoZSB1cGRhdGVkIGFuYWx5c2lzIHJlY29yZFxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdXBkYXRlV2Vic2l0ZUFuYWx5c2lzU3RhdHVzKFxuICBpZDogc3RyaW5nLFxuICBzdGF0dXM6ICdQRU5ESU5HJyB8ICdNQVBQSU5HJyB8ICdTQ1JBUElORycgfCAnUFJPQ0VTU0lORycgfCAnQ09NUExFVEVEJyB8ICdGQUlMRUQnLFxuICByZXN1bHQ/OiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPixcbiAgZXJyb3I/OiBzdHJpbmcsXG4gIHByb2Nlc3NpbmdUaW1lPzogbnVtYmVyXG4pIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gYXdhaXQgcHJpc21hLndlYnNpdGVBbmFseXNpcy51cGRhdGUoe1xuICAgICAgd2hlcmU6IHsgaWQgfSxcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgc3RhdHVzLFxuICAgICAgICByZXN1bHQ6IHJlc3VsdCA/IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkocmVzdWx0KSkgOiB1bmRlZmluZWQsXG4gICAgICAgIGVycm9yLFxuICAgICAgICBwcm9jZXNzaW5nVGltZVxuICAgICAgfVxuICAgIH0pXG4gIH0gY2F0Y2ggKGRiRXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciB1cGRhdGluZyB3ZWJzaXRlIGFuYWx5c2lzOicsIGRiRXJyb3I/LnRvU3RyaW5nKCkgfHwgJ1Vua25vd24gZXJyb3InKVxuICAgIHRocm93IGRiRXJyb3JcbiAgfVxufVxuXG4vKipcbiAqIExpc3Qgd2Vic2l0ZSBhbmFseXNpcyByZXF1ZXN0cyB3aXRoIHBhZ2luYXRpb25cbiAqIEBwYXJhbSBsaW1pdCAtIE1heGltdW0gbnVtYmVyIG9mIHJlY29yZHMgdG8gcmV0dXJuXG4gKiBAcGFyYW0gc2tpcCAtIE51bWJlciBvZiByZWNvcmRzIHRvIHNraXBcbiAqIEByZXR1cm5zIExpc3Qgb2YgYW5hbHlzaXMgcmVjb3Jkc1xuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gbGlzdFdlYnNpdGVBbmFseXNpc1JlcXVlc3RzKGxpbWl0ID0gMTAsIHNraXAgPSAwKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGF3YWl0IHByaXNtYS53ZWJzaXRlQW5hbHlzaXMuZmluZE1hbnkoe1xuICAgICAgdGFrZTogbGltaXQsXG4gICAgICBza2lwLFxuICAgICAgb3JkZXJCeTogeyBjcmVhdGVkQXQ6ICdkZXNjJyB9XG4gICAgfSlcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBsaXN0aW5nIHdlYnNpdGUgYW5hbHlzZXM6JywgZXJyb3I/LnRvU3RyaW5nKCkgfHwgJ1Vua25vd24gZXJyb3InKVxuICAgIHRocm93IGVycm9yXG4gIH1cbn1cblxuLyoqXG4gKiBEZWxldGUgYSB3ZWJzaXRlIGFuYWx5c2lzIHJlcXVlc3QgYW5kIGFsbCByZWxhdGVkIGRhdGFcbiAqIEBwYXJhbSBpZCAtIFRoZSBhbmFseXNpcyBJRFxuICogQHJldHVybnMgVGhlIGRlbGV0ZWQgYW5hbHlzaXMgcmVjb3JkXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBkZWxldGVXZWJzaXRlQW5hbHlzaXNSZXF1ZXN0KGlkOiBzdHJpbmcpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gYXdhaXQgcHJpc21hLndlYnNpdGVBbmFseXNpcy5kZWxldGUoe1xuICAgICAgd2hlcmU6IHsgaWQgfVxuICAgIH0pXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZGVsZXRpbmcgd2Vic2l0ZSBhbmFseXNpczonLCBlcnJvcj8udG9TdHJpbmcoKSB8fCAnVW5rbm93biBlcnJvcicpXG4gICAgdGhyb3cgZXJyb3JcbiAgfVxufVxuXG4vKipcbiAqIEdldCBmYWlsZWQgYW5hbHlzaXMgcmVxdWVzdHMgdGhhdCBjYW4gYmUgcmVzdW1lZFxuICogQHBhcmFtIGxpbWl0IC0gTWF4aW11bSBudW1iZXIgb2YgcmVjb3JkcyB0byByZXR1cm5cbiAqIEByZXR1cm5zIExpc3Qgb2YgZmFpbGVkIGFuYWx5c2lzIHJlY29yZHNcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEZhaWxlZEFuYWx5c2lzUmVxdWVzdHMobGltaXQgPSAxMCkge1xuICB0cnkge1xuICAgIHJldHVybiBhd2FpdCBwcmlzbWEud2Vic2l0ZUFuYWx5c2lzLmZpbmRNYW55KHtcbiAgICAgIHdoZXJlOiB7IHN0YXR1czogJ0ZBSUxFRCcgfSxcbiAgICAgIHRha2U6IGxpbWl0LFxuICAgICAgb3JkZXJCeTogeyBjcmVhdGVkQXQ6ICdkZXNjJyB9XG4gICAgfSlcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBmYWlsZWQgYW5hbHlzaXMgcmVxdWVzdHM6JywgZXJyb3I/LnRvU3RyaW5nKCkgfHwgJ1Vua25vd24gZXJyb3InKVxuICAgIHRocm93IGVycm9yXG4gIH1cbn1cblxuLyoqXG4gKiBHZXQgYW5hbHlzaXMgcmVxdWVzdHMgdGhhdCBjYW4gYmUgcmVzdW1lZCAoZmFpbGVkIG9yIGluY29tcGxldGUpXG4gKiBAcGFyYW0gdXJsIC0gT3B0aW9uYWwgVVJMIGZpbHRlclxuICogQHJldHVybnMgTGlzdCBvZiByZXN1bWFibGUgYW5hbHlzaXMgcmVjb3Jkc1xuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0UmVzdW1hYmxlQW5hbHlzaXNSZXF1ZXN0cyh1cmw/OiBzdHJpbmcpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCB3aGVyZTogYW55ID0ge1xuICAgICAgc3RhdHVzOiB7IGluOiBbJ0ZBSUxFRCcsICdNQVBQSU5HJywgJ1NDUkFQSU5HJywgJ1BST0NFU1NJTkcnXSB9XG4gICAgfVxuXG4gICAgaWYgKHVybCkge1xuICAgICAgd2hlcmUudXJsID0gdXJsXG4gICAgfVxuXG4gICAgcmV0dXJuIGF3YWl0IHByaXNtYS53ZWJzaXRlQW5hbHlzaXMuZmluZE1hbnkoe1xuICAgICAgd2hlcmUsXG4gICAgICBvcmRlckJ5OiB7IGNyZWF0ZWRBdDogJ2Rlc2MnIH1cbiAgICB9KVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIHJlc3VtYWJsZSBhbmFseXNpcyByZXF1ZXN0czonLCBlcnJvcj8udG9TdHJpbmcoKSB8fCAnVW5rbm93biBlcnJvcicpXG4gICAgdGhyb3cgZXJyb3JcbiAgfVxufVxuXG4vKipcbiAqIE1hcmsgYW5hbHlzaXMgYXMgZmFpbGVkIHdpdGggZGV0YWlsZWQgZXJyb3IgaW5mb3JtYXRpb25cbiAqIEBwYXJhbSBpZCAtIFRoZSBhbmFseXNpcyBJRFxuICogQHBhcmFtIGVycm9yIC0gRXJyb3IgbWVzc2FnZVxuICogQHBhcmFtIHByb2Nlc3NpbmdUaW1lIC0gT3B0aW9uYWwgcHJvY2Vzc2luZyB0aW1lIGluIHNlY29uZHNcbiAqIEByZXR1cm5zIFRoZSB1cGRhdGVkIGFuYWx5c2lzIHJlY29yZFxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gbWFya0FuYWx5c2lzQXNGYWlsZWQoXG4gIGlkOiBzdHJpbmcsXG4gIGVycm9yOiBzdHJpbmcsXG4gIHByb2Nlc3NpbmdUaW1lPzogbnVtYmVyXG4pIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gYXdhaXQgdXBkYXRlV2Vic2l0ZUFuYWx5c2lzU3RhdHVzKGlkLCAnRkFJTEVEJywgdW5kZWZpbmVkLCBlcnJvciwgcHJvY2Vzc2luZ1RpbWUpXG4gIH0gY2F0Y2ggKGRiRXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBtYXJraW5nIGFuYWx5c2lzIGFzIGZhaWxlZDonLCBkYkVycm9yPy50b1N0cmluZygpIHx8ICdVbmtub3duIGVycm9yJylcbiAgICB0aHJvdyBkYkVycm9yXG4gIH1cbn1cblxuLyoqXG4gKiBDbGVhbnVwIG9sZCBvciBjb21wbGV0ZWQgYW5hbHlzaXMgcmVxdWVzdHNcbiAqIEBwYXJhbSBkYXlzT2xkIC0gQWdlIGluIGRheXMgdG8gY29uc2lkZXIgZm9yIGNsZWFudXBcbiAqIEByZXR1cm5zIENvdW50IG9mIGRlbGV0ZWQgcmVjb3Jkc1xuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY2xlYW51cE9sZEFuYWx5c2lzUmVxdWVzdHMoZGF5c09sZCA9IDcpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBjdXRvZmZEYXRlID0gbmV3IERhdGUoRGF0ZS5ub3coKSAtIGRheXNPbGQgKiAyNCAqIDYwICogNjAgKiAxMDAwKVxuICAgIHJldHVybiBhd2FpdCBwcmlzbWEud2Vic2l0ZUFuYWx5c2lzLmRlbGV0ZU1hbnkoe1xuICAgICAgd2hlcmU6IHtcbiAgICAgICAgY3JlYXRlZEF0OiB7IGx0OiBjdXRvZmZEYXRlIH0sXG4gICAgICAgIE9SOiBbXG4gICAgICAgICAgeyBzdGF0dXM6ICdDT01QTEVURUQnIH0sXG4gICAgICAgICAgeyBzdGF0dXM6ICdGQUlMRUQnIH1cbiAgICAgICAgXVxuICAgICAgfVxuICAgIH0pXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgY2xlYW5pbmcgdXAgb2xkIGFuYWx5c2lzIHJlcXVlc3RzOicsIGVycm9yPy50b1N0cmluZygpIHx8ICdVbmtub3duIGVycm9yJylcbiAgICB0aHJvdyBlcnJvclxuICB9XG59XG5cbi8vIE5vdGU6IFRoZSBmb2xsb3dpbmcgZnVuY3Rpb25zIHdpbGwgYmUgaW1wbGVtZW50ZWQgYWZ0ZXIgcnVubmluZyBwcmlzbWEgZ2VuZXJhdGVcbi8vIHRvIHVwZGF0ZSB0aGUgY2xpZW50IHdpdGggdGhlIG5ldyBzY2hlbWEuIEZvciBub3csIHdlJ2xsIGNvbW1lbnQgdGhlbSBvdXQgdG8gYXZvaWQgVHlwZVNjcmlwdCBlcnJvcnMuXG5cbi8qXG4gKiBDcmVhdGUgYSB3ZWJzaXRlIHBhZ2UgcmVjb3JkXG4gKiBAcGFyYW0gYW5hbHlzaXNJZCAtIFRoZSBwYXJlbnQgYW5hbHlzaXMgSURcbiAqIEBwYXJhbSBwYWdlRGF0YSAtIFRoZSBwYWdlIGRhdGFcbiAqIEByZXR1cm5zIFRoZSBjcmVhdGVkIHBhZ2UgcmVjb3JkXG4gKi9cbi8qXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY3JlYXRlV2Vic2l0ZVBhZ2UoYW5hbHlzaXNJZDogc3RyaW5nLCBwYWdlRGF0YToge1xuICB1cmw6IHN0cmluZztcbiAgdGl0bGU/OiBzdHJpbmc7XG4gIGh0bWxDb250ZW50Pzogc3RyaW5nO1xuICBtYXJrZG93bkNvbnRlbnQ/OiBzdHJpbmc7XG4gIHNjcmVlbnNob3RQYXRoPzogc3RyaW5nO1xuICBtZXRhZGF0YT86IGFueTtcbn0pIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gYXdhaXQgcHJpc21hLndlYnNpdGVQYWdlLmNyZWF0ZSh7XG4gICAgICBkYXRhOiB7XG4gICAgICAgIC4uLnBhZ2VEYXRhLFxuICAgICAgICBtZXRhZGF0YTogcGFnZURhdGEubWV0YWRhdGEgPyBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHBhZ2VEYXRhLm1ldGFkYXRhKSkgOiB1bmRlZmluZWQsXG4gICAgICAgIGFuYWx5c2lzOiB7XG4gICAgICAgICAgY29ubmVjdDogeyBpZDogYW5hbHlzaXNJZCB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNyZWF0aW5nIHdlYnNpdGUgcGFnZTonLCBlcnJvcilcbiAgICB0aHJvdyBlcnJvclxuICB9XG59XG4qL1xuXG4vKlxuICogQ3JlYXRlIGEgd2Vic2l0ZSBhc3NldCByZWNvcmRcbiAqIEBwYXJhbSBhbmFseXNpc0lkIC0gVGhlIHBhcmVudCBhbmFseXNpcyBJRFxuICogQHBhcmFtIGFzc2V0RGF0YSAtIFRoZSBhc3NldCBkYXRhXG4gKiBAcGFyYW0gcGFnZUlkcyAtIE9wdGlvbmFsIElEcyBvZiBwYWdlcyB0byBjb25uZWN0IHRoaXMgYXNzZXQgdG9cbiAqIEByZXR1cm5zIFRoZSBjcmVhdGVkIGFzc2V0IHJlY29yZFxuICovXG4vKlxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZVdlYnNpdGVBc3NldChcbiAgYW5hbHlzaXNJZDogc3RyaW5nLFxuICBhc3NldERhdGE6IHtcbiAgICB1cmw6IHN0cmluZztcbiAgICB0eXBlOiBBc3NldFR5cGU7XG4gICAgY29udGVudD86IHN0cmluZztcbiAgICBtZXRhZGF0YT86IGFueTtcbiAgfSxcbiAgcGFnZUlkcz86IHN0cmluZ1tdXG4pIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gYXdhaXQgcHJpc21hLndlYnNpdGVBc3NldC5jcmVhdGUoe1xuICAgICAgZGF0YToge1xuICAgICAgICAuLi5hc3NldERhdGEsXG4gICAgICAgIG1ldGFkYXRhOiBhc3NldERhdGEubWV0YWRhdGEgPyBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGFzc2V0RGF0YS5tZXRhZGF0YSkpIDogdW5kZWZpbmVkLFxuICAgICAgICBhbmFseXNpczoge1xuICAgICAgICAgIGNvbm5lY3Q6IHsgaWQ6IGFuYWx5c2lzSWQgfVxuICAgICAgICB9LFxuICAgICAgICBwYWdlczogcGFnZUlkcz8ubGVuZ3RoID8ge1xuICAgICAgICAgIGNvbm5lY3Q6IHBhZ2VJZHMubWFwKGlkID0+ICh7IGlkIH0pKVxuICAgICAgICB9IDogdW5kZWZpbmVkXG4gICAgICB9XG4gICAgfSlcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjcmVhdGluZyB3ZWJzaXRlIGFzc2V0OicsIGVycm9yKVxuICAgIHRocm93IGVycm9yXG4gIH1cbn1cbiovXG5cbi8qXG4gKiBDcmVhdGUgb3IgdXBkYXRlIHBlcmZvcm1hbmNlIGRhdGEgZm9yIGFuIGFuYWx5c2lzXG4gKiBAcGFyYW0gYW5hbHlzaXNJZCAtIFRoZSBwYXJlbnQgYW5hbHlzaXMgSURcbiAqIEBwYXJhbSBwZXJmb3JtYW5jZURhdGEgLSBUaGUgcGVyZm9ybWFuY2UgZGF0YVxuICogQHJldHVybnMgVGhlIGNyZWF0ZWQgb3IgdXBkYXRlZCBwZXJmb3JtYW5jZSByZWNvcmRcbiAqL1xuLypcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB1cHNlcnRQZXJmb3JtYW5jZURhdGEoXG4gIGFuYWx5c2lzSWQ6IHN0cmluZyxcbiAgcGVyZm9ybWFuY2VEYXRhOiB7XG4gICAgcGVyZm9ybWFuY2VTY29yZT86IG51bWJlcjtcbiAgICBhY2Nlc3NpYmlsaXR5U2NvcmU/OiBudW1iZXI7XG4gICAgc2VvU2NvcmU/OiBudW1iZXI7XG4gICAgYmVzdFByYWN0aWNlc1Njb3JlPzogbnVtYmVyO1xuICAgIGxpZ2h0aG91c2VEYXRhPzogYW55O1xuICB9XG4pIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gYXdhaXQgcHJpc21hLnBlcmZvcm1hbmNlRGF0YS51cHNlcnQoe1xuICAgICAgd2hlcmU6IHsgYW5hbHlzaXNJZCB9LFxuICAgICAgdXBkYXRlOiB7XG4gICAgICAgIC4uLnBlcmZvcm1hbmNlRGF0YSxcbiAgICAgICAgbGlnaHRob3VzZURhdGE6IHBlcmZvcm1hbmNlRGF0YS5saWdodGhvdXNlRGF0YVxuICAgICAgICAgID8gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShwZXJmb3JtYW5jZURhdGEubGlnaHRob3VzZURhdGEpKVxuICAgICAgICAgIDogdW5kZWZpbmVkXG4gICAgICB9LFxuICAgICAgY3JlYXRlOiB7XG4gICAgICAgIC4uLnBlcmZvcm1hbmNlRGF0YSxcbiAgICAgICAgbGlnaHRob3VzZURhdGE6IHBlcmZvcm1hbmNlRGF0YS5saWdodGhvdXNlRGF0YVxuICAgICAgICAgID8gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShwZXJmb3JtYW5jZURhdGEubGlnaHRob3VzZURhdGEpKVxuICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICBhbmFseXNpczoge1xuICAgICAgICAgIGNvbm5lY3Q6IHsgaWQ6IGFuYWx5c2lzSWQgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSlcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciB1cHNlcnRpbmcgcGVyZm9ybWFuY2UgZGF0YTonLCBlcnJvcilcbiAgICB0aHJvdyBlcnJvclxuICB9XG59XG4qLyJdLCJuYW1lcyI6WyJQcmlzbWFDbGllbnQiLCJwcmlzbWEiLCJjcmVhdGVXZWJzaXRlQW5hbHlzaXNSZXF1ZXN0IiwidXJsIiwib3B0aW9ucyIsImFuYWx5c2lzIiwid2Vic2l0ZUFuYWx5c2lzIiwiY3JlYXRlIiwiZGF0YSIsInN0YXR1cyIsInJlc3VsdCIsIkpTT04iLCJwYXJzZSIsInN0cmluZ2lmeSIsInVuZGVmaW5lZCIsImVycm9yIiwiY29uc29sZSIsInRvU3RyaW5nIiwiZ2V0V2Vic2l0ZUFuYWx5c2lzQnlJZCIsImlkIiwiZmluZFVuaXF1ZSIsIndoZXJlIiwidXBkYXRlV2Vic2l0ZUFuYWx5c2lzU3RhdHVzIiwicHJvY2Vzc2luZ1RpbWUiLCJ1cGRhdGUiLCJkYkVycm9yIiwibGlzdFdlYnNpdGVBbmFseXNpc1JlcXVlc3RzIiwibGltaXQiLCJza2lwIiwiZmluZE1hbnkiLCJ0YWtlIiwib3JkZXJCeSIsImNyZWF0ZWRBdCIsImRlbGV0ZVdlYnNpdGVBbmFseXNpc1JlcXVlc3QiLCJkZWxldGUiLCJnZXRGYWlsZWRBbmFseXNpc1JlcXVlc3RzIiwiZ2V0UmVzdW1hYmxlQW5hbHlzaXNSZXF1ZXN0cyIsImluIiwibWFya0FuYWx5c2lzQXNGYWlsZWQiLCJjbGVhbnVwT2xkQW5hbHlzaXNSZXF1ZXN0cyIsImRheXNPbGQiLCJjdXRvZmZEYXRlIiwiRGF0ZSIsIm5vdyIsImRlbGV0ZU1hbnkiLCJsdCIsIk9SIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./lib/prisma-utils.ts\n");

/***/ })

};
;

// load runtime
var __webpack_require__ = require("../../../webpack-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = __webpack_require__.X(0, ["vendor-chunks/next","vendor-chunks/pako","vendor-chunks/form-data","vendor-chunks/zod","vendor-chunks/jszip","vendor-chunks/axios","vendor-chunks/ws","vendor-chunks/readable-stream","vendor-chunks/zod-to-json-schema","vendor-chunks/@mendable","vendor-chunks/follow-redirects","vendor-chunks/debug","vendor-chunks/get-intrinsic","vendor-chunks/string_decoder","vendor-chunks/asynckit","vendor-chunks/lie","vendor-chunks/combined-stream","vendor-chunks/proxy-from-env","vendor-chunks/core-util-is","vendor-chunks/ms","vendor-chunks/supports-color","vendor-chunks/has-symbols","vendor-chunks/delayed-stream","vendor-chunks/function-bind","vendor-chunks/immediate","vendor-chunks/es-set-tostringtag","vendor-chunks/get-proto","vendor-chunks/call-bind-apply-helpers","vendor-chunks/process-nextick-args","vendor-chunks/inherits","vendor-chunks/dunder-proto","vendor-chunks/isows","vendor-chunks/math-intrinsics","vendor-chunks/es-errors","vendor-chunks/has-flag","vendor-chunks/gopd","vendor-chunks/es-define-property","vendor-chunks/hasown","vendor-chunks/has-tostringtag","vendor-chunks/isarray","vendor-chunks/util-deprecate","vendor-chunks/typescript-event-target","vendor-chunks/es-object-atoms"], () => (__webpack_exec__("(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader/index.js?name=app%2Fapi%2Fresume-analysis%2Froute&page=%2Fapi%2Fresume-analysis%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fresume-analysis%2Froute.ts&appDir=%2FUsers%2Fdeannewton%2FDocuments%2Fxray%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2FUsers%2Fdeannewton%2FDocuments%2Fxray&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D!")));
module.exports = __webpack_exports__;

})();