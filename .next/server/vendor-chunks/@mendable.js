"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@mendable";
exports.ids = ["vendor-chunks/@mendable"];
exports.modules = {

/***/ "(rsc)/./node_modules/@mendable/firecrawl-js/dist/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@mendable/firecrawl-js/dist/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CrawlWatcher: () => (/* binding */ CrawlWatcher),\n/* harmony export */   FirecrawlError: () => (/* binding */ FirecrawlError),\n/* harmony export */   \"default\": () => (/* binding */ FirecrawlApp)\n/* harmony export */ });\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! axios */ \"(rsc)/./node_modules/axios/lib/axios.js\");\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! axios */ \"(rsc)/./node_modules/axios/index.js\");\n/* harmony import */ var zod__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zod */ \"(rsc)/./node_modules/zod/dist/esm/index.js\");\n/* harmony import */ var zod_to_json_schema__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zod-to-json-schema */ \"(rsc)/./node_modules/zod-to-json-schema/dist/esm/index.js\");\n/* harmony import */ var isows__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! isows */ \"(rsc)/./node_modules/isows/_esm/index.js\");\n/* harmony import */ var typescript_event_target__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! typescript-event-target */ \"(rsc)/./node_modules/typescript-event-target/dist/index.mjs\");\n// src/index.ts\n\n\n\n\n\nvar FirecrawlError = class extends Error {\n  statusCode;\n  details;\n  constructor(message, statusCode, details) {\n    super(message);\n    this.statusCode = statusCode;\n    this.details = details;\n  }\n};\nvar FirecrawlApp = class {\n  apiKey;\n  apiUrl;\n  isCloudService(url) {\n    return url.includes(\"api.firecrawl.dev\");\n  }\n  /**\n   * Initializes a new instance of the FirecrawlApp class.\n   * @param config - Configuration options for the FirecrawlApp instance.\n   */\n  constructor({ apiKey = null, apiUrl = null }) {\n    const baseUrl = apiUrl || \"https://api.firecrawl.dev\";\n    if (this.isCloudService(baseUrl) && typeof apiKey !== \"string\") {\n      throw new FirecrawlError(\"No API key provided\", 401);\n    }\n    this.apiKey = apiKey || \"\";\n    this.apiUrl = baseUrl;\n  }\n  /**\n   * Scrapes a URL using the Firecrawl API.\n   * @param url - The URL to scrape.\n   * @param params - Additional parameters for the scrape request.\n   * @returns The response from the scrape operation.\n   */\n  async scrapeUrl(url, params) {\n    const headers = {\n      \"Content-Type\": \"application/json\",\n      Authorization: `Bearer ${this.apiKey}`\n    };\n    let jsonData = { url, ...params };\n    if (jsonData?.extract?.schema) {\n      let schema = jsonData.extract.schema;\n      try {\n        schema = (0,zod_to_json_schema__WEBPACK_IMPORTED_MODULE_1__.zodToJsonSchema)(schema);\n      } catch (error) {\n      }\n      jsonData = {\n        ...jsonData,\n        extract: {\n          ...jsonData.extract,\n          schema\n        }\n      };\n    }\n    if (jsonData?.jsonOptions?.schema) {\n      let schema = jsonData.jsonOptions.schema;\n      try {\n        schema = (0,zod_to_json_schema__WEBPACK_IMPORTED_MODULE_1__.zodToJsonSchema)(schema);\n      } catch (error) {\n      }\n      jsonData = {\n        ...jsonData,\n        jsonOptions: {\n          ...jsonData.jsonOptions,\n          schema\n        }\n      };\n    }\n    try {\n      const response = await axios__WEBPACK_IMPORTED_MODULE_3__[\"default\"].post(\n        this.apiUrl + `/v1/scrape`,\n        jsonData,\n        { headers, timeout: params?.timeout !== void 0 ? params.timeout + 5e3 : void 0 }\n      );\n      if (response.status === 200) {\n        const responseData = response.data;\n        if (responseData.success) {\n          return {\n            success: true,\n            warning: responseData.warning,\n            error: responseData.error,\n            ...responseData.data\n          };\n        } else {\n          throw new FirecrawlError(`Failed to scrape URL. Error: ${responseData.error}`, response.status);\n        }\n      } else {\n        this.handleError(response, \"scrape URL\");\n      }\n    } catch (error) {\n      this.handleError(error.response, \"scrape URL\");\n    }\n    return { success: false, error: \"Internal server error.\" };\n  }\n  /**\n   * Searches using the Firecrawl API and optionally scrapes the results.\n   * @param query - The search query string.\n   * @param params - Optional parameters for the search request.\n   * @returns The response from the search operation.\n   */\n  async search(query, params) {\n    const headers = {\n      \"Content-Type\": \"application/json\",\n      Authorization: `Bearer ${this.apiKey}`\n    };\n    let jsonData = {\n      query,\n      limit: params?.limit ?? 5,\n      tbs: params?.tbs,\n      filter: params?.filter,\n      lang: params?.lang ?? \"en\",\n      country: params?.country ?? \"us\",\n      location: params?.location,\n      origin: params?.origin ?? \"api\",\n      timeout: params?.timeout ?? 6e4,\n      scrapeOptions: params?.scrapeOptions ?? { formats: [] }\n    };\n    if (jsonData?.scrapeOptions?.extract?.schema) {\n      let schema = jsonData.scrapeOptions.extract.schema;\n      try {\n        schema = (0,zod_to_json_schema__WEBPACK_IMPORTED_MODULE_1__.zodToJsonSchema)(schema);\n      } catch (error) {\n      }\n      jsonData = {\n        ...jsonData,\n        scrapeOptions: {\n          ...jsonData.scrapeOptions,\n          extract: {\n            ...jsonData.scrapeOptions.extract,\n            schema\n          }\n        }\n      };\n    }\n    try {\n      const response = await this.postRequest(\n        this.apiUrl + `/v1/search`,\n        jsonData,\n        headers\n      );\n      if (response.status === 200) {\n        const responseData = response.data;\n        if (responseData.success) {\n          return {\n            success: true,\n            data: responseData.data,\n            warning: responseData.warning\n          };\n        } else {\n          throw new FirecrawlError(`Failed to search. Error: ${responseData.error}`, response.status);\n        }\n      } else {\n        this.handleError(response, \"search\");\n      }\n    } catch (error) {\n      if (error.response?.data?.error) {\n        throw new FirecrawlError(`Request failed with status code ${error.response.status}. Error: ${error.response.data.error} ${error.response.data.details ? ` - ${JSON.stringify(error.response.data.details)}` : \"\"}`, error.response.status);\n      } else {\n        throw new FirecrawlError(error.message, 500);\n      }\n    }\n    return { success: false, error: \"Internal server error.\", data: [] };\n  }\n  /**\n   * Initiates a crawl job for a URL using the Firecrawl API.\n   * @param url - The URL to crawl.\n   * @param params - Additional parameters for the crawl request.\n   * @param pollInterval - Time in seconds for job status checks.\n   * @param idempotencyKey - Optional idempotency key for the request.\n   * @returns The response from the crawl operation.\n   */\n  async crawlUrl(url, params, pollInterval = 2, idempotencyKey) {\n    const headers = this.prepareHeaders(idempotencyKey);\n    let jsonData = { url, ...params };\n    try {\n      const response = await this.postRequest(\n        this.apiUrl + `/v1/crawl`,\n        jsonData,\n        headers\n      );\n      if (response.status === 200) {\n        const id = response.data.id;\n        return this.monitorJobStatus(id, headers, pollInterval);\n      } else {\n        this.handleError(response, \"start crawl job\");\n      }\n    } catch (error) {\n      if (error.response?.data?.error) {\n        throw new FirecrawlError(`Request failed with status code ${error.response.status}. Error: ${error.response.data.error} ${error.response.data.details ? ` - ${JSON.stringify(error.response.data.details)}` : \"\"}`, error.response.status);\n      } else {\n        throw new FirecrawlError(error.message, 500);\n      }\n    }\n    return { success: false, error: \"Internal server error.\" };\n  }\n  async asyncCrawlUrl(url, params, idempotencyKey) {\n    const headers = this.prepareHeaders(idempotencyKey);\n    let jsonData = { url, ...params };\n    try {\n      const response = await this.postRequest(\n        this.apiUrl + `/v1/crawl`,\n        jsonData,\n        headers\n      );\n      if (response.status === 200) {\n        return response.data;\n      } else {\n        this.handleError(response, \"start crawl job\");\n      }\n    } catch (error) {\n      if (error.response?.data?.error) {\n        throw new FirecrawlError(`Request failed with status code ${error.response.status}. Error: ${error.response.data.error} ${error.response.data.details ? ` - ${JSON.stringify(error.response.data.details)}` : \"\"}`, error.response.status);\n      } else {\n        throw new FirecrawlError(error.message, 500);\n      }\n    }\n    return { success: false, error: \"Internal server error.\" };\n  }\n  /**\n   * Checks the status of a crawl job using the Firecrawl API.\n   * @param id - The ID of the crawl operation.\n   * @param getAllData - Paginate through all the pages of documents, returning the full list of all documents. (default: `false`)\n   * @param nextURL - The `next` URL from the previous crawl status. Only required if you're not manually increasing `skip`. Only used when `getAllData = false`.\n   * @param skip - How many entries to skip to paginate. Only required if you're not providing `nextURL`. Only used when `getAllData = false`.\n   * @param limit - How many entries to return. Only used when `getAllData = false`.\n   * @returns The response containing the job status.\n   */\n  async checkCrawlStatus(id, getAllData = false, nextURL, skip, limit) {\n    if (!id) {\n      throw new FirecrawlError(\"No crawl ID provided\", 400);\n    }\n    const headers = this.prepareHeaders();\n    const targetURL = new URL(nextURL ?? `${this.apiUrl}/v1/crawl/${id}`);\n    if (skip !== void 0) {\n      targetURL.searchParams.set(\"skip\", skip.toString());\n    }\n    if (limit !== void 0) {\n      targetURL.searchParams.set(\"limit\", limit.toString());\n    }\n    try {\n      const response = await this.getRequest(\n        targetURL.href,\n        headers\n      );\n      if (response.status === 200) {\n        let allData = response.data.data;\n        if (getAllData && response.data.status === \"completed\") {\n          let statusData = response.data;\n          if (\"data\" in statusData) {\n            let data = statusData.data;\n            while (typeof statusData === \"object\" && \"next\" in statusData) {\n              if (data.length === 0) {\n                break;\n              }\n              statusData = (await this.getRequest(statusData.next, headers)).data;\n              data = data.concat(statusData.data);\n            }\n            allData = data;\n          }\n        }\n        let resp = {\n          success: response.data.success,\n          status: response.data.status,\n          total: response.data.total,\n          completed: response.data.completed,\n          creditsUsed: response.data.creditsUsed,\n          next: getAllData ? void 0 : response.data.next,\n          expiresAt: new Date(response.data.expiresAt),\n          data: allData\n        };\n        if (!response.data.success && response.data.error) {\n          resp = {\n            ...resp,\n            success: false,\n            error: response.data.error\n          };\n        }\n        if (response.data.next) {\n          resp.next = response.data.next;\n        }\n        return resp;\n      } else {\n        this.handleError(response, \"check crawl status\");\n      }\n    } catch (error) {\n      throw new FirecrawlError(error.message, 500);\n    }\n    return { success: false, error: \"Internal server error.\" };\n  }\n  /**\n   * Returns information about crawl errors.\n   * @param id - The ID of the crawl operation.\n   * @returns Information about crawl errors.\n   */\n  async checkCrawlErrors(id) {\n    const headers = this.prepareHeaders();\n    try {\n      const response = await this.deleteRequest(\n        `${this.apiUrl}/v1/crawl/${id}/errors`,\n        headers\n      );\n      if (response.status === 200) {\n        return response.data;\n      } else {\n        this.handleError(response, \"check crawl errors\");\n      }\n    } catch (error) {\n      throw new FirecrawlError(error.message, 500);\n    }\n    return { success: false, error: \"Internal server error.\" };\n  }\n  /**\n   * Cancels a crawl job using the Firecrawl API.\n   * @param id - The ID of the crawl operation.\n   * @returns The response from the cancel crawl operation.\n   */\n  async cancelCrawl(id) {\n    const headers = this.prepareHeaders();\n    try {\n      const response = await this.deleteRequest(\n        `${this.apiUrl}/v1/crawl/${id}`,\n        headers\n      );\n      if (response.status === 200) {\n        return response.data;\n      } else {\n        this.handleError(response, \"cancel crawl job\");\n      }\n    } catch (error) {\n      throw new FirecrawlError(error.message, 500);\n    }\n    return { success: false, error: \"Internal server error.\" };\n  }\n  /**\n   * Initiates a crawl job and returns a CrawlWatcher to monitor the job via WebSocket.\n   * @param url - The URL to crawl.\n   * @param params - Additional parameters for the crawl request.\n   * @param idempotencyKey - Optional idempotency key for the request.\n   * @returns A CrawlWatcher instance to monitor the crawl job.\n   */\n  async crawlUrlAndWatch(url, params, idempotencyKey) {\n    const crawl = await this.asyncCrawlUrl(url, params, idempotencyKey);\n    if (crawl.success && crawl.id) {\n      const id = crawl.id;\n      return new CrawlWatcher(id, this);\n    }\n    throw new FirecrawlError(\"Crawl job failed to start\", 400);\n  }\n  /**\n   * Maps a URL using the Firecrawl API.\n   * @param url - The URL to map.\n   * @param params - Additional parameters for the map request.\n   * @returns The response from the map operation.\n   */\n  async mapUrl(url, params) {\n    const headers = this.prepareHeaders();\n    let jsonData = { url, ...params };\n    try {\n      const response = await this.postRequest(\n        this.apiUrl + `/v1/map`,\n        jsonData,\n        headers\n      );\n      if (response.status === 200) {\n        return response.data;\n      } else {\n        this.handleError(response, \"map\");\n      }\n    } catch (error) {\n      throw new FirecrawlError(error.message, 500);\n    }\n    return { success: false, error: \"Internal server error.\" };\n  }\n  /**\n   * Initiates a batch scrape job for multiple URLs using the Firecrawl API.\n   * @param url - The URLs to scrape.\n   * @param params - Additional parameters for the scrape request.\n   * @param pollInterval - Time in seconds for job status checks.\n   * @param idempotencyKey - Optional idempotency key for the request.\n   * @param webhook - Optional webhook for the batch scrape.\n   * @param ignoreInvalidURLs - Optional flag to ignore invalid URLs.\n   * @returns The response from the crawl operation.\n   */\n  async batchScrapeUrls(urls, params, pollInterval = 2, idempotencyKey, webhook, ignoreInvalidURLs) {\n    const headers = this.prepareHeaders(idempotencyKey);\n    let jsonData = { urls, webhook, ignoreInvalidURLs, ...params };\n    if (jsonData?.extract?.schema) {\n      let schema = jsonData.extract.schema;\n      try {\n        schema = (0,zod_to_json_schema__WEBPACK_IMPORTED_MODULE_1__.zodToJsonSchema)(schema);\n      } catch (error) {\n      }\n      jsonData = {\n        ...jsonData,\n        extract: {\n          ...jsonData.extract,\n          schema\n        }\n      };\n    }\n    if (jsonData?.jsonOptions?.schema) {\n      let schema = jsonData.jsonOptions.schema;\n      try {\n        schema = (0,zod_to_json_schema__WEBPACK_IMPORTED_MODULE_1__.zodToJsonSchema)(schema);\n      } catch (error) {\n      }\n      jsonData = {\n        ...jsonData,\n        jsonOptions: {\n          ...jsonData.jsonOptions,\n          schema\n        }\n      };\n    }\n    try {\n      const response = await this.postRequest(\n        this.apiUrl + `/v1/batch/scrape`,\n        jsonData,\n        headers\n      );\n      if (response.status === 200) {\n        const id = response.data.id;\n        return this.monitorJobStatus(id, headers, pollInterval);\n      } else {\n        this.handleError(response, \"start batch scrape job\");\n      }\n    } catch (error) {\n      if (error.response?.data?.error) {\n        throw new FirecrawlError(`Request failed with status code ${error.response.status}. Error: ${error.response.data.error} ${error.response.data.details ? ` - ${JSON.stringify(error.response.data.details)}` : \"\"}`, error.response.status);\n      } else {\n        throw new FirecrawlError(error.message, 500);\n      }\n    }\n    return { success: false, error: \"Internal server error.\" };\n  }\n  async asyncBatchScrapeUrls(urls, params, idempotencyKey, webhook, ignoreInvalidURLs) {\n    const headers = this.prepareHeaders(idempotencyKey);\n    let jsonData = { urls, webhook, ignoreInvalidURLs, ...params ?? {} };\n    try {\n      const response = await this.postRequest(\n        this.apiUrl + `/v1/batch/scrape`,\n        jsonData,\n        headers\n      );\n      if (response.status === 200) {\n        return response.data;\n      } else {\n        this.handleError(response, \"start batch scrape job\");\n      }\n    } catch (error) {\n      if (error.response?.data?.error) {\n        throw new FirecrawlError(`Request failed with status code ${error.response.status}. Error: ${error.response.data.error} ${error.response.data.details ? ` - ${JSON.stringify(error.response.data.details)}` : \"\"}`, error.response.status);\n      } else {\n        throw new FirecrawlError(error.message, 500);\n      }\n    }\n    return { success: false, error: \"Internal server error.\" };\n  }\n  /**\n   * Initiates a batch scrape job and returns a CrawlWatcher to monitor the job via WebSocket.\n   * @param urls - The URL to scrape.\n   * @param params - Additional parameters for the scrape request.\n   * @param idempotencyKey - Optional idempotency key for the request.\n   * @returns A CrawlWatcher instance to monitor the crawl job.\n   */\n  async batchScrapeUrlsAndWatch(urls, params, idempotencyKey, webhook, ignoreInvalidURLs) {\n    const crawl = await this.asyncBatchScrapeUrls(urls, params, idempotencyKey, webhook, ignoreInvalidURLs);\n    if (crawl.success && crawl.id) {\n      const id = crawl.id;\n      return new CrawlWatcher(id, this);\n    }\n    throw new FirecrawlError(\"Batch scrape job failed to start\", 400);\n  }\n  /**\n   * Checks the status of a batch scrape job using the Firecrawl API.\n   * @param id - The ID of the batch scrape operation.\n   * @param getAllData - Paginate through all the pages of documents, returning the full list of all documents. (default: `false`)\n   * @param nextURL - The `next` URL from the previous batch scrape status. Only required if you're not manually increasing `skip`. Only used when `getAllData = false`.\n   * @param skip - How many entries to skip to paginate. Only used when `getAllData = false`.\n   * @param limit - How many entries to return. Only used when `getAllData = false`.\n   * @returns The response containing the job status.\n   */\n  async checkBatchScrapeStatus(id, getAllData = false, nextURL, skip, limit) {\n    if (!id) {\n      throw new FirecrawlError(\"No batch scrape ID provided\", 400);\n    }\n    const headers = this.prepareHeaders();\n    const targetURL = new URL(nextURL ?? `${this.apiUrl}/v1/batch/scrape/${id}`);\n    if (skip !== void 0) {\n      targetURL.searchParams.set(\"skip\", skip.toString());\n    }\n    if (limit !== void 0) {\n      targetURL.searchParams.set(\"limit\", limit.toString());\n    }\n    try {\n      const response = await this.getRequest(\n        targetURL.href,\n        headers\n      );\n      if (response.status === 200) {\n        let allData = response.data.data;\n        if (getAllData && response.data.status === \"completed\") {\n          let statusData = response.data;\n          if (\"data\" in statusData) {\n            let data = statusData.data;\n            while (typeof statusData === \"object\" && \"next\" in statusData) {\n              if (data.length === 0) {\n                break;\n              }\n              statusData = (await this.getRequest(statusData.next, headers)).data;\n              data = data.concat(statusData.data);\n            }\n            allData = data;\n          }\n        }\n        let resp = {\n          success: response.data.success,\n          status: response.data.status,\n          total: response.data.total,\n          completed: response.data.completed,\n          creditsUsed: response.data.creditsUsed,\n          next: getAllData ? void 0 : response.data.next,\n          expiresAt: new Date(response.data.expiresAt),\n          data: allData\n        };\n        if (!response.data.success && response.data.error) {\n          resp = {\n            ...resp,\n            success: false,\n            error: response.data.error\n          };\n        }\n        if (response.data.next) {\n          resp.next = response.data.next;\n        }\n        return resp;\n      } else {\n        this.handleError(response, \"check batch scrape status\");\n      }\n    } catch (error) {\n      throw new FirecrawlError(error.message, 500);\n    }\n    return { success: false, error: \"Internal server error.\" };\n  }\n  /**\n   * Returns information about batch scrape errors.\n   * @param id - The ID of the batch scrape operation.\n   * @returns Information about batch scrape errors.\n   */\n  async checkBatchScrapeErrors(id) {\n    const headers = this.prepareHeaders();\n    try {\n      const response = await this.deleteRequest(\n        `${this.apiUrl}/v1/batch/scrape/${id}/errors`,\n        headers\n      );\n      if (response.status === 200) {\n        return response.data;\n      } else {\n        this.handleError(response, \"check batch scrape errors\");\n      }\n    } catch (error) {\n      throw new FirecrawlError(error.message, 500);\n    }\n    return { success: false, error: \"Internal server error.\" };\n  }\n  /**\n   * Extracts information from URLs using the Firecrawl API.\n   * Currently in Beta. Expect breaking changes on future minor versions.\n   * @param urls - The URLs to extract information from. Optional if using other methods for data extraction.\n   * @param params - Additional parameters for the extract request.\n   * @returns The response from the extract operation.\n   */\n  async extract(urls, params) {\n    const headers = this.prepareHeaders();\n    let jsonData = { urls, ...params };\n    let jsonSchema;\n    try {\n      if (!params?.schema) {\n        jsonSchema = void 0;\n      } else if (typeof params.schema === \"object\" && params.schema !== null && Object.getPrototypeOf(params.schema)?.constructor?.name?.startsWith(\"Zod\")) {\n        jsonSchema = (0,zod_to_json_schema__WEBPACK_IMPORTED_MODULE_1__.zodToJsonSchema)(params.schema);\n      } else {\n        jsonSchema = params.schema;\n      }\n    } catch (error) {\n      throw new FirecrawlError(\"Invalid schema. Schema must be either a valid Zod schema or JSON schema object.\", 400);\n    }\n    try {\n      const response = await this.postRequest(\n        this.apiUrl + `/v1/extract`,\n        { ...jsonData, schema: jsonSchema, origin: params?.origin || \"api-sdk\" },\n        headers\n      );\n      if (response.status === 200) {\n        const jobId = response.data.id;\n        let extractStatus;\n        do {\n          const statusResponse = await this.getRequest(\n            `${this.apiUrl}/v1/extract/${jobId}`,\n            headers\n          );\n          extractStatus = statusResponse.data;\n          if (extractStatus.status === \"completed\") {\n            if (extractStatus.success) {\n              return {\n                success: true,\n                data: extractStatus.data,\n                warning: extractStatus.warning,\n                error: extractStatus.error,\n                sources: extractStatus?.sources || void 0\n              };\n            } else {\n              throw new FirecrawlError(`Failed to extract data. Error: ${extractStatus.error}`, statusResponse.status);\n            }\n          } else if (extractStatus.status === \"failed\" || extractStatus.status === \"cancelled\") {\n            throw new FirecrawlError(`Extract job ${extractStatus.status}. Error: ${extractStatus.error}`, statusResponse.status);\n          }\n          await new Promise((resolve) => setTimeout(resolve, 1e3));\n        } while (extractStatus.status !== \"completed\");\n      } else {\n        this.handleError(response, \"extract\");\n      }\n    } catch (error) {\n      throw new FirecrawlError(error.message, 500, error.response?.data?.details);\n    }\n    return { success: false, error: \"Internal server error.\" };\n  }\n  /**\n   * Initiates an asynchronous extract job for a URL using the Firecrawl API.\n   * @param url - The URL to extract data from.\n   * @param params - Additional parameters for the extract request.\n   * @param idempotencyKey - Optional idempotency key for the request.\n   * @returns The response from the extract operation.\n   */\n  async asyncExtract(urls, params, idempotencyKey) {\n    const headers = this.prepareHeaders(idempotencyKey);\n    let jsonData = { urls, ...params };\n    let jsonSchema;\n    try {\n      if (params?.schema instanceof zod__WEBPACK_IMPORTED_MODULE_0__.ZodType) {\n        jsonSchema = (0,zod_to_json_schema__WEBPACK_IMPORTED_MODULE_1__.zodToJsonSchema)(params.schema);\n      } else {\n        jsonSchema = params?.schema;\n      }\n    } catch (error) {\n      throw new FirecrawlError(\"Invalid schema. Schema must be either a valid Zod schema or JSON schema object.\", 400);\n    }\n    try {\n      const response = await this.postRequest(\n        this.apiUrl + `/v1/extract`,\n        { ...jsonData, schema: jsonSchema },\n        headers\n      );\n      if (response.status === 200) {\n        return response.data;\n      } else {\n        this.handleError(response, \"start extract job\");\n      }\n    } catch (error) {\n      throw new FirecrawlError(error.message, 500, error.response?.data?.details);\n    }\n    return { success: false, error: \"Internal server error.\" };\n  }\n  /**\n   * Retrieves the status of an extract job.\n   * @param jobId - The ID of the extract job.\n   * @returns The status of the extract job.\n   */\n  async getExtractStatus(jobId) {\n    try {\n      const response = await this.getRequest(\n        `${this.apiUrl}/v1/extract/${jobId}`,\n        this.prepareHeaders()\n      );\n      if (response.status === 200) {\n        return response.data;\n      } else {\n        this.handleError(response, \"get extract status\");\n      }\n    } catch (error) {\n      throw new FirecrawlError(error.message, 500);\n    }\n  }\n  /**\n   * Prepares the headers for an API request.\n   * @param idempotencyKey - Optional key to ensure idempotency.\n   * @returns The prepared headers.\n   */\n  prepareHeaders(idempotencyKey) {\n    return {\n      \"Content-Type\": \"application/json\",\n      Authorization: `Bearer ${this.apiKey}`,\n      ...idempotencyKey ? { \"x-idempotency-key\": idempotencyKey } : {}\n    };\n  }\n  /**\n   * Sends a POST request to the specified URL.\n   * @param url - The URL to send the request to.\n   * @param data - The data to send in the request.\n   * @param headers - The headers for the request.\n   * @returns The response from the POST request.\n   */\n  postRequest(url, data, headers) {\n    return axios__WEBPACK_IMPORTED_MODULE_3__[\"default\"].post(url, data, { headers, timeout: data?.timeout ? data.timeout + 5e3 : void 0 });\n  }\n  /**\n   * Sends a GET request to the specified URL.\n   * @param url - The URL to send the request to.\n   * @param headers - The headers for the request.\n   * @returns The response from the GET request.\n   */\n  async getRequest(url, headers) {\n    try {\n      return await axios__WEBPACK_IMPORTED_MODULE_3__[\"default\"].get(url, { headers });\n    } catch (error) {\n      if (error instanceof axios__WEBPACK_IMPORTED_MODULE_4__.AxiosError && error.response) {\n        return error.response;\n      } else {\n        throw error;\n      }\n    }\n  }\n  /**\n   * Sends a DELETE request to the specified URL.\n   * @param url - The URL to send the request to.\n   * @param headers - The headers for the request.\n   * @returns The response from the DELETE request.\n   */\n  async deleteRequest(url, headers) {\n    try {\n      return await axios__WEBPACK_IMPORTED_MODULE_3__[\"default\"].delete(url, { headers });\n    } catch (error) {\n      if (error instanceof axios__WEBPACK_IMPORTED_MODULE_4__.AxiosError && error.response) {\n        return error.response;\n      } else {\n        throw error;\n      }\n    }\n  }\n  /**\n   * Monitors the status of a crawl job until completion or failure.\n   * @param id - The ID of the crawl operation.\n   * @param headers - The headers for the request.\n   * @param checkInterval - Interval in seconds for job status checks.\n   * @param checkUrl - Optional URL to check the status (used for v1 API)\n   * @returns The final job status or data.\n   */\n  async monitorJobStatus(id, headers, checkInterval) {\n    try {\n      let failedTries = 0;\n      while (true) {\n        let statusResponse = await this.getRequest(\n          `${this.apiUrl}/v1/crawl/${id}`,\n          headers\n        );\n        if (statusResponse.status === 200) {\n          failedTries = 0;\n          let statusData = statusResponse.data;\n          if (statusData.status === \"completed\") {\n            if (\"data\" in statusData) {\n              let data = statusData.data;\n              while (typeof statusData === \"object\" && \"next\" in statusData) {\n                if (data.length === 0) {\n                  break;\n                }\n                statusResponse = await this.getRequest(statusData.next, headers);\n                statusData = statusResponse.data;\n                data = data.concat(statusData.data);\n              }\n              statusData.data = data;\n              return statusData;\n            } else {\n              throw new FirecrawlError(\"Crawl job completed but no data was returned\", 500);\n            }\n          } else if ([\"active\", \"paused\", \"pending\", \"queued\", \"waiting\", \"scraping\"].includes(statusData.status)) {\n            checkInterval = Math.max(checkInterval, 2);\n            await new Promise(\n              (resolve) => setTimeout(resolve, checkInterval * 1e3)\n            );\n          } else {\n            throw new FirecrawlError(\n              `Crawl job failed or was stopped. Status: ${statusData.status}`,\n              500\n            );\n          }\n        } else {\n          failedTries++;\n          if (failedTries >= 3) {\n            this.handleError(statusResponse, \"check crawl status\");\n          }\n        }\n      }\n    } catch (error) {\n      throw new FirecrawlError(error, 500);\n    }\n  }\n  /**\n   * Handles errors from API responses.\n   * @param {AxiosResponse} response - The response from the API.\n   * @param {string} action - The action being performed when the error occurred.\n   */\n  handleError(response, action) {\n    if ([400, 402, 403, 408, 409, 500].includes(response.status)) {\n      const errorMessage = response.data.error || \"Unknown error occurred\";\n      const details = response.data.details ? ` - ${JSON.stringify(response.data.details)}` : \"\";\n      throw new FirecrawlError(\n        `Failed to ${action}. Status code: ${response.status}. Error: ${errorMessage}${details}`,\n        response.status,\n        response?.data?.details\n      );\n    } else {\n      throw new FirecrawlError(\n        `Unexpected error occurred while trying to ${action}. Status code: ${response.status}`,\n        response.status\n      );\n    }\n  }\n  /**\n   * Initiates a deep research operation on a given query and polls until completion.\n   * @param query - The query to research.\n   * @param params - Parameters for the deep research operation.\n   * @param onActivity - Optional callback to receive activity updates in real-time.\n   * @param onSource - Optional callback to receive source updates in real-time.\n   * @returns The final research results.\n   */\n  async deepResearch(query, params, onActivity, onSource) {\n    try {\n      const response = await this.asyncDeepResearch(query, params);\n      if (!response.success || \"error\" in response) {\n        return { success: false, error: \"error\" in response ? response.error : \"Unknown error\" };\n      }\n      if (!response.id) {\n        throw new FirecrawlError(`Failed to start research. No job ID returned.`, 500);\n      }\n      const jobId = response.id;\n      let researchStatus;\n      let lastActivityCount = 0;\n      let lastSourceCount = 0;\n      while (true) {\n        researchStatus = await this.checkDeepResearchStatus(jobId);\n        if (\"error\" in researchStatus && !researchStatus.success) {\n          return researchStatus;\n        }\n        if (onActivity && researchStatus.activities) {\n          const newActivities = researchStatus.activities.slice(lastActivityCount);\n          for (const activity of newActivities) {\n            onActivity(activity);\n          }\n          lastActivityCount = researchStatus.activities.length;\n        }\n        if (onSource && researchStatus.sources) {\n          const newSources = researchStatus.sources.slice(lastSourceCount);\n          for (const source of newSources) {\n            onSource(source);\n          }\n          lastSourceCount = researchStatus.sources.length;\n        }\n        if (researchStatus.status === \"completed\") {\n          return researchStatus;\n        }\n        if (researchStatus.status === \"failed\") {\n          throw new FirecrawlError(\n            `Research job ${researchStatus.status}. Error: ${researchStatus.error}`,\n            500\n          );\n        }\n        if (researchStatus.status !== \"processing\") {\n          break;\n        }\n        await new Promise((resolve) => setTimeout(resolve, 2e3));\n      }\n      return { success: false, error: \"Research job terminated unexpectedly\" };\n    } catch (error) {\n      throw new FirecrawlError(error.message, 500, error.response?.data?.details);\n    }\n  }\n  /**\n   * Initiates a deep research operation on a given query without polling.\n   * @param params - Parameters for the deep research operation.\n   * @returns The response containing the research job ID.\n   */\n  async asyncDeepResearch(query, params) {\n    const headers = this.prepareHeaders();\n    let jsonData = { query, ...params };\n    if (jsonData?.jsonOptions?.schema) {\n      let schema = jsonData.jsonOptions.schema;\n      try {\n        schema = (0,zod_to_json_schema__WEBPACK_IMPORTED_MODULE_1__.zodToJsonSchema)(schema);\n      } catch (error) {\n      }\n      jsonData = {\n        ...jsonData,\n        jsonOptions: {\n          ...jsonData.jsonOptions,\n          schema\n        }\n      };\n    }\n    try {\n      const response = await this.postRequest(\n        `${this.apiUrl}/v1/deep-research`,\n        jsonData,\n        headers\n      );\n      if (response.status === 200) {\n        return response.data;\n      } else {\n        this.handleError(response, \"start deep research\");\n      }\n    } catch (error) {\n      if (error.response?.data?.error) {\n        throw new FirecrawlError(`Request failed with status code ${error.response.status}. Error: ${error.response.data.error} ${error.response.data.details ? ` - ${JSON.stringify(error.response.data.details)}` : \"\"}`, error.response.status);\n      } else {\n        throw new FirecrawlError(error.message, 500);\n      }\n    }\n    return { success: false, error: \"Internal server error.\" };\n  }\n  /**\n   * Checks the status of a deep research operation.\n   * @param id - The ID of the deep research operation.\n   * @returns The current status and results of the research operation.\n   */\n  async checkDeepResearchStatus(id) {\n    const headers = this.prepareHeaders();\n    try {\n      const response = await this.getRequest(\n        `${this.apiUrl}/v1/deep-research/${id}`,\n        headers\n      );\n      if (response.status === 200) {\n        return response.data;\n      } else if (response.status === 404) {\n        throw new FirecrawlError(\"Deep research job not found\", 404);\n      } else {\n        this.handleError(response, \"check deep research status\");\n      }\n    } catch (error) {\n      if (error.response?.data?.error) {\n        throw new FirecrawlError(`Request failed with status code ${error.response.status}. Error: ${error.response.data.error} ${error.response.data.details ? ` - ${JSON.stringify(error.response.data.details)}` : \"\"}`, error.response.status);\n      } else {\n        throw new FirecrawlError(error.message, 500);\n      }\n    }\n    return { success: false, error: \"Internal server error.\" };\n  }\n  /**\n   * @deprecated Use deepResearch() instead\n   * Initiates a deep research operation on a given topic and polls until completion.\n   * @param topic - The topic to research.\n   * @param params - Parameters for the deep research operation.\n   * @param onActivity - Optional callback to receive activity updates in real-time.\n   * @returns The final research results.\n   */\n  async __deepResearch(topic, params, onActivity) {\n    try {\n      const response = await this.__asyncDeepResearch(topic, params);\n      if (!response.success || \"error\" in response) {\n        return { success: false, error: \"error\" in response ? response.error : \"Unknown error\" };\n      }\n      if (!response.id) {\n        throw new FirecrawlError(`Failed to start research. No job ID returned.`, 500);\n      }\n      const jobId = response.id;\n      let researchStatus;\n      let lastActivityCount = 0;\n      while (true) {\n        researchStatus = await this.__checkDeepResearchStatus(jobId);\n        if (\"error\" in researchStatus && !researchStatus.success) {\n          return researchStatus;\n        }\n        if (onActivity && researchStatus.activities) {\n          const newActivities = researchStatus.activities.slice(lastActivityCount);\n          for (const activity of newActivities) {\n            onActivity(activity);\n          }\n          lastActivityCount = researchStatus.activities.length;\n        }\n        if (researchStatus.status === \"completed\") {\n          return researchStatus;\n        }\n        if (researchStatus.status === \"failed\") {\n          throw new FirecrawlError(\n            `Research job ${researchStatus.status}. Error: ${researchStatus.error}`,\n            500\n          );\n        }\n        if (researchStatus.status !== \"processing\") {\n          break;\n        }\n        await new Promise((resolve) => setTimeout(resolve, 2e3));\n      }\n      return { success: false, error: \"Research job terminated unexpectedly\" };\n    } catch (error) {\n      throw new FirecrawlError(error.message, 500, error.response?.data?.details);\n    }\n  }\n  /**\n   * @deprecated Use asyncDeepResearch() instead\n   * Initiates a deep research operation on a given topic without polling.\n   * @param params - Parameters for the deep research operation.\n   * @returns The response containing the research job ID.\n   */\n  async __asyncDeepResearch(topic, params) {\n    const headers = this.prepareHeaders();\n    try {\n      const response = await this.postRequest(\n        `${this.apiUrl}/v1/deep-research`,\n        { topic, ...params },\n        headers\n      );\n      if (response.status === 200) {\n        return response.data;\n      } else {\n        this.handleError(response, \"start deep research\");\n      }\n    } catch (error) {\n      if (error.response?.data?.error) {\n        throw new FirecrawlError(`Request failed with status code ${error.response.status}. Error: ${error.response.data.error} ${error.response.data.details ? ` - ${JSON.stringify(error.response.data.details)}` : \"\"}`, error.response.status);\n      } else {\n        throw new FirecrawlError(error.message, 500);\n      }\n    }\n    return { success: false, error: \"Internal server error.\" };\n  }\n  /**\n   * @deprecated Use checkDeepResearchStatus() instead\n   * Checks the status of a deep research operation.\n   * @param id - The ID of the deep research operation.\n   * @returns The current status and results of the research operation.\n   */\n  async __checkDeepResearchStatus(id) {\n    const headers = this.prepareHeaders();\n    try {\n      const response = await this.getRequest(\n        `${this.apiUrl}/v1/deep-research/${id}`,\n        headers\n      );\n      if (response.status === 200) {\n        return response.data;\n      } else if (response.status === 404) {\n        throw new FirecrawlError(\"Deep research job not found\", 404);\n      } else {\n        this.handleError(response, \"check deep research status\");\n      }\n    } catch (error) {\n      if (error.response?.data?.error) {\n        throw new FirecrawlError(`Request failed with status code ${error.response.status}. Error: ${error.response.data.error} ${error.response.data.details ? ` - ${JSON.stringify(error.response.data.details)}` : \"\"}`, error.response.status);\n      } else {\n        throw new FirecrawlError(error.message, 500);\n      }\n    }\n    return { success: false, error: \"Internal server error.\" };\n  }\n  /**\n   * Generates LLMs.txt for a given URL and polls until completion.\n   * @param url - The URL to generate LLMs.txt from.\n   * @param params - Parameters for the LLMs.txt generation operation.\n   * @returns The final generation results.\n   */\n  async generateLLMsText(url, params) {\n    try {\n      const response = await this.asyncGenerateLLMsText(url, params);\n      if (!response.success || \"error\" in response) {\n        return { success: false, error: \"error\" in response ? response.error : \"Unknown error\" };\n      }\n      if (!response.id) {\n        throw new FirecrawlError(`Failed to start LLMs.txt generation. No job ID returned.`, 500);\n      }\n      const jobId = response.id;\n      let generationStatus;\n      while (true) {\n        generationStatus = await this.checkGenerateLLMsTextStatus(jobId);\n        if (\"error\" in generationStatus && !generationStatus.success) {\n          return generationStatus;\n        }\n        if (generationStatus.status === \"completed\") {\n          return generationStatus;\n        }\n        if (generationStatus.status === \"failed\") {\n          throw new FirecrawlError(\n            `LLMs.txt generation job ${generationStatus.status}. Error: ${generationStatus.error}`,\n            500\n          );\n        }\n        if (generationStatus.status !== \"processing\") {\n          break;\n        }\n        await new Promise((resolve) => setTimeout(resolve, 2e3));\n      }\n      return { success: false, error: \"LLMs.txt generation job terminated unexpectedly\" };\n    } catch (error) {\n      throw new FirecrawlError(error.message, 500, error.response?.data?.details);\n    }\n  }\n  /**\n   * Initiates a LLMs.txt generation operation without polling.\n   * @param url - The URL to generate LLMs.txt from.\n   * @param params - Parameters for the LLMs.txt generation operation.\n   * @returns The response containing the generation job ID.\n   */\n  async asyncGenerateLLMsText(url, params) {\n    const headers = this.prepareHeaders();\n    try {\n      const response = await this.postRequest(\n        `${this.apiUrl}/v1/llmstxt`,\n        { url, ...params },\n        headers\n      );\n      if (response.status === 200) {\n        return response.data;\n      } else {\n        this.handleError(response, \"start LLMs.txt generation\");\n      }\n    } catch (error) {\n      if (error.response?.data?.error) {\n        throw new FirecrawlError(`Request failed with status code ${error.response.status}. Error: ${error.response.data.error} ${error.response.data.details ? ` - ${JSON.stringify(error.response.data.details)}` : \"\"}`, error.response.status);\n      } else {\n        throw new FirecrawlError(error.message, 500);\n      }\n    }\n    return { success: false, error: \"Internal server error.\" };\n  }\n  /**\n   * Checks the status of a LLMs.txt generation operation.\n   * @param id - The ID of the LLMs.txt generation operation.\n   * @returns The current status and results of the generation operation.\n   */\n  async checkGenerateLLMsTextStatus(id) {\n    const headers = this.prepareHeaders();\n    try {\n      const response = await this.getRequest(\n        `${this.apiUrl}/v1/llmstxt/${id}`,\n        headers\n      );\n      if (response.status === 200) {\n        return response.data;\n      } else if (response.status === 404) {\n        throw new FirecrawlError(\"LLMs.txt generation job not found\", 404);\n      } else {\n        this.handleError(response, \"check LLMs.txt generation status\");\n      }\n    } catch (error) {\n      if (error.response?.data?.error) {\n        throw new FirecrawlError(`Request failed with status code ${error.response.status}. Error: ${error.response.data.error} ${error.response.data.details ? ` - ${JSON.stringify(error.response.data.details)}` : \"\"}`, error.response.status);\n      } else {\n        throw new FirecrawlError(error.message, 500);\n      }\n    }\n    return { success: false, error: \"Internal server error.\" };\n  }\n};\nvar CrawlWatcher = class extends typescript_event_target__WEBPACK_IMPORTED_MODULE_2__.TypedEventTarget {\n  ws;\n  data;\n  status;\n  id;\n  constructor(id, app) {\n    super();\n    this.id = id;\n    const wsUrl = app.apiUrl.replace(/^http/, \"ws\");\n    this.ws = new isows__WEBPACK_IMPORTED_MODULE_5__.WebSocket(`${wsUrl}/v1/crawl/${id}`, app.apiKey);\n    this.status = \"scraping\";\n    this.data = [];\n    const messageHandler = (msg) => {\n      if (msg.type === \"done\") {\n        this.status = \"completed\";\n        this.dispatchTypedEvent(\"done\", new CustomEvent(\"done\", {\n          detail: {\n            status: this.status,\n            data: this.data,\n            id: this.id\n          }\n        }));\n      } else if (msg.type === \"error\") {\n        this.status = \"failed\";\n        this.dispatchTypedEvent(\"error\", new CustomEvent(\"error\", {\n          detail: {\n            status: this.status,\n            data: this.data,\n            error: msg.error,\n            id: this.id\n          }\n        }));\n      } else if (msg.type === \"catchup\") {\n        this.status = msg.data.status;\n        this.data.push(...msg.data.data ?? []);\n        for (const doc of this.data) {\n          this.dispatchTypedEvent(\"document\", new CustomEvent(\"document\", {\n            detail: {\n              ...doc,\n              id: this.id\n            }\n          }));\n        }\n      } else if (msg.type === \"document\") {\n        this.dispatchTypedEvent(\"document\", new CustomEvent(\"document\", {\n          detail: {\n            ...msg.data,\n            id: this.id\n          }\n        }));\n      }\n    };\n    this.ws.onmessage = ((ev) => {\n      if (typeof ev.data !== \"string\") {\n        this.ws.close();\n        return;\n      }\n      try {\n        const msg = JSON.parse(ev.data);\n        messageHandler(msg);\n      } catch (error) {\n        console.error(\"Error on message\", error);\n      }\n    }).bind(this);\n    this.ws.onclose = ((ev) => {\n      try {\n        const msg = JSON.parse(ev.reason);\n        messageHandler(msg);\n      } catch (error) {\n        console.error(\"Error on close\", error);\n      }\n    }).bind(this);\n    this.ws.onerror = ((_) => {\n      this.status = \"failed\";\n      this.dispatchTypedEvent(\"error\", new CustomEvent(\"error\", {\n        detail: {\n          status: this.status,\n          data: this.data,\n          error: \"WebSocket error\",\n          id: this.id\n        }\n      }));\n    }).bind(this);\n  }\n  close() {\n    this.ws.close();\n  }\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQG1lbmRhYmxlL2ZpcmVjcmF3bC1qcy9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFBO0FBQzBDO0FBQ2hCO0FBQzJCO0FBQ25CO0FBQ3lCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDhCQUE4QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixZQUFZO0FBQzNDO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixtRUFBZTtBQUNoQyxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG1FQUFlO0FBQ2hDLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw2Q0FBSztBQUNsQztBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLG1FQUFtRSxtQkFBbUI7QUFDdEY7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLFlBQVk7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixtRUFB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NENBQVMsSUFBSSxNQUFNLFlBQVksR0FBRztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtFIiwic291cmNlcyI6WyIvVXNlcnMvZGVhbm5ld3Rvbi9Eb2N1bWVudHMveHJheS9ub2RlX21vZHVsZXMvQG1lbmRhYmxlL2ZpcmVjcmF3bC1qcy9kaXN0L2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9pbmRleC50c1xuaW1wb3J0IGF4aW9zLCB7IEF4aW9zRXJyb3IgfSBmcm9tIFwiYXhpb3NcIjtcbmltcG9ydCAqIGFzIHp0IGZyb20gXCJ6b2RcIjtcbmltcG9ydCB7IHpvZFRvSnNvblNjaGVtYSB9IGZyb20gXCJ6b2QtdG8tanNvbi1zY2hlbWFcIjtcbmltcG9ydCB7IFdlYlNvY2tldCB9IGZyb20gXCJpc293c1wiO1xuaW1wb3J0IHsgVHlwZWRFdmVudFRhcmdldCB9IGZyb20gXCJ0eXBlc2NyaXB0LWV2ZW50LXRhcmdldFwiO1xudmFyIEZpcmVjcmF3bEVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIHN0YXR1c0NvZGU7XG4gIGRldGFpbHM7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHN0YXR1c0NvZGUsIGRldGFpbHMpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLnN0YXR1c0NvZGUgPSBzdGF0dXNDb2RlO1xuICAgIHRoaXMuZGV0YWlscyA9IGRldGFpbHM7XG4gIH1cbn07XG52YXIgRmlyZWNyYXdsQXBwID0gY2xhc3Mge1xuICBhcGlLZXk7XG4gIGFwaVVybDtcbiAgaXNDbG91ZFNlcnZpY2UodXJsKSB7XG4gICAgcmV0dXJuIHVybC5pbmNsdWRlcyhcImFwaS5maXJlY3Jhd2wuZGV2XCIpO1xuICB9XG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgRmlyZWNyYXdsQXBwIGNsYXNzLlxuICAgKiBAcGFyYW0gY29uZmlnIC0gQ29uZmlndXJhdGlvbiBvcHRpb25zIGZvciB0aGUgRmlyZWNyYXdsQXBwIGluc3RhbmNlLlxuICAgKi9cbiAgY29uc3RydWN0b3IoeyBhcGlLZXkgPSBudWxsLCBhcGlVcmwgPSBudWxsIH0pIHtcbiAgICBjb25zdCBiYXNlVXJsID0gYXBpVXJsIHx8IFwiaHR0cHM6Ly9hcGkuZmlyZWNyYXdsLmRldlwiO1xuICAgIGlmICh0aGlzLmlzQ2xvdWRTZXJ2aWNlKGJhc2VVcmwpICYmIHR5cGVvZiBhcGlLZXkgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRocm93IG5ldyBGaXJlY3Jhd2xFcnJvcihcIk5vIEFQSSBrZXkgcHJvdmlkZWRcIiwgNDAxKTtcbiAgICB9XG4gICAgdGhpcy5hcGlLZXkgPSBhcGlLZXkgfHwgXCJcIjtcbiAgICB0aGlzLmFwaVVybCA9IGJhc2VVcmw7XG4gIH1cbiAgLyoqXG4gICAqIFNjcmFwZXMgYSBVUkwgdXNpbmcgdGhlIEZpcmVjcmF3bCBBUEkuXG4gICAqIEBwYXJhbSB1cmwgLSBUaGUgVVJMIHRvIHNjcmFwZS5cbiAgICogQHBhcmFtIHBhcmFtcyAtIEFkZGl0aW9uYWwgcGFyYW1ldGVycyBmb3IgdGhlIHNjcmFwZSByZXF1ZXN0LlxuICAgKiBAcmV0dXJucyBUaGUgcmVzcG9uc2UgZnJvbSB0aGUgc2NyYXBlIG9wZXJhdGlvbi5cbiAgICovXG4gIGFzeW5jIHNjcmFwZVVybCh1cmwsIHBhcmFtcykge1xuICAgIGNvbnN0IGhlYWRlcnMgPSB7XG4gICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgIEF1dGhvcml6YXRpb246IGBCZWFyZXIgJHt0aGlzLmFwaUtleX1gXG4gICAgfTtcbiAgICBsZXQganNvbkRhdGEgPSB7IHVybCwgLi4ucGFyYW1zIH07XG4gICAgaWYgKGpzb25EYXRhPy5leHRyYWN0Py5zY2hlbWEpIHtcbiAgICAgIGxldCBzY2hlbWEgPSBqc29uRGF0YS5leHRyYWN0LnNjaGVtYTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHNjaGVtYSA9IHpvZFRvSnNvblNjaGVtYShzY2hlbWEpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIH1cbiAgICAgIGpzb25EYXRhID0ge1xuICAgICAgICAuLi5qc29uRGF0YSxcbiAgICAgICAgZXh0cmFjdDoge1xuICAgICAgICAgIC4uLmpzb25EYXRhLmV4dHJhY3QsXG4gICAgICAgICAgc2NoZW1hXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChqc29uRGF0YT8uanNvbk9wdGlvbnM/LnNjaGVtYSkge1xuICAgICAgbGV0IHNjaGVtYSA9IGpzb25EYXRhLmpzb25PcHRpb25zLnNjaGVtYTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHNjaGVtYSA9IHpvZFRvSnNvblNjaGVtYShzY2hlbWEpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIH1cbiAgICAgIGpzb25EYXRhID0ge1xuICAgICAgICAuLi5qc29uRGF0YSxcbiAgICAgICAganNvbk9wdGlvbnM6IHtcbiAgICAgICAgICAuLi5qc29uRGF0YS5qc29uT3B0aW9ucyxcbiAgICAgICAgICBzY2hlbWFcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXhpb3MucG9zdChcbiAgICAgICAgdGhpcy5hcGlVcmwgKyBgL3YxL3NjcmFwZWAsXG4gICAgICAgIGpzb25EYXRhLFxuICAgICAgICB7IGhlYWRlcnMsIHRpbWVvdXQ6IHBhcmFtcz8udGltZW91dCAhPT0gdm9pZCAwID8gcGFyYW1zLnRpbWVvdXQgKyA1ZTMgOiB2b2lkIDAgfVxuICAgICAgKTtcbiAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICBjb25zdCByZXNwb25zZURhdGEgPSByZXNwb25zZS5kYXRhO1xuICAgICAgICBpZiAocmVzcG9uc2VEYXRhLnN1Y2Nlc3MpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICAgIHdhcm5pbmc6IHJlc3BvbnNlRGF0YS53YXJuaW5nLFxuICAgICAgICAgICAgZXJyb3I6IHJlc3BvbnNlRGF0YS5lcnJvcixcbiAgICAgICAgICAgIC4uLnJlc3BvbnNlRGF0YS5kYXRhXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRmlyZWNyYXdsRXJyb3IoYEZhaWxlZCB0byBzY3JhcGUgVVJMLiBFcnJvcjogJHtyZXNwb25zZURhdGEuZXJyb3J9YCwgcmVzcG9uc2Uuc3RhdHVzKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5oYW5kbGVFcnJvcihyZXNwb25zZSwgXCJzY3JhcGUgVVJMXCIpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aGlzLmhhbmRsZUVycm9yKGVycm9yLnJlc3BvbnNlLCBcInNjcmFwZSBVUkxcIik7XG4gICAgfVxuICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogXCJJbnRlcm5hbCBzZXJ2ZXIgZXJyb3IuXCIgfTtcbiAgfVxuICAvKipcbiAgICogU2VhcmNoZXMgdXNpbmcgdGhlIEZpcmVjcmF3bCBBUEkgYW5kIG9wdGlvbmFsbHkgc2NyYXBlcyB0aGUgcmVzdWx0cy5cbiAgICogQHBhcmFtIHF1ZXJ5IC0gVGhlIHNlYXJjaCBxdWVyeSBzdHJpbmcuXG4gICAqIEBwYXJhbSBwYXJhbXMgLSBPcHRpb25hbCBwYXJhbWV0ZXJzIGZvciB0aGUgc2VhcmNoIHJlcXVlc3QuXG4gICAqIEByZXR1cm5zIFRoZSByZXNwb25zZSBmcm9tIHRoZSBzZWFyY2ggb3BlcmF0aW9uLlxuICAgKi9cbiAgYXN5bmMgc2VhcmNoKHF1ZXJ5LCBwYXJhbXMpIHtcbiAgICBjb25zdCBoZWFkZXJzID0ge1xuICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7dGhpcy5hcGlLZXl9YFxuICAgIH07XG4gICAgbGV0IGpzb25EYXRhID0ge1xuICAgICAgcXVlcnksXG4gICAgICBsaW1pdDogcGFyYW1zPy5saW1pdCA/PyA1LFxuICAgICAgdGJzOiBwYXJhbXM/LnRicyxcbiAgICAgIGZpbHRlcjogcGFyYW1zPy5maWx0ZXIsXG4gICAgICBsYW5nOiBwYXJhbXM/LmxhbmcgPz8gXCJlblwiLFxuICAgICAgY291bnRyeTogcGFyYW1zPy5jb3VudHJ5ID8/IFwidXNcIixcbiAgICAgIGxvY2F0aW9uOiBwYXJhbXM/LmxvY2F0aW9uLFxuICAgICAgb3JpZ2luOiBwYXJhbXM/Lm9yaWdpbiA/PyBcImFwaVwiLFxuICAgICAgdGltZW91dDogcGFyYW1zPy50aW1lb3V0ID8/IDZlNCxcbiAgICAgIHNjcmFwZU9wdGlvbnM6IHBhcmFtcz8uc2NyYXBlT3B0aW9ucyA/PyB7IGZvcm1hdHM6IFtdIH1cbiAgICB9O1xuICAgIGlmIChqc29uRGF0YT8uc2NyYXBlT3B0aW9ucz8uZXh0cmFjdD8uc2NoZW1hKSB7XG4gICAgICBsZXQgc2NoZW1hID0ganNvbkRhdGEuc2NyYXBlT3B0aW9ucy5leHRyYWN0LnNjaGVtYTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHNjaGVtYSA9IHpvZFRvSnNvblNjaGVtYShzY2hlbWEpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIH1cbiAgICAgIGpzb25EYXRhID0ge1xuICAgICAgICAuLi5qc29uRGF0YSxcbiAgICAgICAgc2NyYXBlT3B0aW9uczoge1xuICAgICAgICAgIC4uLmpzb25EYXRhLnNjcmFwZU9wdGlvbnMsXG4gICAgICAgICAgZXh0cmFjdDoge1xuICAgICAgICAgICAgLi4uanNvbkRhdGEuc2NyYXBlT3B0aW9ucy5leHRyYWN0LFxuICAgICAgICAgICAgc2NoZW1hXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnBvc3RSZXF1ZXN0KFxuICAgICAgICB0aGlzLmFwaVVybCArIGAvdjEvc2VhcmNoYCxcbiAgICAgICAganNvbkRhdGEsXG4gICAgICAgIGhlYWRlcnNcbiAgICAgICk7XG4gICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2VEYXRhID0gcmVzcG9uc2UuZGF0YTtcbiAgICAgICAgaWYgKHJlc3BvbnNlRGF0YS5zdWNjZXNzKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgICBkYXRhOiByZXNwb25zZURhdGEuZGF0YSxcbiAgICAgICAgICAgIHdhcm5pbmc6IHJlc3BvbnNlRGF0YS53YXJuaW5nXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRmlyZWNyYXdsRXJyb3IoYEZhaWxlZCB0byBzZWFyY2guIEVycm9yOiAke3Jlc3BvbnNlRGF0YS5lcnJvcn1gLCByZXNwb25zZS5zdGF0dXMpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmhhbmRsZUVycm9yKHJlc3BvbnNlLCBcInNlYXJjaFwiKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGVycm9yLnJlc3BvbnNlPy5kYXRhPy5lcnJvcikge1xuICAgICAgICB0aHJvdyBuZXcgRmlyZWNyYXdsRXJyb3IoYFJlcXVlc3QgZmFpbGVkIHdpdGggc3RhdHVzIGNvZGUgJHtlcnJvci5yZXNwb25zZS5zdGF0dXN9LiBFcnJvcjogJHtlcnJvci5yZXNwb25zZS5kYXRhLmVycm9yfSAke2Vycm9yLnJlc3BvbnNlLmRhdGEuZGV0YWlscyA/IGAgLSAke0pTT04uc3RyaW5naWZ5KGVycm9yLnJlc3BvbnNlLmRhdGEuZGV0YWlscyl9YCA6IFwiXCJ9YCwgZXJyb3IucmVzcG9uc2Uuc3RhdHVzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBGaXJlY3Jhd2xFcnJvcihlcnJvci5tZXNzYWdlLCA1MDApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IFwiSW50ZXJuYWwgc2VydmVyIGVycm9yLlwiLCBkYXRhOiBbXSB9O1xuICB9XG4gIC8qKlxuICAgKiBJbml0aWF0ZXMgYSBjcmF3bCBqb2IgZm9yIGEgVVJMIHVzaW5nIHRoZSBGaXJlY3Jhd2wgQVBJLlxuICAgKiBAcGFyYW0gdXJsIC0gVGhlIFVSTCB0byBjcmF3bC5cbiAgICogQHBhcmFtIHBhcmFtcyAtIEFkZGl0aW9uYWwgcGFyYW1ldGVycyBmb3IgdGhlIGNyYXdsIHJlcXVlc3QuXG4gICAqIEBwYXJhbSBwb2xsSW50ZXJ2YWwgLSBUaW1lIGluIHNlY29uZHMgZm9yIGpvYiBzdGF0dXMgY2hlY2tzLlxuICAgKiBAcGFyYW0gaWRlbXBvdGVuY3lLZXkgLSBPcHRpb25hbCBpZGVtcG90ZW5jeSBrZXkgZm9yIHRoZSByZXF1ZXN0LlxuICAgKiBAcmV0dXJucyBUaGUgcmVzcG9uc2UgZnJvbSB0aGUgY3Jhd2wgb3BlcmF0aW9uLlxuICAgKi9cbiAgYXN5bmMgY3Jhd2xVcmwodXJsLCBwYXJhbXMsIHBvbGxJbnRlcnZhbCA9IDIsIGlkZW1wb3RlbmN5S2V5KSB7XG4gICAgY29uc3QgaGVhZGVycyA9IHRoaXMucHJlcGFyZUhlYWRlcnMoaWRlbXBvdGVuY3lLZXkpO1xuICAgIGxldCBqc29uRGF0YSA9IHsgdXJsLCAuLi5wYXJhbXMgfTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnBvc3RSZXF1ZXN0KFxuICAgICAgICB0aGlzLmFwaVVybCArIGAvdjEvY3Jhd2xgLFxuICAgICAgICBqc29uRGF0YSxcbiAgICAgICAgaGVhZGVyc1xuICAgICAgKTtcbiAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICBjb25zdCBpZCA9IHJlc3BvbnNlLmRhdGEuaWQ7XG4gICAgICAgIHJldHVybiB0aGlzLm1vbml0b3JKb2JTdGF0dXMoaWQsIGhlYWRlcnMsIHBvbGxJbnRlcnZhbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmhhbmRsZUVycm9yKHJlc3BvbnNlLCBcInN0YXJ0IGNyYXdsIGpvYlwiKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGVycm9yLnJlc3BvbnNlPy5kYXRhPy5lcnJvcikge1xuICAgICAgICB0aHJvdyBuZXcgRmlyZWNyYXdsRXJyb3IoYFJlcXVlc3QgZmFpbGVkIHdpdGggc3RhdHVzIGNvZGUgJHtlcnJvci5yZXNwb25zZS5zdGF0dXN9LiBFcnJvcjogJHtlcnJvci5yZXNwb25zZS5kYXRhLmVycm9yfSAke2Vycm9yLnJlc3BvbnNlLmRhdGEuZGV0YWlscyA/IGAgLSAke0pTT04uc3RyaW5naWZ5KGVycm9yLnJlc3BvbnNlLmRhdGEuZGV0YWlscyl9YCA6IFwiXCJ9YCwgZXJyb3IucmVzcG9uc2Uuc3RhdHVzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBGaXJlY3Jhd2xFcnJvcihlcnJvci5tZXNzYWdlLCA1MDApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IFwiSW50ZXJuYWwgc2VydmVyIGVycm9yLlwiIH07XG4gIH1cbiAgYXN5bmMgYXN5bmNDcmF3bFVybCh1cmwsIHBhcmFtcywgaWRlbXBvdGVuY3lLZXkpIHtcbiAgICBjb25zdCBoZWFkZXJzID0gdGhpcy5wcmVwYXJlSGVhZGVycyhpZGVtcG90ZW5jeUtleSk7XG4gICAgbGV0IGpzb25EYXRhID0geyB1cmwsIC4uLnBhcmFtcyB9O1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMucG9zdFJlcXVlc3QoXG4gICAgICAgIHRoaXMuYXBpVXJsICsgYC92MS9jcmF3bGAsXG4gICAgICAgIGpzb25EYXRhLFxuICAgICAgICBoZWFkZXJzXG4gICAgICApO1xuICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5oYW5kbGVFcnJvcihyZXNwb25zZSwgXCJzdGFydCBjcmF3bCBqb2JcIik7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvci5yZXNwb25zZT8uZGF0YT8uZXJyb3IpIHtcbiAgICAgICAgdGhyb3cgbmV3IEZpcmVjcmF3bEVycm9yKGBSZXF1ZXN0IGZhaWxlZCB3aXRoIHN0YXR1cyBjb2RlICR7ZXJyb3IucmVzcG9uc2Uuc3RhdHVzfS4gRXJyb3I6ICR7ZXJyb3IucmVzcG9uc2UuZGF0YS5lcnJvcn0gJHtlcnJvci5yZXNwb25zZS5kYXRhLmRldGFpbHMgPyBgIC0gJHtKU09OLnN0cmluZ2lmeShlcnJvci5yZXNwb25zZS5kYXRhLmRldGFpbHMpfWAgOiBcIlwifWAsIGVycm9yLnJlc3BvbnNlLnN0YXR1cyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRmlyZWNyYXdsRXJyb3IoZXJyb3IubWVzc2FnZSwgNTAwKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBcIkludGVybmFsIHNlcnZlciBlcnJvci5cIiB9O1xuICB9XG4gIC8qKlxuICAgKiBDaGVja3MgdGhlIHN0YXR1cyBvZiBhIGNyYXdsIGpvYiB1c2luZyB0aGUgRmlyZWNyYXdsIEFQSS5cbiAgICogQHBhcmFtIGlkIC0gVGhlIElEIG9mIHRoZSBjcmF3bCBvcGVyYXRpb24uXG4gICAqIEBwYXJhbSBnZXRBbGxEYXRhIC0gUGFnaW5hdGUgdGhyb3VnaCBhbGwgdGhlIHBhZ2VzIG9mIGRvY3VtZW50cywgcmV0dXJuaW5nIHRoZSBmdWxsIGxpc3Qgb2YgYWxsIGRvY3VtZW50cy4gKGRlZmF1bHQ6IGBmYWxzZWApXG4gICAqIEBwYXJhbSBuZXh0VVJMIC0gVGhlIGBuZXh0YCBVUkwgZnJvbSB0aGUgcHJldmlvdXMgY3Jhd2wgc3RhdHVzLiBPbmx5IHJlcXVpcmVkIGlmIHlvdSdyZSBub3QgbWFudWFsbHkgaW5jcmVhc2luZyBgc2tpcGAuIE9ubHkgdXNlZCB3aGVuIGBnZXRBbGxEYXRhID0gZmFsc2VgLlxuICAgKiBAcGFyYW0gc2tpcCAtIEhvdyBtYW55IGVudHJpZXMgdG8gc2tpcCB0byBwYWdpbmF0ZS4gT25seSByZXF1aXJlZCBpZiB5b3UncmUgbm90IHByb3ZpZGluZyBgbmV4dFVSTGAuIE9ubHkgdXNlZCB3aGVuIGBnZXRBbGxEYXRhID0gZmFsc2VgLlxuICAgKiBAcGFyYW0gbGltaXQgLSBIb3cgbWFueSBlbnRyaWVzIHRvIHJldHVybi4gT25seSB1c2VkIHdoZW4gYGdldEFsbERhdGEgPSBmYWxzZWAuXG4gICAqIEByZXR1cm5zIFRoZSByZXNwb25zZSBjb250YWluaW5nIHRoZSBqb2Igc3RhdHVzLlxuICAgKi9cbiAgYXN5bmMgY2hlY2tDcmF3bFN0YXR1cyhpZCwgZ2V0QWxsRGF0YSA9IGZhbHNlLCBuZXh0VVJMLCBza2lwLCBsaW1pdCkge1xuICAgIGlmICghaWQpIHtcbiAgICAgIHRocm93IG5ldyBGaXJlY3Jhd2xFcnJvcihcIk5vIGNyYXdsIElEIHByb3ZpZGVkXCIsIDQwMCk7XG4gICAgfVxuICAgIGNvbnN0IGhlYWRlcnMgPSB0aGlzLnByZXBhcmVIZWFkZXJzKCk7XG4gICAgY29uc3QgdGFyZ2V0VVJMID0gbmV3IFVSTChuZXh0VVJMID8/IGAke3RoaXMuYXBpVXJsfS92MS9jcmF3bC8ke2lkfWApO1xuICAgIGlmIChza2lwICE9PSB2b2lkIDApIHtcbiAgICAgIHRhcmdldFVSTC5zZWFyY2hQYXJhbXMuc2V0KFwic2tpcFwiLCBza2lwLnRvU3RyaW5nKCkpO1xuICAgIH1cbiAgICBpZiAobGltaXQgIT09IHZvaWQgMCkge1xuICAgICAgdGFyZ2V0VVJMLnNlYXJjaFBhcmFtcy5zZXQoXCJsaW1pdFwiLCBsaW1pdC50b1N0cmluZygpKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5nZXRSZXF1ZXN0KFxuICAgICAgICB0YXJnZXRVUkwuaHJlZixcbiAgICAgICAgaGVhZGVyc1xuICAgICAgKTtcbiAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICBsZXQgYWxsRGF0YSA9IHJlc3BvbnNlLmRhdGEuZGF0YTtcbiAgICAgICAgaWYgKGdldEFsbERhdGEgJiYgcmVzcG9uc2UuZGF0YS5zdGF0dXMgPT09IFwiY29tcGxldGVkXCIpIHtcbiAgICAgICAgICBsZXQgc3RhdHVzRGF0YSA9IHJlc3BvbnNlLmRhdGE7XG4gICAgICAgICAgaWYgKFwiZGF0YVwiIGluIHN0YXR1c0RhdGEpIHtcbiAgICAgICAgICAgIGxldCBkYXRhID0gc3RhdHVzRGF0YS5kYXRhO1xuICAgICAgICAgICAgd2hpbGUgKHR5cGVvZiBzdGF0dXNEYXRhID09PSBcIm9iamVjdFwiICYmIFwibmV4dFwiIGluIHN0YXR1c0RhdGEpIHtcbiAgICAgICAgICAgICAgaWYgKGRhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgc3RhdHVzRGF0YSA9IChhd2FpdCB0aGlzLmdldFJlcXVlc3Qoc3RhdHVzRGF0YS5uZXh0LCBoZWFkZXJzKSkuZGF0YTtcbiAgICAgICAgICAgICAgZGF0YSA9IGRhdGEuY29uY2F0KHN0YXR1c0RhdGEuZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhbGxEYXRhID0gZGF0YTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3AgPSB7XG4gICAgICAgICAgc3VjY2VzczogcmVzcG9uc2UuZGF0YS5zdWNjZXNzLFxuICAgICAgICAgIHN0YXR1czogcmVzcG9uc2UuZGF0YS5zdGF0dXMsXG4gICAgICAgICAgdG90YWw6IHJlc3BvbnNlLmRhdGEudG90YWwsXG4gICAgICAgICAgY29tcGxldGVkOiByZXNwb25zZS5kYXRhLmNvbXBsZXRlZCxcbiAgICAgICAgICBjcmVkaXRzVXNlZDogcmVzcG9uc2UuZGF0YS5jcmVkaXRzVXNlZCxcbiAgICAgICAgICBuZXh0OiBnZXRBbGxEYXRhID8gdm9pZCAwIDogcmVzcG9uc2UuZGF0YS5uZXh0LFxuICAgICAgICAgIGV4cGlyZXNBdDogbmV3IERhdGUocmVzcG9uc2UuZGF0YS5leHBpcmVzQXQpLFxuICAgICAgICAgIGRhdGE6IGFsbERhdGFcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCFyZXNwb25zZS5kYXRhLnN1Y2Nlc3MgJiYgcmVzcG9uc2UuZGF0YS5lcnJvcikge1xuICAgICAgICAgIHJlc3AgPSB7XG4gICAgICAgICAgICAuLi5yZXNwLFxuICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICBlcnJvcjogcmVzcG9uc2UuZGF0YS5lcnJvclxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3BvbnNlLmRhdGEubmV4dCkge1xuICAgICAgICAgIHJlc3AubmV4dCA9IHJlc3BvbnNlLmRhdGEubmV4dDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzcDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuaGFuZGxlRXJyb3IocmVzcG9uc2UsIFwiY2hlY2sgY3Jhd2wgc3RhdHVzXCIpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgRmlyZWNyYXdsRXJyb3IoZXJyb3IubWVzc2FnZSwgNTAwKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBcIkludGVybmFsIHNlcnZlciBlcnJvci5cIiB9O1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGluZm9ybWF0aW9uIGFib3V0IGNyYXdsIGVycm9ycy5cbiAgICogQHBhcmFtIGlkIC0gVGhlIElEIG9mIHRoZSBjcmF3bCBvcGVyYXRpb24uXG4gICAqIEByZXR1cm5zIEluZm9ybWF0aW9uIGFib3V0IGNyYXdsIGVycm9ycy5cbiAgICovXG4gIGFzeW5jIGNoZWNrQ3Jhd2xFcnJvcnMoaWQpIHtcbiAgICBjb25zdCBoZWFkZXJzID0gdGhpcy5wcmVwYXJlSGVhZGVycygpO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZGVsZXRlUmVxdWVzdChcbiAgICAgICAgYCR7dGhpcy5hcGlVcmx9L3YxL2NyYXdsLyR7aWR9L2Vycm9yc2AsXG4gICAgICAgIGhlYWRlcnNcbiAgICAgICk7XG4gICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmhhbmRsZUVycm9yKHJlc3BvbnNlLCBcImNoZWNrIGNyYXdsIGVycm9yc1wiKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEZpcmVjcmF3bEVycm9yKGVycm9yLm1lc3NhZ2UsIDUwMCk7XG4gICAgfVxuICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogXCJJbnRlcm5hbCBzZXJ2ZXIgZXJyb3IuXCIgfTtcbiAgfVxuICAvKipcbiAgICogQ2FuY2VscyBhIGNyYXdsIGpvYiB1c2luZyB0aGUgRmlyZWNyYXdsIEFQSS5cbiAgICogQHBhcmFtIGlkIC0gVGhlIElEIG9mIHRoZSBjcmF3bCBvcGVyYXRpb24uXG4gICAqIEByZXR1cm5zIFRoZSByZXNwb25zZSBmcm9tIHRoZSBjYW5jZWwgY3Jhd2wgb3BlcmF0aW9uLlxuICAgKi9cbiAgYXN5bmMgY2FuY2VsQ3Jhd2woaWQpIHtcbiAgICBjb25zdCBoZWFkZXJzID0gdGhpcy5wcmVwYXJlSGVhZGVycygpO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZGVsZXRlUmVxdWVzdChcbiAgICAgICAgYCR7dGhpcy5hcGlVcmx9L3YxL2NyYXdsLyR7aWR9YCxcbiAgICAgICAgaGVhZGVyc1xuICAgICAgKTtcbiAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuaGFuZGxlRXJyb3IocmVzcG9uc2UsIFwiY2FuY2VsIGNyYXdsIGpvYlwiKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEZpcmVjcmF3bEVycm9yKGVycm9yLm1lc3NhZ2UsIDUwMCk7XG4gICAgfVxuICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogXCJJbnRlcm5hbCBzZXJ2ZXIgZXJyb3IuXCIgfTtcbiAgfVxuICAvKipcbiAgICogSW5pdGlhdGVzIGEgY3Jhd2wgam9iIGFuZCByZXR1cm5zIGEgQ3Jhd2xXYXRjaGVyIHRvIG1vbml0b3IgdGhlIGpvYiB2aWEgV2ViU29ja2V0LlxuICAgKiBAcGFyYW0gdXJsIC0gVGhlIFVSTCB0byBjcmF3bC5cbiAgICogQHBhcmFtIHBhcmFtcyAtIEFkZGl0aW9uYWwgcGFyYW1ldGVycyBmb3IgdGhlIGNyYXdsIHJlcXVlc3QuXG4gICAqIEBwYXJhbSBpZGVtcG90ZW5jeUtleSAtIE9wdGlvbmFsIGlkZW1wb3RlbmN5IGtleSBmb3IgdGhlIHJlcXVlc3QuXG4gICAqIEByZXR1cm5zIEEgQ3Jhd2xXYXRjaGVyIGluc3RhbmNlIHRvIG1vbml0b3IgdGhlIGNyYXdsIGpvYi5cbiAgICovXG4gIGFzeW5jIGNyYXdsVXJsQW5kV2F0Y2godXJsLCBwYXJhbXMsIGlkZW1wb3RlbmN5S2V5KSB7XG4gICAgY29uc3QgY3Jhd2wgPSBhd2FpdCB0aGlzLmFzeW5jQ3Jhd2xVcmwodXJsLCBwYXJhbXMsIGlkZW1wb3RlbmN5S2V5KTtcbiAgICBpZiAoY3Jhd2wuc3VjY2VzcyAmJiBjcmF3bC5pZCkge1xuICAgICAgY29uc3QgaWQgPSBjcmF3bC5pZDtcbiAgICAgIHJldHVybiBuZXcgQ3Jhd2xXYXRjaGVyKGlkLCB0aGlzKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEZpcmVjcmF3bEVycm9yKFwiQ3Jhd2wgam9iIGZhaWxlZCB0byBzdGFydFwiLCA0MDApO1xuICB9XG4gIC8qKlxuICAgKiBNYXBzIGEgVVJMIHVzaW5nIHRoZSBGaXJlY3Jhd2wgQVBJLlxuICAgKiBAcGFyYW0gdXJsIC0gVGhlIFVSTCB0byBtYXAuXG4gICAqIEBwYXJhbSBwYXJhbXMgLSBBZGRpdGlvbmFsIHBhcmFtZXRlcnMgZm9yIHRoZSBtYXAgcmVxdWVzdC5cbiAgICogQHJldHVybnMgVGhlIHJlc3BvbnNlIGZyb20gdGhlIG1hcCBvcGVyYXRpb24uXG4gICAqL1xuICBhc3luYyBtYXBVcmwodXJsLCBwYXJhbXMpIHtcbiAgICBjb25zdCBoZWFkZXJzID0gdGhpcy5wcmVwYXJlSGVhZGVycygpO1xuICAgIGxldCBqc29uRGF0YSA9IHsgdXJsLCAuLi5wYXJhbXMgfTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnBvc3RSZXF1ZXN0KFxuICAgICAgICB0aGlzLmFwaVVybCArIGAvdjEvbWFwYCxcbiAgICAgICAganNvbkRhdGEsXG4gICAgICAgIGhlYWRlcnNcbiAgICAgICk7XG4gICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmhhbmRsZUVycm9yKHJlc3BvbnNlLCBcIm1hcFwiKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEZpcmVjcmF3bEVycm9yKGVycm9yLm1lc3NhZ2UsIDUwMCk7XG4gICAgfVxuICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogXCJJbnRlcm5hbCBzZXJ2ZXIgZXJyb3IuXCIgfTtcbiAgfVxuICAvKipcbiAgICogSW5pdGlhdGVzIGEgYmF0Y2ggc2NyYXBlIGpvYiBmb3IgbXVsdGlwbGUgVVJMcyB1c2luZyB0aGUgRmlyZWNyYXdsIEFQSS5cbiAgICogQHBhcmFtIHVybCAtIFRoZSBVUkxzIHRvIHNjcmFwZS5cbiAgICogQHBhcmFtIHBhcmFtcyAtIEFkZGl0aW9uYWwgcGFyYW1ldGVycyBmb3IgdGhlIHNjcmFwZSByZXF1ZXN0LlxuICAgKiBAcGFyYW0gcG9sbEludGVydmFsIC0gVGltZSBpbiBzZWNvbmRzIGZvciBqb2Igc3RhdHVzIGNoZWNrcy5cbiAgICogQHBhcmFtIGlkZW1wb3RlbmN5S2V5IC0gT3B0aW9uYWwgaWRlbXBvdGVuY3kga2V5IGZvciB0aGUgcmVxdWVzdC5cbiAgICogQHBhcmFtIHdlYmhvb2sgLSBPcHRpb25hbCB3ZWJob29rIGZvciB0aGUgYmF0Y2ggc2NyYXBlLlxuICAgKiBAcGFyYW0gaWdub3JlSW52YWxpZFVSTHMgLSBPcHRpb25hbCBmbGFnIHRvIGlnbm9yZSBpbnZhbGlkIFVSTHMuXG4gICAqIEByZXR1cm5zIFRoZSByZXNwb25zZSBmcm9tIHRoZSBjcmF3bCBvcGVyYXRpb24uXG4gICAqL1xuICBhc3luYyBiYXRjaFNjcmFwZVVybHModXJscywgcGFyYW1zLCBwb2xsSW50ZXJ2YWwgPSAyLCBpZGVtcG90ZW5jeUtleSwgd2ViaG9vaywgaWdub3JlSW52YWxpZFVSTHMpIHtcbiAgICBjb25zdCBoZWFkZXJzID0gdGhpcy5wcmVwYXJlSGVhZGVycyhpZGVtcG90ZW5jeUtleSk7XG4gICAgbGV0IGpzb25EYXRhID0geyB1cmxzLCB3ZWJob29rLCBpZ25vcmVJbnZhbGlkVVJMcywgLi4ucGFyYW1zIH07XG4gICAgaWYgKGpzb25EYXRhPy5leHRyYWN0Py5zY2hlbWEpIHtcbiAgICAgIGxldCBzY2hlbWEgPSBqc29uRGF0YS5leHRyYWN0LnNjaGVtYTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHNjaGVtYSA9IHpvZFRvSnNvblNjaGVtYShzY2hlbWEpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIH1cbiAgICAgIGpzb25EYXRhID0ge1xuICAgICAgICAuLi5qc29uRGF0YSxcbiAgICAgICAgZXh0cmFjdDoge1xuICAgICAgICAgIC4uLmpzb25EYXRhLmV4dHJhY3QsXG4gICAgICAgICAgc2NoZW1hXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChqc29uRGF0YT8uanNvbk9wdGlvbnM/LnNjaGVtYSkge1xuICAgICAgbGV0IHNjaGVtYSA9IGpzb25EYXRhLmpzb25PcHRpb25zLnNjaGVtYTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHNjaGVtYSA9IHpvZFRvSnNvblNjaGVtYShzY2hlbWEpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIH1cbiAgICAgIGpzb25EYXRhID0ge1xuICAgICAgICAuLi5qc29uRGF0YSxcbiAgICAgICAganNvbk9wdGlvbnM6IHtcbiAgICAgICAgICAuLi5qc29uRGF0YS5qc29uT3B0aW9ucyxcbiAgICAgICAgICBzY2hlbWFcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wb3N0UmVxdWVzdChcbiAgICAgICAgdGhpcy5hcGlVcmwgKyBgL3YxL2JhdGNoL3NjcmFwZWAsXG4gICAgICAgIGpzb25EYXRhLFxuICAgICAgICBoZWFkZXJzXG4gICAgICApO1xuICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICAgIGNvbnN0IGlkID0gcmVzcG9uc2UuZGF0YS5pZDtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9uaXRvckpvYlN0YXR1cyhpZCwgaGVhZGVycywgcG9sbEludGVydmFsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuaGFuZGxlRXJyb3IocmVzcG9uc2UsIFwic3RhcnQgYmF0Y2ggc2NyYXBlIGpvYlwiKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGVycm9yLnJlc3BvbnNlPy5kYXRhPy5lcnJvcikge1xuICAgICAgICB0aHJvdyBuZXcgRmlyZWNyYXdsRXJyb3IoYFJlcXVlc3QgZmFpbGVkIHdpdGggc3RhdHVzIGNvZGUgJHtlcnJvci5yZXNwb25zZS5zdGF0dXN9LiBFcnJvcjogJHtlcnJvci5yZXNwb25zZS5kYXRhLmVycm9yfSAke2Vycm9yLnJlc3BvbnNlLmRhdGEuZGV0YWlscyA/IGAgLSAke0pTT04uc3RyaW5naWZ5KGVycm9yLnJlc3BvbnNlLmRhdGEuZGV0YWlscyl9YCA6IFwiXCJ9YCwgZXJyb3IucmVzcG9uc2Uuc3RhdHVzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBGaXJlY3Jhd2xFcnJvcihlcnJvci5tZXNzYWdlLCA1MDApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IFwiSW50ZXJuYWwgc2VydmVyIGVycm9yLlwiIH07XG4gIH1cbiAgYXN5bmMgYXN5bmNCYXRjaFNjcmFwZVVybHModXJscywgcGFyYW1zLCBpZGVtcG90ZW5jeUtleSwgd2ViaG9vaywgaWdub3JlSW52YWxpZFVSTHMpIHtcbiAgICBjb25zdCBoZWFkZXJzID0gdGhpcy5wcmVwYXJlSGVhZGVycyhpZGVtcG90ZW5jeUtleSk7XG4gICAgbGV0IGpzb25EYXRhID0geyB1cmxzLCB3ZWJob29rLCBpZ25vcmVJbnZhbGlkVVJMcywgLi4ucGFyYW1zID8/IHt9IH07XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wb3N0UmVxdWVzdChcbiAgICAgICAgdGhpcy5hcGlVcmwgKyBgL3YxL2JhdGNoL3NjcmFwZWAsXG4gICAgICAgIGpzb25EYXRhLFxuICAgICAgICBoZWFkZXJzXG4gICAgICApO1xuICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5oYW5kbGVFcnJvcihyZXNwb25zZSwgXCJzdGFydCBiYXRjaCBzY3JhcGUgam9iXCIpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoZXJyb3IucmVzcG9uc2U/LmRhdGE/LmVycm9yKSB7XG4gICAgICAgIHRocm93IG5ldyBGaXJlY3Jhd2xFcnJvcihgUmVxdWVzdCBmYWlsZWQgd2l0aCBzdGF0dXMgY29kZSAke2Vycm9yLnJlc3BvbnNlLnN0YXR1c30uIEVycm9yOiAke2Vycm9yLnJlc3BvbnNlLmRhdGEuZXJyb3J9ICR7ZXJyb3IucmVzcG9uc2UuZGF0YS5kZXRhaWxzID8gYCAtICR7SlNPTi5zdHJpbmdpZnkoZXJyb3IucmVzcG9uc2UuZGF0YS5kZXRhaWxzKX1gIDogXCJcIn1gLCBlcnJvci5yZXNwb25zZS5zdGF0dXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEZpcmVjcmF3bEVycm9yKGVycm9yLm1lc3NhZ2UsIDUwMCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogXCJJbnRlcm5hbCBzZXJ2ZXIgZXJyb3IuXCIgfTtcbiAgfVxuICAvKipcbiAgICogSW5pdGlhdGVzIGEgYmF0Y2ggc2NyYXBlIGpvYiBhbmQgcmV0dXJucyBhIENyYXdsV2F0Y2hlciB0byBtb25pdG9yIHRoZSBqb2IgdmlhIFdlYlNvY2tldC5cbiAgICogQHBhcmFtIHVybHMgLSBUaGUgVVJMIHRvIHNjcmFwZS5cbiAgICogQHBhcmFtIHBhcmFtcyAtIEFkZGl0aW9uYWwgcGFyYW1ldGVycyBmb3IgdGhlIHNjcmFwZSByZXF1ZXN0LlxuICAgKiBAcGFyYW0gaWRlbXBvdGVuY3lLZXkgLSBPcHRpb25hbCBpZGVtcG90ZW5jeSBrZXkgZm9yIHRoZSByZXF1ZXN0LlxuICAgKiBAcmV0dXJucyBBIENyYXdsV2F0Y2hlciBpbnN0YW5jZSB0byBtb25pdG9yIHRoZSBjcmF3bCBqb2IuXG4gICAqL1xuICBhc3luYyBiYXRjaFNjcmFwZVVybHNBbmRXYXRjaCh1cmxzLCBwYXJhbXMsIGlkZW1wb3RlbmN5S2V5LCB3ZWJob29rLCBpZ25vcmVJbnZhbGlkVVJMcykge1xuICAgIGNvbnN0IGNyYXdsID0gYXdhaXQgdGhpcy5hc3luY0JhdGNoU2NyYXBlVXJscyh1cmxzLCBwYXJhbXMsIGlkZW1wb3RlbmN5S2V5LCB3ZWJob29rLCBpZ25vcmVJbnZhbGlkVVJMcyk7XG4gICAgaWYgKGNyYXdsLnN1Y2Nlc3MgJiYgY3Jhd2wuaWQpIHtcbiAgICAgIGNvbnN0IGlkID0gY3Jhd2wuaWQ7XG4gICAgICByZXR1cm4gbmV3IENyYXdsV2F0Y2hlcihpZCwgdGhpcyk7XG4gICAgfVxuICAgIHRocm93IG5ldyBGaXJlY3Jhd2xFcnJvcihcIkJhdGNoIHNjcmFwZSBqb2IgZmFpbGVkIHRvIHN0YXJ0XCIsIDQwMCk7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrcyB0aGUgc3RhdHVzIG9mIGEgYmF0Y2ggc2NyYXBlIGpvYiB1c2luZyB0aGUgRmlyZWNyYXdsIEFQSS5cbiAgICogQHBhcmFtIGlkIC0gVGhlIElEIG9mIHRoZSBiYXRjaCBzY3JhcGUgb3BlcmF0aW9uLlxuICAgKiBAcGFyYW0gZ2V0QWxsRGF0YSAtIFBhZ2luYXRlIHRocm91Z2ggYWxsIHRoZSBwYWdlcyBvZiBkb2N1bWVudHMsIHJldHVybmluZyB0aGUgZnVsbCBsaXN0IG9mIGFsbCBkb2N1bWVudHMuIChkZWZhdWx0OiBgZmFsc2VgKVxuICAgKiBAcGFyYW0gbmV4dFVSTCAtIFRoZSBgbmV4dGAgVVJMIGZyb20gdGhlIHByZXZpb3VzIGJhdGNoIHNjcmFwZSBzdGF0dXMuIE9ubHkgcmVxdWlyZWQgaWYgeW91J3JlIG5vdCBtYW51YWxseSBpbmNyZWFzaW5nIGBza2lwYC4gT25seSB1c2VkIHdoZW4gYGdldEFsbERhdGEgPSBmYWxzZWAuXG4gICAqIEBwYXJhbSBza2lwIC0gSG93IG1hbnkgZW50cmllcyB0byBza2lwIHRvIHBhZ2luYXRlLiBPbmx5IHVzZWQgd2hlbiBgZ2V0QWxsRGF0YSA9IGZhbHNlYC5cbiAgICogQHBhcmFtIGxpbWl0IC0gSG93IG1hbnkgZW50cmllcyB0byByZXR1cm4uIE9ubHkgdXNlZCB3aGVuIGBnZXRBbGxEYXRhID0gZmFsc2VgLlxuICAgKiBAcmV0dXJucyBUaGUgcmVzcG9uc2UgY29udGFpbmluZyB0aGUgam9iIHN0YXR1cy5cbiAgICovXG4gIGFzeW5jIGNoZWNrQmF0Y2hTY3JhcGVTdGF0dXMoaWQsIGdldEFsbERhdGEgPSBmYWxzZSwgbmV4dFVSTCwgc2tpcCwgbGltaXQpIHtcbiAgICBpZiAoIWlkKSB7XG4gICAgICB0aHJvdyBuZXcgRmlyZWNyYXdsRXJyb3IoXCJObyBiYXRjaCBzY3JhcGUgSUQgcHJvdmlkZWRcIiwgNDAwKTtcbiAgICB9XG4gICAgY29uc3QgaGVhZGVycyA9IHRoaXMucHJlcGFyZUhlYWRlcnMoKTtcbiAgICBjb25zdCB0YXJnZXRVUkwgPSBuZXcgVVJMKG5leHRVUkwgPz8gYCR7dGhpcy5hcGlVcmx9L3YxL2JhdGNoL3NjcmFwZS8ke2lkfWApO1xuICAgIGlmIChza2lwICE9PSB2b2lkIDApIHtcbiAgICAgIHRhcmdldFVSTC5zZWFyY2hQYXJhbXMuc2V0KFwic2tpcFwiLCBza2lwLnRvU3RyaW5nKCkpO1xuICAgIH1cbiAgICBpZiAobGltaXQgIT09IHZvaWQgMCkge1xuICAgICAgdGFyZ2V0VVJMLnNlYXJjaFBhcmFtcy5zZXQoXCJsaW1pdFwiLCBsaW1pdC50b1N0cmluZygpKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5nZXRSZXF1ZXN0KFxuICAgICAgICB0YXJnZXRVUkwuaHJlZixcbiAgICAgICAgaGVhZGVyc1xuICAgICAgKTtcbiAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICBsZXQgYWxsRGF0YSA9IHJlc3BvbnNlLmRhdGEuZGF0YTtcbiAgICAgICAgaWYgKGdldEFsbERhdGEgJiYgcmVzcG9uc2UuZGF0YS5zdGF0dXMgPT09IFwiY29tcGxldGVkXCIpIHtcbiAgICAgICAgICBsZXQgc3RhdHVzRGF0YSA9IHJlc3BvbnNlLmRhdGE7XG4gICAgICAgICAgaWYgKFwiZGF0YVwiIGluIHN0YXR1c0RhdGEpIHtcbiAgICAgICAgICAgIGxldCBkYXRhID0gc3RhdHVzRGF0YS5kYXRhO1xuICAgICAgICAgICAgd2hpbGUgKHR5cGVvZiBzdGF0dXNEYXRhID09PSBcIm9iamVjdFwiICYmIFwibmV4dFwiIGluIHN0YXR1c0RhdGEpIHtcbiAgICAgICAgICAgICAgaWYgKGRhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgc3RhdHVzRGF0YSA9IChhd2FpdCB0aGlzLmdldFJlcXVlc3Qoc3RhdHVzRGF0YS5uZXh0LCBoZWFkZXJzKSkuZGF0YTtcbiAgICAgICAgICAgICAgZGF0YSA9IGRhdGEuY29uY2F0KHN0YXR1c0RhdGEuZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhbGxEYXRhID0gZGF0YTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3AgPSB7XG4gICAgICAgICAgc3VjY2VzczogcmVzcG9uc2UuZGF0YS5zdWNjZXNzLFxuICAgICAgICAgIHN0YXR1czogcmVzcG9uc2UuZGF0YS5zdGF0dXMsXG4gICAgICAgICAgdG90YWw6IHJlc3BvbnNlLmRhdGEudG90YWwsXG4gICAgICAgICAgY29tcGxldGVkOiByZXNwb25zZS5kYXRhLmNvbXBsZXRlZCxcbiAgICAgICAgICBjcmVkaXRzVXNlZDogcmVzcG9uc2UuZGF0YS5jcmVkaXRzVXNlZCxcbiAgICAgICAgICBuZXh0OiBnZXRBbGxEYXRhID8gdm9pZCAwIDogcmVzcG9uc2UuZGF0YS5uZXh0LFxuICAgICAgICAgIGV4cGlyZXNBdDogbmV3IERhdGUocmVzcG9uc2UuZGF0YS5leHBpcmVzQXQpLFxuICAgICAgICAgIGRhdGE6IGFsbERhdGFcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCFyZXNwb25zZS5kYXRhLnN1Y2Nlc3MgJiYgcmVzcG9uc2UuZGF0YS5lcnJvcikge1xuICAgICAgICAgIHJlc3AgPSB7XG4gICAgICAgICAgICAuLi5yZXNwLFxuICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICBlcnJvcjogcmVzcG9uc2UuZGF0YS5lcnJvclxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3BvbnNlLmRhdGEubmV4dCkge1xuICAgICAgICAgIHJlc3AubmV4dCA9IHJlc3BvbnNlLmRhdGEubmV4dDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzcDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuaGFuZGxlRXJyb3IocmVzcG9uc2UsIFwiY2hlY2sgYmF0Y2ggc2NyYXBlIHN0YXR1c1wiKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEZpcmVjcmF3bEVycm9yKGVycm9yLm1lc3NhZ2UsIDUwMCk7XG4gICAgfVxuICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogXCJJbnRlcm5hbCBzZXJ2ZXIgZXJyb3IuXCIgfTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBpbmZvcm1hdGlvbiBhYm91dCBiYXRjaCBzY3JhcGUgZXJyb3JzLlxuICAgKiBAcGFyYW0gaWQgLSBUaGUgSUQgb2YgdGhlIGJhdGNoIHNjcmFwZSBvcGVyYXRpb24uXG4gICAqIEByZXR1cm5zIEluZm9ybWF0aW9uIGFib3V0IGJhdGNoIHNjcmFwZSBlcnJvcnMuXG4gICAqL1xuICBhc3luYyBjaGVja0JhdGNoU2NyYXBlRXJyb3JzKGlkKSB7XG4gICAgY29uc3QgaGVhZGVycyA9IHRoaXMucHJlcGFyZUhlYWRlcnMoKTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmRlbGV0ZVJlcXVlc3QoXG4gICAgICAgIGAke3RoaXMuYXBpVXJsfS92MS9iYXRjaC9zY3JhcGUvJHtpZH0vZXJyb3JzYCxcbiAgICAgICAgaGVhZGVyc1xuICAgICAgKTtcbiAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuaGFuZGxlRXJyb3IocmVzcG9uc2UsIFwiY2hlY2sgYmF0Y2ggc2NyYXBlIGVycm9yc1wiKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEZpcmVjcmF3bEVycm9yKGVycm9yLm1lc3NhZ2UsIDUwMCk7XG4gICAgfVxuICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogXCJJbnRlcm5hbCBzZXJ2ZXIgZXJyb3IuXCIgfTtcbiAgfVxuICAvKipcbiAgICogRXh0cmFjdHMgaW5mb3JtYXRpb24gZnJvbSBVUkxzIHVzaW5nIHRoZSBGaXJlY3Jhd2wgQVBJLlxuICAgKiBDdXJyZW50bHkgaW4gQmV0YS4gRXhwZWN0IGJyZWFraW5nIGNoYW5nZXMgb24gZnV0dXJlIG1pbm9yIHZlcnNpb25zLlxuICAgKiBAcGFyYW0gdXJscyAtIFRoZSBVUkxzIHRvIGV4dHJhY3QgaW5mb3JtYXRpb24gZnJvbS4gT3B0aW9uYWwgaWYgdXNpbmcgb3RoZXIgbWV0aG9kcyBmb3IgZGF0YSBleHRyYWN0aW9uLlxuICAgKiBAcGFyYW0gcGFyYW1zIC0gQWRkaXRpb25hbCBwYXJhbWV0ZXJzIGZvciB0aGUgZXh0cmFjdCByZXF1ZXN0LlxuICAgKiBAcmV0dXJucyBUaGUgcmVzcG9uc2UgZnJvbSB0aGUgZXh0cmFjdCBvcGVyYXRpb24uXG4gICAqL1xuICBhc3luYyBleHRyYWN0KHVybHMsIHBhcmFtcykge1xuICAgIGNvbnN0IGhlYWRlcnMgPSB0aGlzLnByZXBhcmVIZWFkZXJzKCk7XG4gICAgbGV0IGpzb25EYXRhID0geyB1cmxzLCAuLi5wYXJhbXMgfTtcbiAgICBsZXQganNvblNjaGVtYTtcbiAgICB0cnkge1xuICAgICAgaWYgKCFwYXJhbXM/LnNjaGVtYSkge1xuICAgICAgICBqc29uU2NoZW1hID0gdm9pZCAwO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcGFyYW1zLnNjaGVtYSA9PT0gXCJvYmplY3RcIiAmJiBwYXJhbXMuc2NoZW1hICE9PSBudWxsICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihwYXJhbXMuc2NoZW1hKT8uY29uc3RydWN0b3I/Lm5hbWU/LnN0YXJ0c1dpdGgoXCJab2RcIikpIHtcbiAgICAgICAganNvblNjaGVtYSA9IHpvZFRvSnNvblNjaGVtYShwYXJhbXMuc2NoZW1hKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGpzb25TY2hlbWEgPSBwYXJhbXMuc2NoZW1hO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgRmlyZWNyYXdsRXJyb3IoXCJJbnZhbGlkIHNjaGVtYS4gU2NoZW1hIG11c3QgYmUgZWl0aGVyIGEgdmFsaWQgWm9kIHNjaGVtYSBvciBKU09OIHNjaGVtYSBvYmplY3QuXCIsIDQwMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMucG9zdFJlcXVlc3QoXG4gICAgICAgIHRoaXMuYXBpVXJsICsgYC92MS9leHRyYWN0YCxcbiAgICAgICAgeyAuLi5qc29uRGF0YSwgc2NoZW1hOiBqc29uU2NoZW1hLCBvcmlnaW46IHBhcmFtcz8ub3JpZ2luIHx8IFwiYXBpLXNka1wiIH0sXG4gICAgICAgIGhlYWRlcnNcbiAgICAgICk7XG4gICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgY29uc3Qgam9iSWQgPSByZXNwb25zZS5kYXRhLmlkO1xuICAgICAgICBsZXQgZXh0cmFjdFN0YXR1cztcbiAgICAgICAgZG8ge1xuICAgICAgICAgIGNvbnN0IHN0YXR1c1Jlc3BvbnNlID0gYXdhaXQgdGhpcy5nZXRSZXF1ZXN0KFxuICAgICAgICAgICAgYCR7dGhpcy5hcGlVcmx9L3YxL2V4dHJhY3QvJHtqb2JJZH1gLFxuICAgICAgICAgICAgaGVhZGVyc1xuICAgICAgICAgICk7XG4gICAgICAgICAgZXh0cmFjdFN0YXR1cyA9IHN0YXR1c1Jlc3BvbnNlLmRhdGE7XG4gICAgICAgICAgaWYgKGV4dHJhY3RTdGF0dXMuc3RhdHVzID09PSBcImNvbXBsZXRlZFwiKSB7XG4gICAgICAgICAgICBpZiAoZXh0cmFjdFN0YXR1cy5zdWNjZXNzKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICAgICAgICBkYXRhOiBleHRyYWN0U3RhdHVzLmRhdGEsXG4gICAgICAgICAgICAgICAgd2FybmluZzogZXh0cmFjdFN0YXR1cy53YXJuaW5nLFxuICAgICAgICAgICAgICAgIGVycm9yOiBleHRyYWN0U3RhdHVzLmVycm9yLFxuICAgICAgICAgICAgICAgIHNvdXJjZXM6IGV4dHJhY3RTdGF0dXM/LnNvdXJjZXMgfHwgdm9pZCAwXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRmlyZWNyYXdsRXJyb3IoYEZhaWxlZCB0byBleHRyYWN0IGRhdGEuIEVycm9yOiAke2V4dHJhY3RTdGF0dXMuZXJyb3J9YCwgc3RhdHVzUmVzcG9uc2Uuc3RhdHVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKGV4dHJhY3RTdGF0dXMuc3RhdHVzID09PSBcImZhaWxlZFwiIHx8IGV4dHJhY3RTdGF0dXMuc3RhdHVzID09PSBcImNhbmNlbGxlZFwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRmlyZWNyYXdsRXJyb3IoYEV4dHJhY3Qgam9iICR7ZXh0cmFjdFN0YXR1cy5zdGF0dXN9LiBFcnJvcjogJHtleHRyYWN0U3RhdHVzLmVycm9yfWAsIHN0YXR1c1Jlc3BvbnNlLnN0YXR1cyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDFlMykpO1xuICAgICAgICB9IHdoaWxlIChleHRyYWN0U3RhdHVzLnN0YXR1cyAhPT0gXCJjb21wbGV0ZWRcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmhhbmRsZUVycm9yKHJlc3BvbnNlLCBcImV4dHJhY3RcIik7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBGaXJlY3Jhd2xFcnJvcihlcnJvci5tZXNzYWdlLCA1MDAsIGVycm9yLnJlc3BvbnNlPy5kYXRhPy5kZXRhaWxzKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBcIkludGVybmFsIHNlcnZlciBlcnJvci5cIiB9O1xuICB9XG4gIC8qKlxuICAgKiBJbml0aWF0ZXMgYW4gYXN5bmNocm9ub3VzIGV4dHJhY3Qgam9iIGZvciBhIFVSTCB1c2luZyB0aGUgRmlyZWNyYXdsIEFQSS5cbiAgICogQHBhcmFtIHVybCAtIFRoZSBVUkwgdG8gZXh0cmFjdCBkYXRhIGZyb20uXG4gICAqIEBwYXJhbSBwYXJhbXMgLSBBZGRpdGlvbmFsIHBhcmFtZXRlcnMgZm9yIHRoZSBleHRyYWN0IHJlcXVlc3QuXG4gICAqIEBwYXJhbSBpZGVtcG90ZW5jeUtleSAtIE9wdGlvbmFsIGlkZW1wb3RlbmN5IGtleSBmb3IgdGhlIHJlcXVlc3QuXG4gICAqIEByZXR1cm5zIFRoZSByZXNwb25zZSBmcm9tIHRoZSBleHRyYWN0IG9wZXJhdGlvbi5cbiAgICovXG4gIGFzeW5jIGFzeW5jRXh0cmFjdCh1cmxzLCBwYXJhbXMsIGlkZW1wb3RlbmN5S2V5KSB7XG4gICAgY29uc3QgaGVhZGVycyA9IHRoaXMucHJlcGFyZUhlYWRlcnMoaWRlbXBvdGVuY3lLZXkpO1xuICAgIGxldCBqc29uRGF0YSA9IHsgdXJscywgLi4ucGFyYW1zIH07XG4gICAgbGV0IGpzb25TY2hlbWE7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChwYXJhbXM/LnNjaGVtYSBpbnN0YW5jZW9mIHp0LlpvZFR5cGUpIHtcbiAgICAgICAganNvblNjaGVtYSA9IHpvZFRvSnNvblNjaGVtYShwYXJhbXMuc2NoZW1hKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGpzb25TY2hlbWEgPSBwYXJhbXM/LnNjaGVtYTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEZpcmVjcmF3bEVycm9yKFwiSW52YWxpZCBzY2hlbWEuIFNjaGVtYSBtdXN0IGJlIGVpdGhlciBhIHZhbGlkIFpvZCBzY2hlbWEgb3IgSlNPTiBzY2hlbWEgb2JqZWN0LlwiLCA0MDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnBvc3RSZXF1ZXN0KFxuICAgICAgICB0aGlzLmFwaVVybCArIGAvdjEvZXh0cmFjdGAsXG4gICAgICAgIHsgLi4uanNvbkRhdGEsIHNjaGVtYToganNvblNjaGVtYSB9LFxuICAgICAgICBoZWFkZXJzXG4gICAgICApO1xuICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5oYW5kbGVFcnJvcihyZXNwb25zZSwgXCJzdGFydCBleHRyYWN0IGpvYlwiKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEZpcmVjcmF3bEVycm9yKGVycm9yLm1lc3NhZ2UsIDUwMCwgZXJyb3IucmVzcG9uc2U/LmRhdGE/LmRldGFpbHMpO1xuICAgIH1cbiAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IFwiSW50ZXJuYWwgc2VydmVyIGVycm9yLlwiIH07XG4gIH1cbiAgLyoqXG4gICAqIFJldHJpZXZlcyB0aGUgc3RhdHVzIG9mIGFuIGV4dHJhY3Qgam9iLlxuICAgKiBAcGFyYW0gam9iSWQgLSBUaGUgSUQgb2YgdGhlIGV4dHJhY3Qgam9iLlxuICAgKiBAcmV0dXJucyBUaGUgc3RhdHVzIG9mIHRoZSBleHRyYWN0IGpvYi5cbiAgICovXG4gIGFzeW5jIGdldEV4dHJhY3RTdGF0dXMoam9iSWQpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmdldFJlcXVlc3QoXG4gICAgICAgIGAke3RoaXMuYXBpVXJsfS92MS9leHRyYWN0LyR7am9iSWR9YCxcbiAgICAgICAgdGhpcy5wcmVwYXJlSGVhZGVycygpXG4gICAgICApO1xuICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5oYW5kbGVFcnJvcihyZXNwb25zZSwgXCJnZXQgZXh0cmFjdCBzdGF0dXNcIik7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBGaXJlY3Jhd2xFcnJvcihlcnJvci5tZXNzYWdlLCA1MDApO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUHJlcGFyZXMgdGhlIGhlYWRlcnMgZm9yIGFuIEFQSSByZXF1ZXN0LlxuICAgKiBAcGFyYW0gaWRlbXBvdGVuY3lLZXkgLSBPcHRpb25hbCBrZXkgdG8gZW5zdXJlIGlkZW1wb3RlbmN5LlxuICAgKiBAcmV0dXJucyBUaGUgcHJlcGFyZWQgaGVhZGVycy5cbiAgICovXG4gIHByZXBhcmVIZWFkZXJzKGlkZW1wb3RlbmN5S2V5KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke3RoaXMuYXBpS2V5fWAsXG4gICAgICAuLi5pZGVtcG90ZW5jeUtleSA/IHsgXCJ4LWlkZW1wb3RlbmN5LWtleVwiOiBpZGVtcG90ZW5jeUtleSB9IDoge31cbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBTZW5kcyBhIFBPU1QgcmVxdWVzdCB0byB0aGUgc3BlY2lmaWVkIFVSTC5cbiAgICogQHBhcmFtIHVybCAtIFRoZSBVUkwgdG8gc2VuZCB0aGUgcmVxdWVzdCB0by5cbiAgICogQHBhcmFtIGRhdGEgLSBUaGUgZGF0YSB0byBzZW5kIGluIHRoZSByZXF1ZXN0LlxuICAgKiBAcGFyYW0gaGVhZGVycyAtIFRoZSBoZWFkZXJzIGZvciB0aGUgcmVxdWVzdC5cbiAgICogQHJldHVybnMgVGhlIHJlc3BvbnNlIGZyb20gdGhlIFBPU1QgcmVxdWVzdC5cbiAgICovXG4gIHBvc3RSZXF1ZXN0KHVybCwgZGF0YSwgaGVhZGVycykge1xuICAgIHJldHVybiBheGlvcy5wb3N0KHVybCwgZGF0YSwgeyBoZWFkZXJzLCB0aW1lb3V0OiBkYXRhPy50aW1lb3V0ID8gZGF0YS50aW1lb3V0ICsgNWUzIDogdm9pZCAwIH0pO1xuICB9XG4gIC8qKlxuICAgKiBTZW5kcyBhIEdFVCByZXF1ZXN0IHRvIHRoZSBzcGVjaWZpZWQgVVJMLlxuICAgKiBAcGFyYW0gdXJsIC0gVGhlIFVSTCB0byBzZW5kIHRoZSByZXF1ZXN0IHRvLlxuICAgKiBAcGFyYW0gaGVhZGVycyAtIFRoZSBoZWFkZXJzIGZvciB0aGUgcmVxdWVzdC5cbiAgICogQHJldHVybnMgVGhlIHJlc3BvbnNlIGZyb20gdGhlIEdFVCByZXF1ZXN0LlxuICAgKi9cbiAgYXN5bmMgZ2V0UmVxdWVzdCh1cmwsIGhlYWRlcnMpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGF3YWl0IGF4aW9zLmdldCh1cmwsIHsgaGVhZGVycyB9KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgQXhpb3NFcnJvciAmJiBlcnJvci5yZXNwb25zZSkge1xuICAgICAgICByZXR1cm4gZXJyb3IucmVzcG9uc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFNlbmRzIGEgREVMRVRFIHJlcXVlc3QgdG8gdGhlIHNwZWNpZmllZCBVUkwuXG4gICAqIEBwYXJhbSB1cmwgLSBUaGUgVVJMIHRvIHNlbmQgdGhlIHJlcXVlc3QgdG8uXG4gICAqIEBwYXJhbSBoZWFkZXJzIC0gVGhlIGhlYWRlcnMgZm9yIHRoZSByZXF1ZXN0LlxuICAgKiBAcmV0dXJucyBUaGUgcmVzcG9uc2UgZnJvbSB0aGUgREVMRVRFIHJlcXVlc3QuXG4gICAqL1xuICBhc3luYyBkZWxldGVSZXF1ZXN0KHVybCwgaGVhZGVycykge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgYXhpb3MuZGVsZXRlKHVybCwgeyBoZWFkZXJzIH0pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBBeGlvc0Vycm9yICYmIGVycm9yLnJlc3BvbnNlKSB7XG4gICAgICAgIHJldHVybiBlcnJvci5yZXNwb25zZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogTW9uaXRvcnMgdGhlIHN0YXR1cyBvZiBhIGNyYXdsIGpvYiB1bnRpbCBjb21wbGV0aW9uIG9yIGZhaWx1cmUuXG4gICAqIEBwYXJhbSBpZCAtIFRoZSBJRCBvZiB0aGUgY3Jhd2wgb3BlcmF0aW9uLlxuICAgKiBAcGFyYW0gaGVhZGVycyAtIFRoZSBoZWFkZXJzIGZvciB0aGUgcmVxdWVzdC5cbiAgICogQHBhcmFtIGNoZWNrSW50ZXJ2YWwgLSBJbnRlcnZhbCBpbiBzZWNvbmRzIGZvciBqb2Igc3RhdHVzIGNoZWNrcy5cbiAgICogQHBhcmFtIGNoZWNrVXJsIC0gT3B0aW9uYWwgVVJMIHRvIGNoZWNrIHRoZSBzdGF0dXMgKHVzZWQgZm9yIHYxIEFQSSlcbiAgICogQHJldHVybnMgVGhlIGZpbmFsIGpvYiBzdGF0dXMgb3IgZGF0YS5cbiAgICovXG4gIGFzeW5jIG1vbml0b3JKb2JTdGF0dXMoaWQsIGhlYWRlcnMsIGNoZWNrSW50ZXJ2YWwpIHtcbiAgICB0cnkge1xuICAgICAgbGV0IGZhaWxlZFRyaWVzID0gMDtcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGxldCBzdGF0dXNSZXNwb25zZSA9IGF3YWl0IHRoaXMuZ2V0UmVxdWVzdChcbiAgICAgICAgICBgJHt0aGlzLmFwaVVybH0vdjEvY3Jhd2wvJHtpZH1gLFxuICAgICAgICAgIGhlYWRlcnNcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKHN0YXR1c1Jlc3BvbnNlLnN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICAgICAgZmFpbGVkVHJpZXMgPSAwO1xuICAgICAgICAgIGxldCBzdGF0dXNEYXRhID0gc3RhdHVzUmVzcG9uc2UuZGF0YTtcbiAgICAgICAgICBpZiAoc3RhdHVzRGF0YS5zdGF0dXMgPT09IFwiY29tcGxldGVkXCIpIHtcbiAgICAgICAgICAgIGlmIChcImRhdGFcIiBpbiBzdGF0dXNEYXRhKSB7XG4gICAgICAgICAgICAgIGxldCBkYXRhID0gc3RhdHVzRGF0YS5kYXRhO1xuICAgICAgICAgICAgICB3aGlsZSAodHlwZW9mIHN0YXR1c0RhdGEgPT09IFwib2JqZWN0XCIgJiYgXCJuZXh0XCIgaW4gc3RhdHVzRGF0YSkge1xuICAgICAgICAgICAgICAgIGlmIChkYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0YXR1c1Jlc3BvbnNlID0gYXdhaXQgdGhpcy5nZXRSZXF1ZXN0KHN0YXR1c0RhdGEubmV4dCwgaGVhZGVycyk7XG4gICAgICAgICAgICAgICAgc3RhdHVzRGF0YSA9IHN0YXR1c1Jlc3BvbnNlLmRhdGE7XG4gICAgICAgICAgICAgICAgZGF0YSA9IGRhdGEuY29uY2F0KHN0YXR1c0RhdGEuZGF0YSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgc3RhdHVzRGF0YS5kYXRhID0gZGF0YTtcbiAgICAgICAgICAgICAgcmV0dXJuIHN0YXR1c0RhdGE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRmlyZWNyYXdsRXJyb3IoXCJDcmF3bCBqb2IgY29tcGxldGVkIGJ1dCBubyBkYXRhIHdhcyByZXR1cm5lZFwiLCA1MDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoW1wiYWN0aXZlXCIsIFwicGF1c2VkXCIsIFwicGVuZGluZ1wiLCBcInF1ZXVlZFwiLCBcIndhaXRpbmdcIiwgXCJzY3JhcGluZ1wiXS5pbmNsdWRlcyhzdGF0dXNEYXRhLnN0YXR1cykpIHtcbiAgICAgICAgICAgIGNoZWNrSW50ZXJ2YWwgPSBNYXRoLm1heChjaGVja0ludGVydmFsLCAyKTtcbiAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKFxuICAgICAgICAgICAgICAocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCBjaGVja0ludGVydmFsICogMWUzKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEZpcmVjcmF3bEVycm9yKFxuICAgICAgICAgICAgICBgQ3Jhd2wgam9iIGZhaWxlZCBvciB3YXMgc3RvcHBlZC4gU3RhdHVzOiAke3N0YXR1c0RhdGEuc3RhdHVzfWAsXG4gICAgICAgICAgICAgIDUwMFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZmFpbGVkVHJpZXMrKztcbiAgICAgICAgICBpZiAoZmFpbGVkVHJpZXMgPj0gMykge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVFcnJvcihzdGF0dXNSZXNwb25zZSwgXCJjaGVjayBjcmF3bCBzdGF0dXNcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBGaXJlY3Jhd2xFcnJvcihlcnJvciwgNTAwKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEhhbmRsZXMgZXJyb3JzIGZyb20gQVBJIHJlc3BvbnNlcy5cbiAgICogQHBhcmFtIHtBeGlvc1Jlc3BvbnNlfSByZXNwb25zZSAtIFRoZSByZXNwb25zZSBmcm9tIHRoZSBBUEkuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhY3Rpb24gLSBUaGUgYWN0aW9uIGJlaW5nIHBlcmZvcm1lZCB3aGVuIHRoZSBlcnJvciBvY2N1cnJlZC5cbiAgICovXG4gIGhhbmRsZUVycm9yKHJlc3BvbnNlLCBhY3Rpb24pIHtcbiAgICBpZiAoWzQwMCwgNDAyLCA0MDMsIDQwOCwgNDA5LCA1MDBdLmluY2x1ZGVzKHJlc3BvbnNlLnN0YXR1cykpIHtcbiAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IHJlc3BvbnNlLmRhdGEuZXJyb3IgfHwgXCJVbmtub3duIGVycm9yIG9jY3VycmVkXCI7XG4gICAgICBjb25zdCBkZXRhaWxzID0gcmVzcG9uc2UuZGF0YS5kZXRhaWxzID8gYCAtICR7SlNPTi5zdHJpbmdpZnkocmVzcG9uc2UuZGF0YS5kZXRhaWxzKX1gIDogXCJcIjtcbiAgICAgIHRocm93IG5ldyBGaXJlY3Jhd2xFcnJvcihcbiAgICAgICAgYEZhaWxlZCB0byAke2FjdGlvbn0uIFN0YXR1cyBjb2RlOiAke3Jlc3BvbnNlLnN0YXR1c30uIEVycm9yOiAke2Vycm9yTWVzc2FnZX0ke2RldGFpbHN9YCxcbiAgICAgICAgcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICByZXNwb25zZT8uZGF0YT8uZGV0YWlsc1xuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEZpcmVjcmF3bEVycm9yKFxuICAgICAgICBgVW5leHBlY3RlZCBlcnJvciBvY2N1cnJlZCB3aGlsZSB0cnlpbmcgdG8gJHthY3Rpb259LiBTdGF0dXMgY29kZTogJHtyZXNwb25zZS5zdGF0dXN9YCxcbiAgICAgICAgcmVzcG9uc2Uuc3RhdHVzXG4gICAgICApO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogSW5pdGlhdGVzIGEgZGVlcCByZXNlYXJjaCBvcGVyYXRpb24gb24gYSBnaXZlbiBxdWVyeSBhbmQgcG9sbHMgdW50aWwgY29tcGxldGlvbi5cbiAgICogQHBhcmFtIHF1ZXJ5IC0gVGhlIHF1ZXJ5IHRvIHJlc2VhcmNoLlxuICAgKiBAcGFyYW0gcGFyYW1zIC0gUGFyYW1ldGVycyBmb3IgdGhlIGRlZXAgcmVzZWFyY2ggb3BlcmF0aW9uLlxuICAgKiBAcGFyYW0gb25BY3Rpdml0eSAtIE9wdGlvbmFsIGNhbGxiYWNrIHRvIHJlY2VpdmUgYWN0aXZpdHkgdXBkYXRlcyBpbiByZWFsLXRpbWUuXG4gICAqIEBwYXJhbSBvblNvdXJjZSAtIE9wdGlvbmFsIGNhbGxiYWNrIHRvIHJlY2VpdmUgc291cmNlIHVwZGF0ZXMgaW4gcmVhbC10aW1lLlxuICAgKiBAcmV0dXJucyBUaGUgZmluYWwgcmVzZWFyY2ggcmVzdWx0cy5cbiAgICovXG4gIGFzeW5jIGRlZXBSZXNlYXJjaChxdWVyeSwgcGFyYW1zLCBvbkFjdGl2aXR5LCBvblNvdXJjZSkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuYXN5bmNEZWVwUmVzZWFyY2gocXVlcnksIHBhcmFtcyk7XG4gICAgICBpZiAoIXJlc3BvbnNlLnN1Y2Nlc3MgfHwgXCJlcnJvclwiIGluIHJlc3BvbnNlKSB7XG4gICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogXCJlcnJvclwiIGluIHJlc3BvbnNlID8gcmVzcG9uc2UuZXJyb3IgOiBcIlVua25vd24gZXJyb3JcIiB9O1xuICAgICAgfVxuICAgICAgaWYgKCFyZXNwb25zZS5pZCkge1xuICAgICAgICB0aHJvdyBuZXcgRmlyZWNyYXdsRXJyb3IoYEZhaWxlZCB0byBzdGFydCByZXNlYXJjaC4gTm8gam9iIElEIHJldHVybmVkLmAsIDUwMCk7XG4gICAgICB9XG4gICAgICBjb25zdCBqb2JJZCA9IHJlc3BvbnNlLmlkO1xuICAgICAgbGV0IHJlc2VhcmNoU3RhdHVzO1xuICAgICAgbGV0IGxhc3RBY3Rpdml0eUNvdW50ID0gMDtcbiAgICAgIGxldCBsYXN0U291cmNlQ291bnQgPSAwO1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgcmVzZWFyY2hTdGF0dXMgPSBhd2FpdCB0aGlzLmNoZWNrRGVlcFJlc2VhcmNoU3RhdHVzKGpvYklkKTtcbiAgICAgICAgaWYgKFwiZXJyb3JcIiBpbiByZXNlYXJjaFN0YXR1cyAmJiAhcmVzZWFyY2hTdGF0dXMuc3VjY2Vzcykge1xuICAgICAgICAgIHJldHVybiByZXNlYXJjaFN0YXR1cztcbiAgICAgICAgfVxuICAgICAgICBpZiAob25BY3Rpdml0eSAmJiByZXNlYXJjaFN0YXR1cy5hY3Rpdml0aWVzKSB7XG4gICAgICAgICAgY29uc3QgbmV3QWN0aXZpdGllcyA9IHJlc2VhcmNoU3RhdHVzLmFjdGl2aXRpZXMuc2xpY2UobGFzdEFjdGl2aXR5Q291bnQpO1xuICAgICAgICAgIGZvciAoY29uc3QgYWN0aXZpdHkgb2YgbmV3QWN0aXZpdGllcykge1xuICAgICAgICAgICAgb25BY3Rpdml0eShhY3Rpdml0eSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxhc3RBY3Rpdml0eUNvdW50ID0gcmVzZWFyY2hTdGF0dXMuYWN0aXZpdGllcy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uU291cmNlICYmIHJlc2VhcmNoU3RhdHVzLnNvdXJjZXMpIHtcbiAgICAgICAgICBjb25zdCBuZXdTb3VyY2VzID0gcmVzZWFyY2hTdGF0dXMuc291cmNlcy5zbGljZShsYXN0U291cmNlQ291bnQpO1xuICAgICAgICAgIGZvciAoY29uc3Qgc291cmNlIG9mIG5ld1NvdXJjZXMpIHtcbiAgICAgICAgICAgIG9uU291cmNlKHNvdXJjZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxhc3RTb3VyY2VDb3VudCA9IHJlc2VhcmNoU3RhdHVzLnNvdXJjZXMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXNlYXJjaFN0YXR1cy5zdGF0dXMgPT09IFwiY29tcGxldGVkXCIpIHtcbiAgICAgICAgICByZXR1cm4gcmVzZWFyY2hTdGF0dXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc2VhcmNoU3RhdHVzLnN0YXR1cyA9PT0gXCJmYWlsZWRcIikge1xuICAgICAgICAgIHRocm93IG5ldyBGaXJlY3Jhd2xFcnJvcihcbiAgICAgICAgICAgIGBSZXNlYXJjaCBqb2IgJHtyZXNlYXJjaFN0YXR1cy5zdGF0dXN9LiBFcnJvcjogJHtyZXNlYXJjaFN0YXR1cy5lcnJvcn1gLFxuICAgICAgICAgICAgNTAwXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzZWFyY2hTdGF0dXMuc3RhdHVzICE9PSBcInByb2Nlc3NpbmdcIikge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDJlMykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBcIlJlc2VhcmNoIGpvYiB0ZXJtaW5hdGVkIHVuZXhwZWN0ZWRseVwiIH07XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBGaXJlY3Jhd2xFcnJvcihlcnJvci5tZXNzYWdlLCA1MDAsIGVycm9yLnJlc3BvbnNlPy5kYXRhPy5kZXRhaWxzKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEluaXRpYXRlcyBhIGRlZXAgcmVzZWFyY2ggb3BlcmF0aW9uIG9uIGEgZ2l2ZW4gcXVlcnkgd2l0aG91dCBwb2xsaW5nLlxuICAgKiBAcGFyYW0gcGFyYW1zIC0gUGFyYW1ldGVycyBmb3IgdGhlIGRlZXAgcmVzZWFyY2ggb3BlcmF0aW9uLlxuICAgKiBAcmV0dXJucyBUaGUgcmVzcG9uc2UgY29udGFpbmluZyB0aGUgcmVzZWFyY2ggam9iIElELlxuICAgKi9cbiAgYXN5bmMgYXN5bmNEZWVwUmVzZWFyY2gocXVlcnksIHBhcmFtcykge1xuICAgIGNvbnN0IGhlYWRlcnMgPSB0aGlzLnByZXBhcmVIZWFkZXJzKCk7XG4gICAgbGV0IGpzb25EYXRhID0geyBxdWVyeSwgLi4ucGFyYW1zIH07XG4gICAgaWYgKGpzb25EYXRhPy5qc29uT3B0aW9ucz8uc2NoZW1hKSB7XG4gICAgICBsZXQgc2NoZW1hID0ganNvbkRhdGEuanNvbk9wdGlvbnMuc2NoZW1hO1xuICAgICAgdHJ5IHtcbiAgICAgICAgc2NoZW1hID0gem9kVG9Kc29uU2NoZW1hKHNjaGVtYSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgfVxuICAgICAganNvbkRhdGEgPSB7XG4gICAgICAgIC4uLmpzb25EYXRhLFxuICAgICAgICBqc29uT3B0aW9uczoge1xuICAgICAgICAgIC4uLmpzb25EYXRhLmpzb25PcHRpb25zLFxuICAgICAgICAgIHNjaGVtYVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnBvc3RSZXF1ZXN0KFxuICAgICAgICBgJHt0aGlzLmFwaVVybH0vdjEvZGVlcC1yZXNlYXJjaGAsXG4gICAgICAgIGpzb25EYXRhLFxuICAgICAgICBoZWFkZXJzXG4gICAgICApO1xuICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5oYW5kbGVFcnJvcihyZXNwb25zZSwgXCJzdGFydCBkZWVwIHJlc2VhcmNoXCIpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoZXJyb3IucmVzcG9uc2U/LmRhdGE/LmVycm9yKSB7XG4gICAgICAgIHRocm93IG5ldyBGaXJlY3Jhd2xFcnJvcihgUmVxdWVzdCBmYWlsZWQgd2l0aCBzdGF0dXMgY29kZSAke2Vycm9yLnJlc3BvbnNlLnN0YXR1c30uIEVycm9yOiAke2Vycm9yLnJlc3BvbnNlLmRhdGEuZXJyb3J9ICR7ZXJyb3IucmVzcG9uc2UuZGF0YS5kZXRhaWxzID8gYCAtICR7SlNPTi5zdHJpbmdpZnkoZXJyb3IucmVzcG9uc2UuZGF0YS5kZXRhaWxzKX1gIDogXCJcIn1gLCBlcnJvci5yZXNwb25zZS5zdGF0dXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEZpcmVjcmF3bEVycm9yKGVycm9yLm1lc3NhZ2UsIDUwMCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogXCJJbnRlcm5hbCBzZXJ2ZXIgZXJyb3IuXCIgfTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2tzIHRoZSBzdGF0dXMgb2YgYSBkZWVwIHJlc2VhcmNoIG9wZXJhdGlvbi5cbiAgICogQHBhcmFtIGlkIC0gVGhlIElEIG9mIHRoZSBkZWVwIHJlc2VhcmNoIG9wZXJhdGlvbi5cbiAgICogQHJldHVybnMgVGhlIGN1cnJlbnQgc3RhdHVzIGFuZCByZXN1bHRzIG9mIHRoZSByZXNlYXJjaCBvcGVyYXRpb24uXG4gICAqL1xuICBhc3luYyBjaGVja0RlZXBSZXNlYXJjaFN0YXR1cyhpZCkge1xuICAgIGNvbnN0IGhlYWRlcnMgPSB0aGlzLnByZXBhcmVIZWFkZXJzKCk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5nZXRSZXF1ZXN0KFxuICAgICAgICBgJHt0aGlzLmFwaVVybH0vdjEvZGVlcC1yZXNlYXJjaC8ke2lkfWAsXG4gICAgICAgIGhlYWRlcnNcbiAgICAgICk7XG4gICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgICB9IGVsc2UgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDA0KSB7XG4gICAgICAgIHRocm93IG5ldyBGaXJlY3Jhd2xFcnJvcihcIkRlZXAgcmVzZWFyY2ggam9iIG5vdCBmb3VuZFwiLCA0MDQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5oYW5kbGVFcnJvcihyZXNwb25zZSwgXCJjaGVjayBkZWVwIHJlc2VhcmNoIHN0YXR1c1wiKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGVycm9yLnJlc3BvbnNlPy5kYXRhPy5lcnJvcikge1xuICAgICAgICB0aHJvdyBuZXcgRmlyZWNyYXdsRXJyb3IoYFJlcXVlc3QgZmFpbGVkIHdpdGggc3RhdHVzIGNvZGUgJHtlcnJvci5yZXNwb25zZS5zdGF0dXN9LiBFcnJvcjogJHtlcnJvci5yZXNwb25zZS5kYXRhLmVycm9yfSAke2Vycm9yLnJlc3BvbnNlLmRhdGEuZGV0YWlscyA/IGAgLSAke0pTT04uc3RyaW5naWZ5KGVycm9yLnJlc3BvbnNlLmRhdGEuZGV0YWlscyl9YCA6IFwiXCJ9YCwgZXJyb3IucmVzcG9uc2Uuc3RhdHVzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBGaXJlY3Jhd2xFcnJvcihlcnJvci5tZXNzYWdlLCA1MDApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IFwiSW50ZXJuYWwgc2VydmVyIGVycm9yLlwiIH07XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBkZWVwUmVzZWFyY2goKSBpbnN0ZWFkXG4gICAqIEluaXRpYXRlcyBhIGRlZXAgcmVzZWFyY2ggb3BlcmF0aW9uIG9uIGEgZ2l2ZW4gdG9waWMgYW5kIHBvbGxzIHVudGlsIGNvbXBsZXRpb24uXG4gICAqIEBwYXJhbSB0b3BpYyAtIFRoZSB0b3BpYyB0byByZXNlYXJjaC5cbiAgICogQHBhcmFtIHBhcmFtcyAtIFBhcmFtZXRlcnMgZm9yIHRoZSBkZWVwIHJlc2VhcmNoIG9wZXJhdGlvbi5cbiAgICogQHBhcmFtIG9uQWN0aXZpdHkgLSBPcHRpb25hbCBjYWxsYmFjayB0byByZWNlaXZlIGFjdGl2aXR5IHVwZGF0ZXMgaW4gcmVhbC10aW1lLlxuICAgKiBAcmV0dXJucyBUaGUgZmluYWwgcmVzZWFyY2ggcmVzdWx0cy5cbiAgICovXG4gIGFzeW5jIF9fZGVlcFJlc2VhcmNoKHRvcGljLCBwYXJhbXMsIG9uQWN0aXZpdHkpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9fYXN5bmNEZWVwUmVzZWFyY2godG9waWMsIHBhcmFtcyk7XG4gICAgICBpZiAoIXJlc3BvbnNlLnN1Y2Nlc3MgfHwgXCJlcnJvclwiIGluIHJlc3BvbnNlKSB7XG4gICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogXCJlcnJvclwiIGluIHJlc3BvbnNlID8gcmVzcG9uc2UuZXJyb3IgOiBcIlVua25vd24gZXJyb3JcIiB9O1xuICAgICAgfVxuICAgICAgaWYgKCFyZXNwb25zZS5pZCkge1xuICAgICAgICB0aHJvdyBuZXcgRmlyZWNyYXdsRXJyb3IoYEZhaWxlZCB0byBzdGFydCByZXNlYXJjaC4gTm8gam9iIElEIHJldHVybmVkLmAsIDUwMCk7XG4gICAgICB9XG4gICAgICBjb25zdCBqb2JJZCA9IHJlc3BvbnNlLmlkO1xuICAgICAgbGV0IHJlc2VhcmNoU3RhdHVzO1xuICAgICAgbGV0IGxhc3RBY3Rpdml0eUNvdW50ID0gMDtcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHJlc2VhcmNoU3RhdHVzID0gYXdhaXQgdGhpcy5fX2NoZWNrRGVlcFJlc2VhcmNoU3RhdHVzKGpvYklkKTtcbiAgICAgICAgaWYgKFwiZXJyb3JcIiBpbiByZXNlYXJjaFN0YXR1cyAmJiAhcmVzZWFyY2hTdGF0dXMuc3VjY2Vzcykge1xuICAgICAgICAgIHJldHVybiByZXNlYXJjaFN0YXR1cztcbiAgICAgICAgfVxuICAgICAgICBpZiAob25BY3Rpdml0eSAmJiByZXNlYXJjaFN0YXR1cy5hY3Rpdml0aWVzKSB7XG4gICAgICAgICAgY29uc3QgbmV3QWN0aXZpdGllcyA9IHJlc2VhcmNoU3RhdHVzLmFjdGl2aXRpZXMuc2xpY2UobGFzdEFjdGl2aXR5Q291bnQpO1xuICAgICAgICAgIGZvciAoY29uc3QgYWN0aXZpdHkgb2YgbmV3QWN0aXZpdGllcykge1xuICAgICAgICAgICAgb25BY3Rpdml0eShhY3Rpdml0eSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxhc3RBY3Rpdml0eUNvdW50ID0gcmVzZWFyY2hTdGF0dXMuYWN0aXZpdGllcy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc2VhcmNoU3RhdHVzLnN0YXR1cyA9PT0gXCJjb21wbGV0ZWRcIikge1xuICAgICAgICAgIHJldHVybiByZXNlYXJjaFN0YXR1cztcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzZWFyY2hTdGF0dXMuc3RhdHVzID09PSBcImZhaWxlZFwiKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZpcmVjcmF3bEVycm9yKFxuICAgICAgICAgICAgYFJlc2VhcmNoIGpvYiAke3Jlc2VhcmNoU3RhdHVzLnN0YXR1c30uIEVycm9yOiAke3Jlc2VhcmNoU3RhdHVzLmVycm9yfWAsXG4gICAgICAgICAgICA1MDBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXNlYXJjaFN0YXR1cy5zdGF0dXMgIT09IFwicHJvY2Vzc2luZ1wiKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMmUzKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IFwiUmVzZWFyY2ggam9iIHRlcm1pbmF0ZWQgdW5leHBlY3RlZGx5XCIgfTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEZpcmVjcmF3bEVycm9yKGVycm9yLm1lc3NhZ2UsIDUwMCwgZXJyb3IucmVzcG9uc2U/LmRhdGE/LmRldGFpbHMpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGFzeW5jRGVlcFJlc2VhcmNoKCkgaW5zdGVhZFxuICAgKiBJbml0aWF0ZXMgYSBkZWVwIHJlc2VhcmNoIG9wZXJhdGlvbiBvbiBhIGdpdmVuIHRvcGljIHdpdGhvdXQgcG9sbGluZy5cbiAgICogQHBhcmFtIHBhcmFtcyAtIFBhcmFtZXRlcnMgZm9yIHRoZSBkZWVwIHJlc2VhcmNoIG9wZXJhdGlvbi5cbiAgICogQHJldHVybnMgVGhlIHJlc3BvbnNlIGNvbnRhaW5pbmcgdGhlIHJlc2VhcmNoIGpvYiBJRC5cbiAgICovXG4gIGFzeW5jIF9fYXN5bmNEZWVwUmVzZWFyY2godG9waWMsIHBhcmFtcykge1xuICAgIGNvbnN0IGhlYWRlcnMgPSB0aGlzLnByZXBhcmVIZWFkZXJzKCk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wb3N0UmVxdWVzdChcbiAgICAgICAgYCR7dGhpcy5hcGlVcmx9L3YxL2RlZXAtcmVzZWFyY2hgLFxuICAgICAgICB7IHRvcGljLCAuLi5wYXJhbXMgfSxcbiAgICAgICAgaGVhZGVyc1xuICAgICAgKTtcbiAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuaGFuZGxlRXJyb3IocmVzcG9uc2UsIFwic3RhcnQgZGVlcCByZXNlYXJjaFwiKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGVycm9yLnJlc3BvbnNlPy5kYXRhPy5lcnJvcikge1xuICAgICAgICB0aHJvdyBuZXcgRmlyZWNyYXdsRXJyb3IoYFJlcXVlc3QgZmFpbGVkIHdpdGggc3RhdHVzIGNvZGUgJHtlcnJvci5yZXNwb25zZS5zdGF0dXN9LiBFcnJvcjogJHtlcnJvci5yZXNwb25zZS5kYXRhLmVycm9yfSAke2Vycm9yLnJlc3BvbnNlLmRhdGEuZGV0YWlscyA/IGAgLSAke0pTT04uc3RyaW5naWZ5KGVycm9yLnJlc3BvbnNlLmRhdGEuZGV0YWlscyl9YCA6IFwiXCJ9YCwgZXJyb3IucmVzcG9uc2Uuc3RhdHVzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBGaXJlY3Jhd2xFcnJvcihlcnJvci5tZXNzYWdlLCA1MDApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IFwiSW50ZXJuYWwgc2VydmVyIGVycm9yLlwiIH07XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBjaGVja0RlZXBSZXNlYXJjaFN0YXR1cygpIGluc3RlYWRcbiAgICogQ2hlY2tzIHRoZSBzdGF0dXMgb2YgYSBkZWVwIHJlc2VhcmNoIG9wZXJhdGlvbi5cbiAgICogQHBhcmFtIGlkIC0gVGhlIElEIG9mIHRoZSBkZWVwIHJlc2VhcmNoIG9wZXJhdGlvbi5cbiAgICogQHJldHVybnMgVGhlIGN1cnJlbnQgc3RhdHVzIGFuZCByZXN1bHRzIG9mIHRoZSByZXNlYXJjaCBvcGVyYXRpb24uXG4gICAqL1xuICBhc3luYyBfX2NoZWNrRGVlcFJlc2VhcmNoU3RhdHVzKGlkKSB7XG4gICAgY29uc3QgaGVhZGVycyA9IHRoaXMucHJlcGFyZUhlYWRlcnMoKTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmdldFJlcXVlc3QoXG4gICAgICAgIGAke3RoaXMuYXBpVXJsfS92MS9kZWVwLXJlc2VhcmNoLyR7aWR9YCxcbiAgICAgICAgaGVhZGVyc1xuICAgICAgKTtcbiAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICAgIH0gZWxzZSBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MDQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEZpcmVjcmF3bEVycm9yKFwiRGVlcCByZXNlYXJjaCBqb2Igbm90IGZvdW5kXCIsIDQwNCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmhhbmRsZUVycm9yKHJlc3BvbnNlLCBcImNoZWNrIGRlZXAgcmVzZWFyY2ggc3RhdHVzXCIpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoZXJyb3IucmVzcG9uc2U/LmRhdGE/LmVycm9yKSB7XG4gICAgICAgIHRocm93IG5ldyBGaXJlY3Jhd2xFcnJvcihgUmVxdWVzdCBmYWlsZWQgd2l0aCBzdGF0dXMgY29kZSAke2Vycm9yLnJlc3BvbnNlLnN0YXR1c30uIEVycm9yOiAke2Vycm9yLnJlc3BvbnNlLmRhdGEuZXJyb3J9ICR7ZXJyb3IucmVzcG9uc2UuZGF0YS5kZXRhaWxzID8gYCAtICR7SlNPTi5zdHJpbmdpZnkoZXJyb3IucmVzcG9uc2UuZGF0YS5kZXRhaWxzKX1gIDogXCJcIn1gLCBlcnJvci5yZXNwb25zZS5zdGF0dXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEZpcmVjcmF3bEVycm9yKGVycm9yLm1lc3NhZ2UsIDUwMCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogXCJJbnRlcm5hbCBzZXJ2ZXIgZXJyb3IuXCIgfTtcbiAgfVxuICAvKipcbiAgICogR2VuZXJhdGVzIExMTXMudHh0IGZvciBhIGdpdmVuIFVSTCBhbmQgcG9sbHMgdW50aWwgY29tcGxldGlvbi5cbiAgICogQHBhcmFtIHVybCAtIFRoZSBVUkwgdG8gZ2VuZXJhdGUgTExNcy50eHQgZnJvbS5cbiAgICogQHBhcmFtIHBhcmFtcyAtIFBhcmFtZXRlcnMgZm9yIHRoZSBMTE1zLnR4dCBnZW5lcmF0aW9uIG9wZXJhdGlvbi5cbiAgICogQHJldHVybnMgVGhlIGZpbmFsIGdlbmVyYXRpb24gcmVzdWx0cy5cbiAgICovXG4gIGFzeW5jIGdlbmVyYXRlTExNc1RleHQodXJsLCBwYXJhbXMpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmFzeW5jR2VuZXJhdGVMTE1zVGV4dCh1cmwsIHBhcmFtcyk7XG4gICAgICBpZiAoIXJlc3BvbnNlLnN1Y2Nlc3MgfHwgXCJlcnJvclwiIGluIHJlc3BvbnNlKSB7XG4gICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogXCJlcnJvclwiIGluIHJlc3BvbnNlID8gcmVzcG9uc2UuZXJyb3IgOiBcIlVua25vd24gZXJyb3JcIiB9O1xuICAgICAgfVxuICAgICAgaWYgKCFyZXNwb25zZS5pZCkge1xuICAgICAgICB0aHJvdyBuZXcgRmlyZWNyYXdsRXJyb3IoYEZhaWxlZCB0byBzdGFydCBMTE1zLnR4dCBnZW5lcmF0aW9uLiBObyBqb2IgSUQgcmV0dXJuZWQuYCwgNTAwKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGpvYklkID0gcmVzcG9uc2UuaWQ7XG4gICAgICBsZXQgZ2VuZXJhdGlvblN0YXR1cztcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGdlbmVyYXRpb25TdGF0dXMgPSBhd2FpdCB0aGlzLmNoZWNrR2VuZXJhdGVMTE1zVGV4dFN0YXR1cyhqb2JJZCk7XG4gICAgICAgIGlmIChcImVycm9yXCIgaW4gZ2VuZXJhdGlvblN0YXR1cyAmJiAhZ2VuZXJhdGlvblN0YXR1cy5zdWNjZXNzKSB7XG4gICAgICAgICAgcmV0dXJuIGdlbmVyYXRpb25TdGF0dXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdlbmVyYXRpb25TdGF0dXMuc3RhdHVzID09PSBcImNvbXBsZXRlZFwiKSB7XG4gICAgICAgICAgcmV0dXJuIGdlbmVyYXRpb25TdGF0dXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdlbmVyYXRpb25TdGF0dXMuc3RhdHVzID09PSBcImZhaWxlZFwiKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZpcmVjcmF3bEVycm9yKFxuICAgICAgICAgICAgYExMTXMudHh0IGdlbmVyYXRpb24gam9iICR7Z2VuZXJhdGlvblN0YXR1cy5zdGF0dXN9LiBFcnJvcjogJHtnZW5lcmF0aW9uU3RhdHVzLmVycm9yfWAsXG4gICAgICAgICAgICA1MDBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChnZW5lcmF0aW9uU3RhdHVzLnN0YXR1cyAhPT0gXCJwcm9jZXNzaW5nXCIpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCAyZTMpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogXCJMTE1zLnR4dCBnZW5lcmF0aW9uIGpvYiB0ZXJtaW5hdGVkIHVuZXhwZWN0ZWRseVwiIH07XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBGaXJlY3Jhd2xFcnJvcihlcnJvci5tZXNzYWdlLCA1MDAsIGVycm9yLnJlc3BvbnNlPy5kYXRhPy5kZXRhaWxzKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEluaXRpYXRlcyBhIExMTXMudHh0IGdlbmVyYXRpb24gb3BlcmF0aW9uIHdpdGhvdXQgcG9sbGluZy5cbiAgICogQHBhcmFtIHVybCAtIFRoZSBVUkwgdG8gZ2VuZXJhdGUgTExNcy50eHQgZnJvbS5cbiAgICogQHBhcmFtIHBhcmFtcyAtIFBhcmFtZXRlcnMgZm9yIHRoZSBMTE1zLnR4dCBnZW5lcmF0aW9uIG9wZXJhdGlvbi5cbiAgICogQHJldHVybnMgVGhlIHJlc3BvbnNlIGNvbnRhaW5pbmcgdGhlIGdlbmVyYXRpb24gam9iIElELlxuICAgKi9cbiAgYXN5bmMgYXN5bmNHZW5lcmF0ZUxMTXNUZXh0KHVybCwgcGFyYW1zKSB7XG4gICAgY29uc3QgaGVhZGVycyA9IHRoaXMucHJlcGFyZUhlYWRlcnMoKTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnBvc3RSZXF1ZXN0KFxuICAgICAgICBgJHt0aGlzLmFwaVVybH0vdjEvbGxtc3R4dGAsXG4gICAgICAgIHsgdXJsLCAuLi5wYXJhbXMgfSxcbiAgICAgICAgaGVhZGVyc1xuICAgICAgKTtcbiAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuaGFuZGxlRXJyb3IocmVzcG9uc2UsIFwic3RhcnQgTExNcy50eHQgZ2VuZXJhdGlvblwiKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGVycm9yLnJlc3BvbnNlPy5kYXRhPy5lcnJvcikge1xuICAgICAgICB0aHJvdyBuZXcgRmlyZWNyYXdsRXJyb3IoYFJlcXVlc3QgZmFpbGVkIHdpdGggc3RhdHVzIGNvZGUgJHtlcnJvci5yZXNwb25zZS5zdGF0dXN9LiBFcnJvcjogJHtlcnJvci5yZXNwb25zZS5kYXRhLmVycm9yfSAke2Vycm9yLnJlc3BvbnNlLmRhdGEuZGV0YWlscyA/IGAgLSAke0pTT04uc3RyaW5naWZ5KGVycm9yLnJlc3BvbnNlLmRhdGEuZGV0YWlscyl9YCA6IFwiXCJ9YCwgZXJyb3IucmVzcG9uc2Uuc3RhdHVzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBGaXJlY3Jhd2xFcnJvcihlcnJvci5tZXNzYWdlLCA1MDApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IFwiSW50ZXJuYWwgc2VydmVyIGVycm9yLlwiIH07XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrcyB0aGUgc3RhdHVzIG9mIGEgTExNcy50eHQgZ2VuZXJhdGlvbiBvcGVyYXRpb24uXG4gICAqIEBwYXJhbSBpZCAtIFRoZSBJRCBvZiB0aGUgTExNcy50eHQgZ2VuZXJhdGlvbiBvcGVyYXRpb24uXG4gICAqIEByZXR1cm5zIFRoZSBjdXJyZW50IHN0YXR1cyBhbmQgcmVzdWx0cyBvZiB0aGUgZ2VuZXJhdGlvbiBvcGVyYXRpb24uXG4gICAqL1xuICBhc3luYyBjaGVja0dlbmVyYXRlTExNc1RleHRTdGF0dXMoaWQpIHtcbiAgICBjb25zdCBoZWFkZXJzID0gdGhpcy5wcmVwYXJlSGVhZGVycygpO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZ2V0UmVxdWVzdChcbiAgICAgICAgYCR7dGhpcy5hcGlVcmx9L3YxL2xsbXN0eHQvJHtpZH1gLFxuICAgICAgICBoZWFkZXJzXG4gICAgICApO1xuICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICAgICAgfSBlbHNlIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQwNCkge1xuICAgICAgICB0aHJvdyBuZXcgRmlyZWNyYXdsRXJyb3IoXCJMTE1zLnR4dCBnZW5lcmF0aW9uIGpvYiBub3QgZm91bmRcIiwgNDA0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuaGFuZGxlRXJyb3IocmVzcG9uc2UsIFwiY2hlY2sgTExNcy50eHQgZ2VuZXJhdGlvbiBzdGF0dXNcIik7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvci5yZXNwb25zZT8uZGF0YT8uZXJyb3IpIHtcbiAgICAgICAgdGhyb3cgbmV3IEZpcmVjcmF3bEVycm9yKGBSZXF1ZXN0IGZhaWxlZCB3aXRoIHN0YXR1cyBjb2RlICR7ZXJyb3IucmVzcG9uc2Uuc3RhdHVzfS4gRXJyb3I6ICR7ZXJyb3IucmVzcG9uc2UuZGF0YS5lcnJvcn0gJHtlcnJvci5yZXNwb25zZS5kYXRhLmRldGFpbHMgPyBgIC0gJHtKU09OLnN0cmluZ2lmeShlcnJvci5yZXNwb25zZS5kYXRhLmRldGFpbHMpfWAgOiBcIlwifWAsIGVycm9yLnJlc3BvbnNlLnN0YXR1cyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRmlyZWNyYXdsRXJyb3IoZXJyb3IubWVzc2FnZSwgNTAwKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBcIkludGVybmFsIHNlcnZlciBlcnJvci5cIiB9O1xuICB9XG59O1xudmFyIENyYXdsV2F0Y2hlciA9IGNsYXNzIGV4dGVuZHMgVHlwZWRFdmVudFRhcmdldCB7XG4gIHdzO1xuICBkYXRhO1xuICBzdGF0dXM7XG4gIGlkO1xuICBjb25zdHJ1Y3RvcihpZCwgYXBwKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmlkID0gaWQ7XG4gICAgY29uc3Qgd3NVcmwgPSBhcHAuYXBpVXJsLnJlcGxhY2UoL15odHRwLywgXCJ3c1wiKTtcbiAgICB0aGlzLndzID0gbmV3IFdlYlNvY2tldChgJHt3c1VybH0vdjEvY3Jhd2wvJHtpZH1gLCBhcHAuYXBpS2V5KTtcbiAgICB0aGlzLnN0YXR1cyA9IFwic2NyYXBpbmdcIjtcbiAgICB0aGlzLmRhdGEgPSBbXTtcbiAgICBjb25zdCBtZXNzYWdlSGFuZGxlciA9IChtc2cpID0+IHtcbiAgICAgIGlmIChtc2cudHlwZSA9PT0gXCJkb25lXCIpIHtcbiAgICAgICAgdGhpcy5zdGF0dXMgPSBcImNvbXBsZXRlZFwiO1xuICAgICAgICB0aGlzLmRpc3BhdGNoVHlwZWRFdmVudChcImRvbmVcIiwgbmV3IEN1c3RvbUV2ZW50KFwiZG9uZVwiLCB7XG4gICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICBzdGF0dXM6IHRoaXMuc3RhdHVzLFxuICAgICAgICAgICAgZGF0YTogdGhpcy5kYXRhLFxuICAgICAgICAgICAgaWQ6IHRoaXMuaWRcbiAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICAgIH0gZWxzZSBpZiAobXNnLnR5cGUgPT09IFwiZXJyb3JcIikge1xuICAgICAgICB0aGlzLnN0YXR1cyA9IFwiZmFpbGVkXCI7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hUeXBlZEV2ZW50KFwiZXJyb3JcIiwgbmV3IEN1c3RvbUV2ZW50KFwiZXJyb3JcIiwge1xuICAgICAgICAgIGRldGFpbDoge1xuICAgICAgICAgICAgc3RhdHVzOiB0aGlzLnN0YXR1cyxcbiAgICAgICAgICAgIGRhdGE6IHRoaXMuZGF0YSxcbiAgICAgICAgICAgIGVycm9yOiBtc2cuZXJyb3IsXG4gICAgICAgICAgICBpZDogdGhpcy5pZFxuICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgICAgfSBlbHNlIGlmIChtc2cudHlwZSA9PT0gXCJjYXRjaHVwXCIpIHtcbiAgICAgICAgdGhpcy5zdGF0dXMgPSBtc2cuZGF0YS5zdGF0dXM7XG4gICAgICAgIHRoaXMuZGF0YS5wdXNoKC4uLm1zZy5kYXRhLmRhdGEgPz8gW10pO1xuICAgICAgICBmb3IgKGNvbnN0IGRvYyBvZiB0aGlzLmRhdGEpIHtcbiAgICAgICAgICB0aGlzLmRpc3BhdGNoVHlwZWRFdmVudChcImRvY3VtZW50XCIsIG5ldyBDdXN0b21FdmVudChcImRvY3VtZW50XCIsIHtcbiAgICAgICAgICAgIGRldGFpbDoge1xuICAgICAgICAgICAgICAuLi5kb2MsXG4gICAgICAgICAgICAgIGlkOiB0aGlzLmlkXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG1zZy50eXBlID09PSBcImRvY3VtZW50XCIpIHtcbiAgICAgICAgdGhpcy5kaXNwYXRjaFR5cGVkRXZlbnQoXCJkb2N1bWVudFwiLCBuZXcgQ3VzdG9tRXZlbnQoXCJkb2N1bWVudFwiLCB7XG4gICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICAuLi5tc2cuZGF0YSxcbiAgICAgICAgICAgIGlkOiB0aGlzLmlkXG4gICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLndzLm9ubWVzc2FnZSA9ICgoZXYpID0+IHtcbiAgICAgIGlmICh0eXBlb2YgZXYuZGF0YSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICB0aGlzLndzLmNsb3NlKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IG1zZyA9IEpTT04ucGFyc2UoZXYuZGF0YSk7XG4gICAgICAgIG1lc3NhZ2VIYW5kbGVyKG1zZyk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3Igb24gbWVzc2FnZVwiLCBlcnJvcik7XG4gICAgICB9XG4gICAgfSkuYmluZCh0aGlzKTtcbiAgICB0aGlzLndzLm9uY2xvc2UgPSAoKGV2KSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBtc2cgPSBKU09OLnBhcnNlKGV2LnJlYXNvbik7XG4gICAgICAgIG1lc3NhZ2VIYW5kbGVyKG1zZyk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3Igb24gY2xvc2VcIiwgZXJyb3IpO1xuICAgICAgfVxuICAgIH0pLmJpbmQodGhpcyk7XG4gICAgdGhpcy53cy5vbmVycm9yID0gKChfKSA9PiB7XG4gICAgICB0aGlzLnN0YXR1cyA9IFwiZmFpbGVkXCI7XG4gICAgICB0aGlzLmRpc3BhdGNoVHlwZWRFdmVudChcImVycm9yXCIsIG5ldyBDdXN0b21FdmVudChcImVycm9yXCIsIHtcbiAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgc3RhdHVzOiB0aGlzLnN0YXR1cyxcbiAgICAgICAgICBkYXRhOiB0aGlzLmRhdGEsXG4gICAgICAgICAgZXJyb3I6IFwiV2ViU29ja2V0IGVycm9yXCIsXG4gICAgICAgICAgaWQ6IHRoaXMuaWRcbiAgICAgICAgfVxuICAgICAgfSkpO1xuICAgIH0pLmJpbmQodGhpcyk7XG4gIH1cbiAgY2xvc2UoKSB7XG4gICAgdGhpcy53cy5jbG9zZSgpO1xuICB9XG59O1xuZXhwb3J0IHtcbiAgQ3Jhd2xXYXRjaGVyLFxuICBGaXJlY3Jhd2xFcnJvcixcbiAgRmlyZWNyYXdsQXBwIGFzIGRlZmF1bHRcbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@mendable/firecrawl-js/dist/index.js\n");

/***/ })

};
;